unit Blend2D;
{ OPP wrappers for Blend2D C API.

  Follows the C++ API as closely as possible. }

{$MINENUMSIZE 4}
{$SCOPEDENUMS ON}
{$EXCESSPRECISION OFF}

interface

uses
  System.SysUtils,
  System.UITypes,
  System.Math;

{$REGION 'Common Types'}
type
  {$IF Defined(MACOS)}
  Size_T = LongWord;
  {$ELSE}
  Size_T = NativeUInt;
  {$ENDIF}
  PSize_T = ^Size_T;
{$ENDREGION 'Common Types'}

{$REGION 'Error Handling'}

{ ============================================================================
   [Error Handling - Enums]
  ============================================================================ }

type
  /// <summary>
  ///  Blend2D result code.
  /// </summary>
  TBLResult = (
    /// <summary>Successful result code.</summary>
    Success = 0,

    /// <summary>Out of memory [ENOMEM].</summary>
    OutOfMemory = $00010000,

    /// <summary>Invalid value/argument [EINVAL].</summary>
    InvalidValue,

    /// <summary>Invalid state [EFAULT].</summary>
    InvalidState,

    /// <summary>Invalid handle or file [EBADF].</summary>
    InvalidHandle,

    /// <summary>Invalid conversion.</summary>
    InvalidConversion,

    /// <summary>Value too large [EOVERFLOW].</summary>
    Overflow,

    /// <summary>Object not initialized.</summary>
    NotInitialized,

    /// <summary>Not implemented [ENOSYS].</summary>
    NotImplemented,

    /// <summary>Operation not permitted [EPERM].</summary>
    NotPermitted,

    /// <summary>IO error [EIO].</summary>
    IOError,

    /// <summary>Device or resource busy [EBUSY].</summary>
    Busy,

    /// <summary>Operation interrupted [EINTR].</summary>
    Interrupted,

    /// <summary>Try again [EAGAIN].</summary>
    TryAgain,

    /// <summary>Timed out [ETIMEDOUT].</summary>
    TimedOut,

    /// <summary>Broken pipe [EPIPE].</summary>
    BrokenPipe,

    /// <summary>File is not seekable [ESPIPE].</summary>
    InvalidSeek,

    /// <summary>Too many levels of symlinks [ELOOP].</summary>
    SymlinkLoop,

    /// <summary>File is too large [EFBIG].</summary>
    FileTooLarge,

    /// <summary>File/directory already exists [EEXIST].</summary>
    AlreadyExists,

    /// <summary>Access denied [EACCES].</summary>
    AccessDenied,

    /// <summary>Media changed [Windows::ERROR_MEDIA_CHANGED].</summary>
    MediaChanged,

    /// <summary>The file/FS is read-only [EROFS].</summary>
    ReadOnlyFS,

    /// <summary>Device doesn't exist [ENXIO].</summary>
    NoDevice,

    /// <summary>Not found, no entry (fs) [ENOENT].</summary>
    NoEntry,

    /// <summary>No media in drive/device [ENOMEDIUM].</summary>
    NoMedia,

    /// <summary>No more data / end of file [ENODATA].</summary>
    NoMoreData,

    /// <summary>No more files [ENMFILE].</summary>
    NoMoreFiles,

    /// <summary>No space left on device [ENOSPC].</summary>
    NoSpaceLeft,

    /// <summary>Directory is not empty [ENOTEMPTY].</summary>
    NotEmpty,

    /// <summary>Not a file [EISDIR].</summary>
    NotFile,

    /// <summary>Not a directory [ENOTDIR].</summary>
    NotDirectory,

    /// <summary>Not same device [EXDEV].</summary>
    NotSameDevice,

    /// <summary>Not a block device [ENOTBLK].</summary>
    NotBlockDevice,

    /// <summary>File/path name is invalid.</summary>
    InvalidFilename,

    /// <summary>File/path name is too long [ENAMETOOLONG].</summary>
    FilenameTooLong,

    /// <summary>Too many open files [EMFILE].</summary>
    TooManyOpenFiles,

    /// <summary>Too many open files by OS [ENFILE].</summary>
    TooManyOpenFilesByOS,

    /// <summary>Too many symbolic links on FS [EMLINK].</summary>
    TooManyLinks,

    /// <summary>Too many threads [EAGAIN].</summary>
    TooManyThreads,

    /// <summary>Thread pool is exhausted and couldn't acquire the requested thread count.</summary>
    ThreadPoolExhausted,

    /// <summary>File is empty (not specific to any OS error).</summary>
    FileEmpty,

    /// <summary>File open failed [Windows::ERROR_OPEN_FAILED].</summary>
    OpenFailed,

    /// <summary>Not a root device/directory [Windows::ERROR_DIR_NOT_ROOT].</summary>
    NotRootDevice,

    /// <summary>Unknown system error that failed to translate to Blend2D result code.</summary>
    UnknownSystemError,

    /// <summary>Invalid data alignment.</summary>
    InvalidArgument,

    /// <summary>Invalid data signature or header.</summary>
    InvalidSignature,

    /// <summary>Invalid or corrupted data.</summary>
    InvalidData,

    /// <summary>Invalid string (invalid data of either UTF8, UTF16, or UTF32).</summary>
    InvalidString,

    /// <summary>Invalid key or property.</summary>
    InvalidKey,

    /// <summary>Truncated data (more data required than memory/stream provides).</summary>
    DataTruncated,

    /// <summary>Input data too large to be processed.</summary>
    DataTooLarge,

    /// <summary>Decompression failed due to invalid data (RLE, Huffman, etc).</summary>
    DecompressionFailed,

    /// <summary>Invalid geometry (invalid path data or shape).</summary>
    InvalidGeometry,

    /// <summary>Returned when there is no matching vertex in path data.</summary>
    NoMatchingVertex,

    /// <summary>Invalid create flags (TBLContext).</summary>
    InvalidCreateFlags,

    /// <summary>No matching cookie (TBLContext).</summary>
    NoMatchingCookie,

    /// <summary>No states to restore (TBLContext).</summary>
    NoStatesToRestore,

    /// <summary>Cannot save state as the number of saved states reached the limit (TBLContext).</summary>
    TooManySavedStates,

    /// <summary>The size of the image is too large.</summary>
    ImageTooBig,

    /// <summary>Image codec for a required format doesn't exist.</summary>
    ImageNoMatchingCodec,

    /// <summary>Unknown or invalid file format that cannot be read.</summary>
    ImageUnknownFileFormat,

    /// <summary>Image codec doesn't support reading the file format.</summary>
    ImageDecoderNotProvided,

    /// <summary>Image codec doesn't support writing the file format.</summary>
    ImageEncoderNotProvided,

    /// <summary>Multiple IHDR chunks are not allowed (PNG).</summary>
    PngMultipleIHDR,

    /// <summary>Invalid IDAT chunk (PNG).</summary>
    PngInvalidIDAT,

    /// <summary>Invalid IEND chunk (PNG).</summary>
    PngInvalidIEND,

    /// <summary>Invalid PLTE chunk (PNG).</summary>
    PngInvalidPLTE,

    /// <summary>Invalid tRNS chunk (PNG).</summary>
    PngInvalidTRNS,

    /// <summary>Invalid filter type (PNG).</summary>
    PngInvalidFilter,

    /// <summary>Unsupported feature (JPEG).</summary>
    JpegUnsupportedFeature,

    /// <summary>Invalid SOS marker or header (JPEG).</summary>
    JpegInvalidSOS,

    /// <summary>Invalid SOF marker (JPEG).</summary>
    JpegInvalidSOF,

    /// <summary>Multiple SOF markers (JPEG).</summary>
    JpegMultipleSOF,

    /// <summary>Unsupported SOF marker (JPEG).</summary>
    JpegUnsupportedSOF,

    /// <summary>Font doesn't have any data as it's not initialized.</summary>
    FontNotInitialized,

    /// <summary>Font or font-face was not matched (TBLFontManager).</summary>
    FontNoMatch,

    /// <summary>Font has no character to glyph mapping data.</summary>
    FontNoCharacterMapping,

    /// <summary>Font has missing an important table.</summary>
    FontMissingImportantTable,

    /// <summary>Font feature is not available.</summary>
    FontFeatureNotAvailable,

    /// <summary>Font has an invalid CFF data.</summary>
    FontCFFInvalidData,

    /// <summary>Font program terminated because the execution reached the limit.</summary>
    FontProgramTerminated,

    /// <summary>Glyph substitution requires too much space and was terminated.</summary>
    GlyphSubstitutionTooLarge,

    /// <summary>Invalid glyph identifier.</summary>
    InvalidGlyph);

type
  /// <summary>
  ///  Adds functionality to `TBLResult`.
  /// </summary>
  /// <seealso cref="TBLResult"/>
  _TBLResultHelper = record helper for TBLResult
  public
    /// <summary>
    ///  Converts the result code to a string.
    /// </summary>
    function ToString: String;
  end;

{ ============================================================================
   [Error Handling - Handlers]
  ============================================================================ }

type
  /// <summary>
  ///  Type of exception that is raised for Blend2D errors.
  ///  Exceptions are enabled by default, but can be disabled using
  ///  `BLSetErrorHandler`.
  /// </summary>
  /// <seealso cref="BLSetErrorHandler"/>
  EBlend2DError = class(Exception)
  {$REGION 'Internal Declarations'}
  private
    FResult: TBLResult;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Creates an exception object.
    /// </summary>
    constructor Create(const AResult: TBLResult);

    /// <summary>
    ///  The Blend2D result code.
    /// </summary>
    property ResultCode: TBLResult read FResult;
  end;

type
  /// <summary>
  ///  Type of procedure that is called when a Blend2D error occurs.
  /// </summary>
  /// <param name="AResult">The Blend2D result code.</param>
  /// <param name="AUserData">Any user data passed to `BLSetErrorHandler`.</param>
  /// <seealso cref="BLSetErrorHandler"/>
  TBLErrorHandler = procedure(const AResultCode: TBLResult; const AUserData: Pointer);

/// <summary>
///  Sets a Blend2D error handler.
/// </summary>
/// <param name="AHandler">The error handler that is called when a Blend2D error occurs.</param>
/// <param name="AUserData">Any data you want to pass to the handler.</param>
/// <remarks>
///  The default error handler raises an exception of type `EBlend2DError`.
///  You can disable error handling completely by setting AHandler to nil. In
///  that case, there is no way to know if and when an error occured.
///
///  The following procedures can be used to set some default error handlers:
///   * `BLSetExceptionErrorHandler`: sets the error handler to a procedure that
///     raises an exception when a Blend2D error occurs. This is the default
///     behavior.
///   * `BLSetGetLastErrorHandler`: sets the error handler to a procedure that
///     sets a global error variable when a Blend2D error occurs. You can then
///     use `BLGetLastError` to retrieve this error code.
/// </remarks>
/// <seealso cref="EBlend2DError"/>
/// <seealso cref="BLSetExceptionErrorHandler"/>
/// <seealso cref="BLSetGetLastErrorHandler"/>
/// <seealso cref="BLGetLastError"/>
procedure BLSetErrorHandler(const AHandler: TBLErrorHandler;
  const AUserData: Pointer);

/// <summary>
///  Sets the error handler to a procedure that raises an exception when a
///  Blend2D error occurs. This is the default behavior.
/// </summary>
procedure BLSetExceptionErrorHandler;

/// <summary>
///  Sets the error handler to a procedure that sets a global error variable
///  when a Blend2D error occurs. You can then use `BLGetLastError` to retrieve
///  this error code.
/// </summary>
/// <seealso cref="BLGetLastError"/>
procedure BLSetGetLastErrorHandler;

/// <summary>
///  Retrieves the last Blend2D error, or `TBLResult.Success` if there was none.
/// </summary>
/// <remarks>
///  After this call, the last error is reset to `TBLResult.Success`.
///
///  This function should only be used when `BLSetGetLastErrorHandler` has been
///  called. Otherwise, it always returns `TBLResult.Success`.
///
///  This function is not thread-safe. If Blend2D is used from multiple threads,
///  the returned value can be from any thread.
/// </remarks>
/// <seealso cref="TBLResult"/>
/// <seealso cref="BLSetGetLastErrorHandler"/>
function BLGetLastError: TBLResult;

{ ============================================================================
   [Error Handling - Internal]
  ============================================================================ }

procedure _BLCheck(const AResult: Integer); overload; inline;
procedure _BLCheck(const AResult: TBLResult); overload; inline;
{$ENDREGION 'Error Handling'}

{$REGION 'Globals'}

{ ============================================================================
   [Globals - Types]
  ============================================================================ }

type
  /// <summary>
  ///  Tag is a 32-bit integer consisting of 4 bytes (or ASCII characters) in
  ///  the following format:
  ///
  ///  ```
  ///  Tag := (A shl 24) or (B shl 16) or (C shl 8) or D;
  ///  ```
  ///
  ///  Tags are used extensively by OpenType fonts and other binary formats like
  ///  PNG. In most cases TAGs should only contain ASCII letters, digits, and
  ///  spaces.
  ///
  ///  Blend2D uses TBLTag in public and internal APIs to distinguish between a
  ///  regular `UInt32` and tag.
  /// </summary>
  TBLTag = type UInt32;

type
  /// <summary>
  ///  Adds functionality to `TBLTag`.
  /// </summary>
  _TBLTagHelper = record helper for TBLTag
  public
    /// <summary>
    ///  Creates a 32-bit tag from the given `A`, `B`, `C`, and `D` values.
    /// </summary>
    constructor Create(const AA, AB, AC, AD: Byte); overload;

    /// <summary>
    ///  Creates a 32-bit tag from the given `A`, `B`, `C`, and `D` values.
    /// </summary>
    constructor Create(const AA, AB, AC, AD: AnsiChar); overload;

    /// <summary>
    ///  Creates a 32-bit tag from the given four-character string AFourCC.
    /// </summary>
    /// <remarks>
    ///  The string must contain at least 4 characters. Any additional
    ///  characters are ignored.
    /// </remarks>
    constructor Create(const AFourCC: AnsiString); overload;

    /// <summary>
    ///  Implicitly converts a four-character string to a 32-bit tag.
    /// </summary>
    /// <remarks>
    ///  The string must contain at least 4 characters. Any additional
    ///  characters are ignored.
    /// </remarks>
    class operator Implicit(const AFourCC: AnsiString): TBLTag; inline; static;
  end;

type
  /// <summary>
  ///  Unique identifier that can be used for caching purposes.
  ///
  ///  Some objects such as TBLImage and TBLFontFace have assigned an unique
  ///  identifier that can be used to identify such objects for caching
  ///  purposes. This identifier is never zero, so zero can be safely used as
  ///  "uncached".
  /// </summary>
  /// <remarks>
  ///  Unique identifier is per-process. It's implemented as an increasing
  ///  global or thread-local counter in a way that identifiers would not
  ///  collide.
  /// </remarks>
  /// <seealso cref="TBLImage"/>
  /// <seealso cref="TBLFontFace"/>
  TBLUniqueId = UInt64;

{ ============================================================================
   [Globals - Enums and Sets]
  ============================================================================ }

type
  /// <summary>
  ///  Byte order.
  /// </summary>
  TBLByteOrder = (
    /// <summary>
    ///  Little endian byte-order.
    /// </summary>
    LE,

    /// <summary>
    ///  Big endian byte-order.
    /// </summary>
    BE,

    /// <summary>
    ///  Native (host) byte-order.
    /// </summary>
    Native  = LE,

    /// <summary>
    ///  Swapped byte-order (BE if host is LE and vice versa).
    /// </summary>
    Swapped = BE);

type
  /// <summary>
  ///  Data access flags.
  /// </summary>
  TBLDataAccessFlags = (
    /// <summary>
    ///  No data access flags.
    /// </summary>
    None  = $00,

    /// <summary>
    ///  Read access.
    /// </summary>
    Read  = $01,

    /// <summary>
    ///  Write access.
    /// </summary>
    Write = $02,

    /// <summary>
    /// Read and write access.
    /// </summary>
    RW    = $03);

type
  /// <summary>
  ///  Data source type.
  /// </summary>
  TBLDataSourceType = (
    /// <summary>
    ///  No data source.
    /// </summary>
    None,

    /// <summary>
    ///  Memory data source.
    /// </summary>
    Memory,

    /// <summary>
    ///  File data source.
    /// </summary>
    &File,

    /// <summary>
    ///  Custom data source.
    /// </summary>
    Custom);

type
  /// <summary>
  ///  Modification operation applied to Blend2D containers.
  /// </summary>
  TBLModifyOp = (
    /// <summary>
    ///  Assign operation, which reserves space only to fit the requested input.
    /// </summary>
    AssignFit,

    /// <summary>
    ///  Assign operation, which takes into consideration successive appends.
    /// </summary>
    AssignGrow,

    /// <summary>
    ///  Append operation, which reserves space only to fit the current and appended content.
    /// </summary>
    AppendFit,

    /// <summary>
    ///  Append operation, which takes into consideration successive appends.
    /// </summary>
    AppendGrow);

type
  /// <summary>
  ///  Boolean operator (between A and B).
  /// </summary>
  TBLBooleanOp = (
    /// <summary>
    ///  Result = B.
    /// </summary>
    Copy,

    /// <summary>
    ///  Result = A and B.
    /// </summary>
    &And,

    /// <summary>
    ///  Result = A or B.
    /// </summary>
    &Or,

    /// <summary>
    ///  Result = A xor B.
    /// </summary>
    &Xor,

    /// <summary>
    ///  Result = A and (not B).
    /// </summary>
    AndNot,

    /// <summary>
    ///  Result = (not A) and B.
    /// </summary>
    NotAnd);
{$ENDREGION 'Globals'}

{$REGION 'Objects'}

type
  /// <summary>
  ///  Object type identifier.
  /// </summary>
  TBLObjectType = (
    /// <summary>
    ///  Object represents a TBLRgba value stored as four 32-bit floating point
    ///  components (can be used as Style).
    /// </summary>
    Rgba = 0,

    /// <summary>
    ///  Object represents a TBLRgba32 value stored as 32-bit integer in
    ///  `$AARRGGBB` form. Also compatible with Delphi's `TAlphaColor` and
    ///  `TAlphaColorRec`.
    /// </summary>
    Rgba32 = 1,

    /// <summary>
    ///  Object represents a TBLRgba64 value stored as 64-bit integer in
    ///  `$AAAARRRRGGGGBBBB` form.
    /// </summary>
    Rgba64 = 2,

    /// <summary>
    ///  Object is `Null` (can be used as Style).
    /// </summary>
    Null = 3,

    /// <summary>
    ///  Object is TBLPattern (can be used as Style).
    /// </summary>
    Pattern = 4,

    /// <summary>
    ///  Object is TBLGradient (can be used as Style).
    /// </summary>
    Gradient = 5,

    /// <summary>
    ///  Object is TBLImage.
    /// </summary>
    Image = 9,

    /// <summary>
    ///  Object is TBLPath.
    /// </summary>
    Path = 10,

    /// <summary>
    ///  Object is TBLFont.
    /// </summary>
    Font = 16,

    /// <summary>
    ///  Object is TBLFontFeatureSettings.
    /// </summary>
    FontFeatureSettings = 17,

    /// <summary>
    ///  Object is TBLFontVariationSettings.
    /// </summary>
    FontVariationSettings = 18,

    /// <summary>
    ///  Object is TBLBitArray.
    /// </summary>
    BitArray = 25,

    /// <summary>
    ///  Object is TBLBitSet.
    /// </summary>
    BitSet = 26,

    /// <summary>
    ///  Object represents a Boolean value.
    /// </summary>
    Bool = 28,

    /// <summary>
    ///  Object represents a 64-bit signed integer value.
    /// </summary>
    Int64 = 29,

    /// <summary>
    ///  Object represents a 64-bit unsigned integer value.
    /// </summary>
    UInt64 = 30,

    /// <summary>
    ///  Object represents a 64-bit floating point value.
    /// </summary>
    Double = 31,

    /// <summary>
    ///  Object is TBLString.
    /// </summary>
    &String = 32,

    /// <summary>
    ///  Object is TBLArray&lt;T> where `T` is a `TBLObject` compatible type.
    /// </summary>
    ArrayObject = 33,

    /// <summary>
    ///  Object is TBLArray&lt;T> where `T` matches 8-bit signed integral type.
    /// </summary>
    ArrayInt8 = 34,

    /// <summary>
    ///  Object is TBLArray&lt;T> where `T` matches 8-bit unsigned integral type.
    /// </summary>
    ArrayUInt8 = 35,

    /// <summary>
    ///  Object is TBLArray&lt;T> where `T` matches 16-bit signed integral type.
    /// </summary>
    ArrayInt16 = 36,

    /// <summary>
    ///  Object is TBLArray&lt;T> where `T` matches 16-bit unsigned integral type.
    /// </summary>
    ArrayUInt16 = 37,

    /// <summary>
    ///  Object is TBLArray&lt;T> where `T` matches 32-bit signed integral type.
    /// </summary>
    ArrayInt32 = 38,

    /// <summary>
    ///  Object is TBLArray&lt;T> where `T` matches 32-bit unsigned integral type.
    /// </summary>
    ArrayUInt32 = 39,

    /// <summary>
    ///  Object is TBLArray&lt;T> where `T` matches 64-bit signed integral type.
    /// </summary>
    ArrayInt64 = 40,

    /// <summary>
    ///  Object is TBLArray&lt;T> where `T` matches 64-bit unsigned integral type.
    /// </summary>
    ArrayUInt64 = 41,

    /// <summary>
    ///  Object is TBLArray&lt;T> where `T` matches 32-bit floating point type.
    /// </summary>
    ArrayFloat32 = 42,

    /// <summary>
    ///  Object is TBLArray&lt;T> where `T` matches 64-bit floating point type.
    /// </summary>
    ArrayFloat64 = 43,

    /// <summary>
    ///  Object is TBLArray&lt;T> where `T` is a record of size 1.
    /// </summary>
    ArrayStruct1 = 44,

    /// <summary>
    ///  Object is TBLArray&lt;T> where `T` is a record of size 2.
    /// </summary>
    ArrayStruct2 = 45,

    /// <summary>
    ///  Object is TBLArray&lt;T> where `T` is a record of size 3.
    /// </summary>
    ArrayStruct3 = 46,

    /// <summary>
    ///  Object is TBLArray&lt;T> where `T` is a record of size 4.
    /// </summary>
    ArrayStruct4 = 47,

    /// <summary>
    ///  Object is TBLArray&lt;T> where `T` is a record of size 6.
    /// </summary>
    ArrayStruct6 = 48,

    /// <summary>
    ///  Object is TBLArray&lt;T> where `T` is a record of size 8.
    /// </summary>
    ArrayStruct8 = 49,

    /// <summary>
    ///  Object is TBLArray&lt;T> where `T` is a record of size 10.
    /// </summary>
    ArrayStruct10 = 50,

    /// <summary>
    ///  Object is TBLArray&lt;T> where `T` is a record of size 12.
    /// </summary>
    ArrayStruct12 = 51,

    /// <summary>
    ///  Object is TBLArray&lt;T> where `T` is a record of size 16.
    /// </summary>
    ArrayStruct16 = 52,

    /// <summary>
    ///  Object is TBLArray&lt;T> where `T` is a record of size 20.
    /// </summary>
    ArrayStruct20 = 53,

    /// <summary>
    ///  Object is TBLArray&lt;T> where `T` is a record of size 24.
    /// </summary>
    ArrayStruct24 = 54,

    /// <summary>
    ///  Object is TBLArray&lt;T> where `T` is a record of size 32.
    /// </summary>
    ArrayStruct32 = 55,

    /// <summary>
    ///  Object is TBLContext.
    /// </summary>
    Context = 100,

    /// <summary>
    ///  Object is TBLImageCodec.
    /// </summary>
    ImageCodec = 101,

    /// <summary>
    ///  Object is TBLImageDecoder.
    /// </summary>
    ImageDecoder = 102,

    /// <summary>
    ///  Object is TBLImageEncoder.
    /// </summary>
    ImageEncoder = 103,

    /// <summary>
    ///  Object is TBLFontFace.
    /// </summary>
    FontFace = 104,

    /// <summary>
    ///  Object is TBLFontData.
    /// </summary>
    FontData = 105,

    /// <summary>
    ///  Object is TBLFontManager.
    /// </summary>
    FontManager = 106,

    /// <summary>
    ///  Minimum object type of an array object.
    /// </summary>
    MinArray = 33,

    /// <summary>
    ///  Maximum object type of an array object.
    /// </summary>
    MaxArray = 55,

    /// <summary>
    ///  Minimum object type identifier that can be used as a style.
    /// </summary>
    MinStyle = 0,

    /// <summary>
    ///  Maximum object type identifier that can be used as a style.
    /// </summary>
    MaxStyle = 5,

    /// <summary>
    ///  Minimum object type of an object with virtual function table.
    /// </summary>
    MinVirtual = 100,

    /// <summary>
    ///  Maximum object type of an object with virtual function table.
    /// </summary>
    MaxVirtual = 127);

type
  /// <summary>
  /// Base "class" used by all Blend2D objects.
  /// </summary>
  TBLObjectCore = packed record
  {$REGION 'Internal Declarations'}
  private const
    P_SHIFT    = 0;
    Q_SHIFT    = 8;
    C_SHIFT    = 8;
    B_SHIFT    = 12;
    A_SHIFT    = 16;
    TYPE_SHIFT = 22;
    R_SHIFT    = 29;
    D_SHIFT    = 30;
    M_SHIFT    = 31;
  private const
    P_MASK = $FF shl P_SHIFT;           // [........|........|........|pppppppp]
    Q_MASK = $FF shl Q_SHIFT;           // [........|........|qqqqqqqq|........]
    C_MASK = $0F shl C_SHIFT;           // [........|........|....cccc|........]
    B_MASK = $0F shl B_SHIFT;           // [........|........|bbbb....|........]
    A_MASK = $3F shl A_SHIFT;           // [........|..aaaaaa|........|........]
    FIELDS_MASK = $003FFFF;
    TYPE_MASK = $7F shl TYPE_SHIFT;     // [...ttttt|tt......|........|........]
    R_FLAG = $01 shl R_SHIFT;           // [..R.....|........|........|........]
    D_FLAG = $01 shl D_SHIFT;           // [.D......|........|........|........]
    M_FLAG = Cardinal($01) shl M_SHIFT; // [M.......|........|........|........]
    MD_FLAGS = M_FLAG or D_FLAG;
    MDR_FLAGS = M_FLAG or D_FLAG or R_FLAG;
  private const
    /// <summary>
    /// Size of object static storage not considering FInfo field.
    /// </summary>
    STATIC_DATA_SIZE = 12;
  private
    FImpl: Pointer;
    {$HINTS OFF}
    {$IFDEF CPU32BITS}
    FData: UInt64;
    {$ELSE}
    FData: UInt32;
    {$ENDIF}
    {$HINTS ON}
    FInfo: UInt32;
  private
    function NeedsCleanup: Boolean; inline;
    procedure Swap(var AOther: TBLObjectCore); inline;
  private
    function AField: UInt32; inline;
//    function BField: UInt32; inline;
//    function CField: UInt32; inline;
//    function PField: UInt32; inline;
//    function QField: UInt32; inline;
  {$ENDREGION 'Internal Declarations'}
  end;

type
  /// <summary>
  ///  A function callback that is called when an object that holds external data
  ///  is going to be destroyed. It's often used as a notification that a data
  ///  passed to a certain object is no longer in use by Blend2D.
  /// </summary>
  TBLDestroyExternalDataFunc = procedure(AImpl, AExternalData, AUserData: Pointer); cdecl;

type
  /// <summary>
  ///  A sink that can be used to debug various parts of Blend2D.
  /// </summary>
  TBLDebugMessageSinkFunc = procedure (const AMessage: PUTF8Char;
    ASize: Size_T; AUserData: Pointer); cdecl;
{$ENDREGION 'Objects'}

{$REGION 'Containers'}

{ ============================================================================
   [Containers - Views & Common Types]
  ============================================================================ }

type
  /// <summary>
  ///  Array view of `T`.
  /// </summary>
  /// <remarks>
  ///  `T` must be an unmanaged type (eg. cannot be a String or interface or
  ///  dynamic array) and cannot contain [weak] references. This is checked with
  ///  an assertion.
  /// </remarks>
  TBLArrayView<T> = record
  public type
    {$POINTERMATH ON}
    /// <summary>
    ///  A pointer to type `T`.
    /// </summary>
    P = ^T;
    {$POINTERMATH OFF}
  {$REGION 'Internal Declarations'}
  private
    FData: P;
    FCount: NativeInt;
    function GetItem(const AIndex: NativeInt): T; inline;
    function GetRef(const AIndex: NativeInt): P; inline;
  public
    class constructor Create;
  {$ENDREGION 'Internal Declarations'}
  public
    constructor Create(const ADataIn: P; const ACountIn: NativeInt);

    /// <summary>
    ///  Creates a default empty array view
    /// </summary>
    class operator Initialize(out ADest: TBLArrayView<T>);

    procedure Reset; overload; inline;
    procedure Reset(const ADataIn: P; const ACountIn: NativeInt); overload; inline;

    function First: P; inline;
    function Last: P; inline;

    property Count: NativeInt read FCount;
    property Items[const AIndex: NativeInt]: T read GetItem; default;
    property Refs[const AIndex: NativeInt]: P read GetRef;
  end;

type
  /// <summary>
  ///  View of `UTF8Char[]` data used by TBLString.
  /// </summary>
  TBLStringView = TBLArrayView<UTF8Char>;

type
  /// <summary>
  ///  View of untyped data.
  /// </summary>
  TBLDataView = TBLArrayView<Byte>;

type
  /// <summary>
  ///  Provides start and end indexes. It has the same semantics as Slices in
  ///  other programming languages - range is always within [Start, Stop)
  ///  internal (Start is inclusive, Stop is exclusive). It's used to specify a
  ///  range of an operation of indexed containers like TBLString, TBLArray,
  ///  TBLGradient, TBLPath, etc...
  /// </summary>
  TBLRange = record
  public
    Start: NativeInt;
    Stop: NativeInt;
  public
    class operator Equal(const ALeft, ARight: TBLRange): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLRange): Boolean; inline; static;

    /// <summary>
    ///  Reset the range to [0, 0).
    /// </summary>
    procedure Reset; overload; inline;

    /// <summary>
    ///  Reset the range to [AStart, AStop).
    /// </summary>
    procedure Reset(const AStart, AStop: NativeInt); overload; inline;

    function Equals(const AOther: TBLRange): Boolean; inline;
  end;
  PBLRange = ^TBLRange;

type
  /// <summary>
  ///  Adds functionality to TBLRange.
  /// </summary>
  _TBLRangeHelper = record helper for TBLRange
  public const
    Everything: TBLRange = (Start: 0; Stop: NativeInt.MaxValue);
  end;

{ ============================================================================
   [Containers - Sequential Containers]
  ============================================================================ }

type
  /// <summary>
  ///  Generic array container.
  /// </summary>
  /// <remarks>
  ///  `T` must be of one of the following types:
  ///
  ///    - A signed or unsigned 8-, 16-, 32- or 64-bit integer.
  ///    - Enumerated types.
  ///    - A 32- or 64-bit floating-point value (Single or Double).
  ///    - An unmanaged record that does not contain any [weak] references.
  ///      So the record cannot contain reference-counted values like Strings,
  ///      Interfaces or dynamic arrays. Also, only small records of certain
  ///      sizes (32 bytes or less) bytes are supported.
  ///
  ///  These conditions are checked with an assertion.
  /// </remarks>
  TBLArray<T> = record
  public type
    {$POINTERMATH ON}
    /// <summary>
    ///  A pointer to type `T`.
    /// </summary>
    P = ^T;
    {$POINTERMATH OFF}
  {$REGION 'Internal Declarations'}
  private class var
    FArrayType: TBLObjectType;
  private
    FBase: TBLObjectCore;
    function GetIsEmpty: Boolean; inline;
    function GetCount: NativeInt; inline;
    function GetCapacity: NativeInt; inline;
    function GetItem(const AIndex: NativeInt): T; inline;
    procedure SetItem(const AIndex: NativeInt; const AValue: T); inline;
    function GetRef(const AIndex: NativeInt): P; inline;
    function GetData: P; inline;
  public
    class constructor Create;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Creates a default constructed array.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Initialize(out ADest: TBLArray<T>);

    /// <summary>
    ///  Destroys the path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Finalize(var ADest: TBLArray<T>);

    /// <summary>
    ///  Copy constructor.
    ///
    ///  Creates a weak-copy of the `ASrc` array by increasing it's internal
    ///  reference counter. This array and `ASrc` would point to the same data
    ///  and would be otherwise identical. Any change to `ASrc` would also
    ///  affect this array.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Assign(var ADest: TBLArray<T>; const [ref] ASrc: TBLArray<T>); inline;

    /// <summary>
    ///  Used to compare against `nil` (empty array).
    /// </summary>
    class operator Equal(const ALeft: TBLArray<T>; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two arrays are equal (have the same contents).
    /// </summary>
    class operator Equal(const ALeft, ARight: TBLArray<T>): Boolean; inline; static;

    /// <summary>
    ///  Used to compare against `nil` (empty array).
    /// </summary>
    class operator NotEqual(const ALeft: TBLArray<T>; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two arrays are not equal (do not have the same contents).
    /// </summary>
    class operator NotEqual(const ALeft, ARight: TBLArray<T>): Boolean; inline; static;

    /// <summary>
    ///  Returns whether the content of this array and `AOther` matches.
    /// </summary>
    function Equals(const AOther: TBLArray<T>): Boolean; inline;

    /// <summary>
    ///  Resets the array into a default constructed state by clearing its
    ///  content and releasing its memory.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Reset; inline;

    /// <summary>
    ///  Swaps the content of this array with the `AOther` array.
    /// </summary>
    procedure Swap(var AOther: TBLArray<T>); inline;

    /// <summary>
    ///  Converts this array to a Delphi `TArray<T>`.
    /// </summary>
    function ToArray: TArray<T>;

    /// <summary>
    ///  Returns a reference to the first item.
    /// </summary>
    /// <remarks>
    ///  The array must have at least one item otherwise calling `First` would
    ///  point to the end of the array, which is not initialized, and such
    ///  reference would be invalid. Debug builds would catch this condition
    ///  with an assertion.
    /// </remarks>
    function First: P; inline;

    /// <summary>
    ///  Returns a reference to the last item.
    /// </summary>
    /// <remarks>
    ///  The array must have at least one item otherwise calling `Last` would
    ///  point to the end of the array, which is not initialized, and such
    ///  reference would be invalid. Debug builds would catch this condition
    ///  with an assertion.
    /// </remarks>
    function Last: P; inline;

    /// <summary>
    ///  Returns the array data as `TBLArrayView<T>`.
    /// </summary>
    function View: TBLArrayView<T>; inline;

    /// <summary>
    ///  Returns the array item at the given `AIndex`.
    /// </summary>
    /// <remarks>
    ///  The index must be valid, which means it has to be less than the array
    ///  length. Accessing items out of range is undefined behavior that would
    ///  be caught by assertions in debug builds.
    /// </remarks>
    function At(const AIndex: NativeInt): T; inline;

    /// <summary>
    ///  Returns a reference to the array item at the given `AIndex`.
    /// </summary>
    /// <remarks>
    ///  The index must be valid, which means it has to be less than the array
    ///  length. Accessing items out of range is undefined behavior that would
    ///  be caught by assertions in debug builds.
    /// </remarks>
    function RefAt(const AIndex: NativeInt): P; inline;

    /// <summary>
    ///  Clears the content of the array.
    /// </summary>
    /// <remarks>
    ///  If the array uses a dynamically allocated memory and the instance is
    ///  mutable the memory won't be released, it will be reused instead.
    ///  Consider using `Reset` if you want to release the memory in such case
    ///  instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Clear; inline;

    /// <summary>
    ///  Shrinks the capacity of the array to fit its length.
    ///
    ///  Some array operations like `Append` may grow the array more than
    ///  necessary to make it faster when such manipulation operations are
    ///  called consecutively. When you are done with modifications and you know
    ///  the lifetime of the array won't be short you can use `Shrink` to fit
    ///  its memory requirements to the number of items it stores, which could
    ///  optimize the application's memory requirements.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Shrink; inline;

    /// <summary>
    ///  Reserves the array capacity to hold at least `AMinCapacity` items.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Reserve(const AMinCapacity: NativeInt); inline;

    /// <summary>
    ///  Truncates the length of the array to maximum `AMaxCount` items.
    ///
    ///  If the length of the array is less than `AMaxCount` then truncation
    ///  does nothing.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Truncate(const AMaxCount: NativeInt); inline;

    /// <summary>
    ///  Resizes the array to `ACount` items.
    ///
    ///  If `ACount` is greater than the array length then all new items will be
    ///  initialized by `AFill` item.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Resize(const ACount: NativeInt; const AFill: T); inline;

    /// <summary>
    ///  Makes the array mutable by possibly creating a deep copy of the data if
    ///  it's either read-only or shared with another array. Returns a pointer
    ///  to the beginning of mutable data in `dataOut`.
    ///
    ///  ```Delphi
    ///  var A: TBLArray&lt;Byte>;
    ///  A.Append([0, 1, 2, 3, 4, 5, 6, 7]);
    ///
    ///  var Data := A.MakeMutable;
    ///
    ///  // Data is a mutable pointer to array content of 8 items.
    ///  Data[0] = 100;
    ///
    ///  // Calling array member functions could invalidate Data.
    ///  A.Append(9); // You shouldn't use Data afterwards.
    ///  ```
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function MakeMutable: P; inline;

    /// <summary>
    ///  Modify operation is similar to `MakeMutable`, however, the `AOp`
    ///  argument specifies the desired array operation, and `ACount` specified
    ///  the number of items to assign or append. Returns a pointer to the first
    ///  item to be either assigned or appended and it points to an
    ///  uninitialized memory.
    ///
    ///  Please note that assignments mean to wipe out the whole array content
    ///  and to set the length of the array to `ACount`. The caller is
    ///  responsible for initializing the returned data.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function ModifyOp(const AOp: TBLModifyOp; const ACount: NativeInt): P; inline;

    /// <summary>
    ///  Insert operation, the semantics is similar to `ModifyOp`, however,
    ///  ACount items are inserted at the given `AIndex` instead of assigned or
    ///  appended.
    ///
    ///  The caller is responsible for initializing the returned data.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function InsertOp(const AIndex, ACount: NativeInt): P; inline;

    /// <summary>
    /// Similar to `ModifyOp`, but the items to assign/append to the array are
    /// given after the `AOp` argument.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Modify(const AOp: TBLModifyOp; const AItems: array of T);

    /// <summary>
    ///  Copy assignment, but creates a deep copy of the `AOther` array instead
    ///  of weak copy.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AssignDeep(const AOther: TBLArray<T>); inline;

    /// <summary>
    ///  Replaces the content of the array with the items passed in `AItems`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Assign(const AItems: array of T);

    /// <summary>
    ///  Replaces the content of the array by items in the passed array `AView`.
    /// </summary>
    /// <remarks>
    ///  The implementation can handle `AView` pointing to the array's data as
    ///  well, so it's possible to create a slice of the array if required.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AssignData(const AView: TBLArrayView<T>); overload; inline;

    /// <summary>
    ///  Replaces the content of the array `AItems` of length `ACount`.
    /// </summary>
    /// <remarks>
    ///  The implementation can handle items pointing to the array's data as
    ///  well, so it's possible to create a slice of the array if required.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AssignData(const AItems: P; const ACount: NativeInt); overload; inline;

    /// <summary>
    ///  Assign an external buffer to the array, which would replace the
    ///  existing content.
    ///
    /// <param name="AData">External data buffer to use (cannot be nil).</param>
    /// <param name="ACount">Size of the data buffer in items.</param>
    /// <param name="ACapacity">Capacity of the buffer, cannot be zero or
    ///  smaller than `ACount`.</param>
    /// <param name="AAccessFlags">Flags that describe whether the data is
    ///  read-only or read-write.</param>
    /// <param name="ADestroyFunc">(Optional) function that would be called when
    ///  the array is destroyed (can be nil if you don't need it).</param>
    /// <param name="AUserData">(Optional) user data passed to `ADestroyFunc`.</param>
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AssignExternalData(const AData: P; const ACount,
      ACapacity: NativeInt; const AAccessFlags: TBLDataAccessFlags;
      const ADestroyFunc: TBLDestroyExternalDataFunc = nil;
      const AUserData: Pointer = nil); inline;

    /// <summary>
    ///  Appends `AItem` to the array.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Append(const AItem: T); overload; inline;

    /// <summary>
    ///  Appends a number of items items passed in `AItems` to the array.
    /// </summary>
    /// <remarks>
    ///  The data in `AItems` cannot point to the same data that the array holds
    ///  as the function that prepares the append operation has no way to know
    ///  about the source (it only makes space for new data). It's an undefined
    ///  behavior in such case.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Append(const AItems: array of T); overload;

    /// <summary>
    ///  Appends items to the array of the given array `AView`.
    /// </summary>
    /// <remarks>
    ///  The implementation guarantees that a `AView` pointing to the array data
    ///  itself would work.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AppendData(const AView: TBLArrayView<T>); overload; inline;

    /// <summary>
    ///  Appends `AItems` to the array of length `ACount`.
    /// </summary>
    /// <remarks>
    ///  The implementation guarantees that a `AItems` pointing to the array
    ///  data itself would work.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AppendData(const AItems: P; const ACount: NativeInt); overload; inline;

    /// <summary>
    ///  Prepends `AItem` to the array.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Prepend(const AItem: T); overload; inline;

    /// <summary>
    ///  Prepends a number of items passed in `AItems` to the array.
    /// </summary>
    /// <remarks>
    ///  The data in `AItems` cannot point to the same data that the array holds
    ///  as the function that prepares the prepend operation has no way to know
    ///  about the source (it only makes space for new data). It's an undefined
    ///  behavior in such case.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Prepend(const AItems: array of T); overload;

    /// <summary>
    ///  Prepends items to the array of the given array `AView`.
    /// </summary>
    /// <remarks>
    ///  The implementation guarantees that a `AView` pointing to the array data
    ///  itself would work.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure PrependData(const AView: TBLArrayView<T>); overload; inline;

    /// <summary>
    ///  Prepends `AItems` to the array of length `ACount`.
    /// </summary>
    /// <remarks>
    ///  The implementation guarantees that a `AItems` pointing to the array
    ///  data itself would work.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure PrependData(const AItems: P; const ACount: NativeInt); overload; inline;

    /// <summary>
    ///  Inserts `AItem` at the given `AIndex`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Insert(const AIndex: NativeInt; const AItem: T); overload;

    /// <summary>
    ///  Inserts a number of items passed in `AItems` at the given `AIndex`.
    /// </summary>
    /// <remarks>
    ///  The data in `AItems` cannot point to the same data that the array holds
    ///  as the function that prepares the insert operation has no way to know
    ///  about the source (it only makes space for new data). It's an undefined
    ///  behavior in such case.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Insert(const AIndex: NativeInt; const AItems: array of T); overload;

    /// <summary>
    ///  Inserts items to the array of the given array `AView` at the given
    ///  `AIndex`.
    /// </summary>
    /// <remarks>
    ///  The implementation guarantees that a `AView` pointing to the array data
    ///  itself would work.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure InsertData(const AIndex: NativeInt; const AView: TBLArrayView<T>); overload; inline;

    /// <summary>
    ///  Prepends `AItems` to the array of length `ACount` at the given `AIndex`.
    /// </summary>
    /// <remarks>
    ///  The implementation guarantees that a `AItems` pointing to the array
    ///  data itself would work.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure InsertData(const AIndex: NativeInt; const AItems: P;
      const ACount: NativeInt); overload; inline;

    /// <summary>
    ///  Replaces an item at the given `AIndex` by `AItem`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Replace(const AIndex: NativeInt; const AItem: T); inline;

    /// <summary>
    ///  Replaces the given `ARange` of items by the given array `AView`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ReplaceData(const ARange: TBLRange; const AView: TBLArrayView<T>); overload; inline;

    /// <summary>
    ///  Replaces the given `ARange` of items by `AItems` of length `ACount`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ReplaceData(const ARange: TBLRange; const AItems: P;
      const ACount: NativeInt); overload; inline;

    /// <summary>
    ///  Removes an item at the given `Andex`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Remove(const AIndex: NativeInt); overload; inline;

    /// <summary>
    ///  Removes `ARange` of items.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Remove(const ARange: TBLRange); overload; inline;

    /// <summary>
    ///  Returns the first index at which a given `AItem` can be found in the
    ///  array, or -1 if not found.
    /// </summary>
    function IndexOf(const AItem: T): NativeInt; overload; inline;

    /// <summary>
    ///  Returns the index at which a given `AItem` can be found in the array
    ///  starting from `AFromIndex`, or -1 if not found.
    /// </summary>
    function IndexOf(const AItem: T; const AFromIndex: NativeInt): NativeInt; overload;

    /// <summary>
    ///  Returns the last index at which a given `AItem` can be found in the
    ///  array, or -1 if not present.
    /// </summary>
    function LastIndexOf(const AItem: T): NativeInt; overload; inline;

    /// <summary>
    ///  Returns the index at which a given `AItem` can be found in the array
    ///  starting from `AFromIndex` and ending at 0, or -1 if not present.
    /// </summary>
    function LastIndexOf(const AItem: T; const AFromIndex: NativeInt): NativeInt; overload;

    /// <summary>
    ///  Whether the array is empty.
    /// </summary>
    property IsEmpty: Boolean read GetIsEmpty;

    /// <summary>
    ///  The size of the array (number of items).
    /// </summary>
    property Count: NativeInt read GetCount;

    /// <summary>
    ///  The capacity of the array (number of items).
    /// </summary>
    property Capacity: NativeInt read GetCapacity;

    /// <summary>
    ///  The items in the array.
    /// </summary>
    /// <remarks>
    ///  This is the same as calling `At(AIndex)`.
    ///  The index must be valid, which means it has to be less than the array
    ///  length. Accessing items out of range is undefined behavior that would
    ///  be caught by assertions in debug builds.
    /// </remarks>
    property Items[const AIndex: NativeInt]: T read GetItem write SetItem; default;

    /// <summary>
    ///  References to the items in the array.
    /// </summary>
    /// <remarks>
    ///  This is the same as calling `RefAt(AIndex)`.
    /// </remarks>
    property Refs[const AIndex: NativeInt]: P read GetRef;

    /// <summary>
    ///  Pointer to the array data.
    /// </summary>
    property Data: P read GetData;
  end;

type
  /// <summary>
  ///  Byte string.
  ///
  ///  Blend2D always uses UTF-8 encoding in public APIs so all strings are
  ///  assumed UTF-8 by default. However, `TBLString` doesn't guarantee any
  ///  assumptions about the encoding of the data it holds. It can hold
  ///  arbitrary byte sequence and act as a raw byte-string when this
  ///  functionality is desired.
  /// </summary>
  /// <remarks>
  ///  Most Blend2D API's use `TBLString` instead of Delphi's built-in String
  ///  (UnicodeString) type since `TBLString` can be more efficient for short
  ///  strings. If you use the same string multiple times, it's more efficient
  ///  to keep a `TBLString` value around instead recreating them or using
  ///  regular strings, to avoid Unicode-to-UTF8 conversions.
  /// </remarks>
  TBLString = record
  {$REGION 'Internal Declarations'}
  private
    FBase: TBLObjectCore;
    function GetIsEmpty: Boolean; inline;
    function GetLength: NativeInt; inline;
    function GetCapacity: NativeInt; inline;
    function GetData: PUTF8Char; inline;
    function GetChar(const AIndex: NativeInt): UTF8Char; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Creates an empty string.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Initialize(out ADest: TBLString);

    /// <summary>
    ///  Destroys the string.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Finalize(var ADest: TBLString);

    /// <summary>
    ///  Copy constructor.
    ///
    ///  Performs weak copy of the data held by the `ASrc` string.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Assign(var ADest: TBLString; const [ref] ASrc: TBLString); inline;

    /// <summary>
    ///  Constructor that creates a string from the given string `AView`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    constructor Create(const AView: TBLStringView); overload;

    /// <summary>
    ///  Constructor that creates a string from the given UTF8 data specified by
    ///  `AStr` and `ALength`. If `ALength` is -1 the string is assumed to be null
    ///  terminated.
    ///
    ///  This is a convenience function that doesn't provide error handling. If
    ///  size exceeds small string capacity and dynamic allocation failed then a
    ///  default empty string would be constructed.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    constructor Create(const AStr: PUTF8Char; const ALength: NativeInt = -1); overload;

    /// <summary>
    ///  Constructor that creates a string from a Delphi (Unicode) String.
    /// </summary>
    /// <remarks>
    ///  This involves a Unicode-to-UTF8 conversion.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    constructor Create(const AStr: String); overload;

    /// <summary>
    ///  Constructor that creates a string from a Delphi UTF8String.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    constructor Create(const AStr: UTF8String); overload;

    /// <summary>
    ///  Implicitly convers a Delphi (Unicode) String to a TBLString.
    /// </summary>
    /// <remarks>
    ///  This involves a Unicode-to-UTF8 conversion.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Implicit(const AStr: String): TBLString; inline; static;

    /// <summary>
    ///  Implicitly convers a Delphi UTF8String to a TBLString.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Implicit(const AStr: UTF8String): TBLString; inline; static;

    /// <summary>
    ///  Used to compare against `nil` (empty string).
    /// </summary>
    class operator Equal(const ALeft: TBLString; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two strings are equal (have the same contents).
    /// </summary>
    class operator Equal(const ALeft, ARight: TBLString): Boolean; inline; static;

    /// <summary>
    ///  Used to compare against `nil` (empty string).
    /// </summary>
    class operator NotEqual(const ALeft: TBLString; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two strings are not equal (do not have the same contents).
    /// </summary>
    class operator NotEqual(const ALeft, ARight: TBLString): Boolean; inline; static;

    class operator LessThan(const ALeft, ARight: TBLString): Boolean; inline; static;
    class operator LessThanOrEqual(const ALeft, ARight: TBLString): Boolean; inline; static;
    class operator GreaterThan(const ALeft, ARight: TBLString): Boolean; inline; static;
    class operator GreaterThanOrEqual(const ALeft, ARight: TBLString): Boolean; inline; static;

    class operator Equal(const ALeft: TBLString; const ARight: TBLStringView): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLString; const ARight: TBLStringView): Boolean; inline; static;
    class operator LessThan(const ALeft: TBLString; const ARight: TBLStringView): Boolean; inline; static;
    class operator LessThanOrEqual(const ALeft: TBLString; const ARight: TBLStringView): Boolean; inline; static;
    class operator GreaterThan(const ALeft: TBLString; const ARight: TBLStringView): Boolean; inline; static;
    class operator GreaterThanOrEqual(const ALeft: TBLString; const ARight: TBLStringView): Boolean; inline; static;

    class operator Equal(const ALeft: TBLString; const ARight: PUTF8Char): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLString; const ARight: PUTF8Char): Boolean; inline; static;
    class operator LessThan(const ALeft: TBLString; const ARight: PUTF8Char): Boolean; inline; static;
    class operator LessThanOrEqual(const ALeft: TBLString; const ARight: PUTF8Char): Boolean; inline; static;
    class operator GreaterThan(const ALeft: TBLString; const ARight: PUTF8Char): Boolean; inline; static;
    class operator GreaterThanOrEqual(const ALeft: TBLString; const ARight: PUTF8Char): Boolean; inline; static;

    class operator Equal(const ALeft: TBLString; const ARight: UTF8String): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLString; const ARight: UTF8String): Boolean; inline; static;
    class operator LessThan(const ALeft: TBLString; const ARight: UTF8String): Boolean; inline; static;
    class operator LessThanOrEqual(const ALeft: TBLString; const ARight: UTF8String): Boolean; inline; static;
    class operator GreaterThan(const ALeft: TBLString; const ARight: UTF8String): Boolean; inline; static;
    class operator GreaterThanOrEqual(const ALeft: TBLString; const ARight: UTF8String): Boolean; inline; static;

    class operator Equal(const ALeft: TBLString; const ARight: String): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLString; const ARight: String): Boolean; inline; static;
    class operator LessThan(const ALeft: TBLString; const ARight: String): Boolean; inline; static;
    class operator LessThanOrEqual(const ALeft: TBLString; const ARight: String): Boolean; inline; static;
    class operator GreaterThan(const ALeft: TBLString; const ARight: String): Boolean; inline; static;
    class operator GreaterThanOrEqual(const ALeft: TBLString; const ARight: String): Boolean; inline; static;

    /// <summary>
    ///  Returns whether this string and `AOther` are equal (i.e. their contents
    ///  match).
    /// </summary>
    function Equals(const AOther: TBLString): Boolean; overload; inline;

    /// <summary>
    ///  Returns whether this string and other string `AView` are equal.
    /// </summary>
    function Equals(const AOther: TBLStringView): Boolean; overload; inline;

    /// <summary>
    ///  Returns whether this string and the given string data `AStr` of length
    ///  `ALength` are equal.
    /// </summary>
    function Equals(const AOther: PUTF8Char; const ALength: NativeInt = -1): Boolean; overload; inline;

    /// <summary>
    ///  Returns whether this string and the given UTF8 string data `AStr` are
    ///  equal.
    /// </summary>
    function Equals(const AOther: UTF8String): Boolean; overload; inline;

    /// <summary>
    ///  Returns whether this string and the given Unicode string data `AStr`
    ///  are equal.
    /// </summary>
    /// <remarks>
    ///  This involves a Unicode-to-UTF8 conversion of AOther.
    /// </remarks>
    function Equals(const AOther: String): Boolean; overload; inline;

    /// <summary>
    ///  Compares this string with `AOther` and returns either `-1`, `0`, or `1`.
    /// </summary>
    function Compare(const AOther: TBLString): Integer; overload; inline;

    /// <summary>
    ///  Compares this string with other string `AView` and returns either
    ///  `-1`, `0`, or `1`.
    /// </summary>
    function Compare(const AOther: TBLStringView): Integer; overload; inline;

    /// <summary>
    ///  Compares this string with other string data and returns either
    ///  `-1`, `0`, or `1`.
    /// </summary>
    function Compare(const AOther: PUTF8Char; const ALength: NativeInt = -1): Integer; overload; inline;

    /// <summary>
    ///  Compares this string with other string data and returns either
    ///  `-1`, `0`, or `1`.
    /// </summary>
    function Compare(const AOther: UTF8String): Integer; overload; inline;

    /// <summary>
    ///  Compares this string with other string data and returns either
    ///  `-1`, `0`, or `1`.
    /// </summary>
    /// <remarks>
    ///  This involves a Unicode-to-UTF8 conversion of AOther.
    /// </remarks>
    function Compare(const AOther: String): Integer; overload; inline;

    /// <summary>
    ///  Returns a character at the given `AIndex`.
    /// </summary>
    /// <remarks>
    ///  Index must be valid and cannot be out of bounds - there is an assertion.
    /// </remarks>
    function At(const AIndex: NativeInt): UTF8Char; inline;

    /// <summary>
    ///  Clears the content of the string and releases its data.
    ///
    ///  After reset the string content matches a default constructed string.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Reset; inline;

    /// <summary>
    ///  Swaps the content of this string with the `AOther` string.
    /// </summary>
    procedure Swap(var AOther: TBLString); inline;

    /// <summary>
    ///  Returns the content of the string as `TBLStringView`.
    /// </summary>
    function View: TBLStringView; inline;

    /// <summary>
    ///  Clears the content of the string without releasing its dynamically
    ///  allocated data, if possible.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Clear; inline;

    /// <summary>
    ///  Shrinks the capacity of the string to match the actual content.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Shrink; inline;

    /// <summary>
    ///  Reserves at least `AMinSize` bytes (UTF8 characters) in the string for
    ///  further manipulation (most probably appending).
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Reserve(const AMinSize: NativeInt); inline;

    /// <summary>
    ///  Resizes the string to `ALength` and fills the additional data by
    ///  `AFill` pattern.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Resize(const ALength: NativeInt; const AFill: UTF8Char = #0); inline;

    /// <summary>
    ///  Makes the string mutable.
    ///
    ///  This operation checks whether the string is mutable and if not it makes
    ///  a deep copy of its content so it can be modified. Please note that you
    ///  can only modify the content that is defined by its length property.
    ///  Even if the string had higher capacity before `MakeMutable` it's not
    ///  guaranteed that the possible new data would match that capacity.
    ///
    ///  If you want to make the string mutable for the purpose of appending or
    ///  making other modifications please consider using `ModifyOp` and
    ///  `InsertOp` instead.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="ModifyOp"/>
    /// <seealso cref="InsertOp"/>
    function MakeMutable: PUTF8Char; inline;

    function ModifyOp(const AOp: TBLModifyOp; const ALength: NativeInt): PUTF8Char; inline;
    function InsertOp(const AIndex, ALength: NativeInt): PUTF8Char; inline;

    /// <summary>
    ///  Replaces the content of the string by `AChar` character or multiple
    ///  characters if `ACount` is greater than one.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Assign(const AChar: UTF8Char; const ACount: NativeInt = 1); overload; inline;

    /// <summary>
    ///  Replaces the string by the content described by the given string `AView`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Assign(const AView: TBLStringView); overload; inline;

    /// <summary>
    ///  Replaces the string by `AStr` data of the given length `ALength`.
    /// </summary>
    /// <remarks>
    ///  The implementation assumes null terminated string if `ALength` equals to
    ///  `-1`.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Assign(const AStr: PUTF8Char; const ALength: NativeInt = -1); overload; inline;

    /// <summary>
    ///  Copy assignment, but creates a deep copy of the `AOther` string instead
    ///  of weak copy.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AssignDeep(const AOther: TBLString); inline;

    /// <summary>
    ///  Replaces the content of the string by a result of calling
    ///  `Format(AFmt, AArgs)`.
    /// </summary>
    /// <remarks>
    ///  This involves a Unicode-to-UTF8 conversion.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AssignFormat(const AFmt: String; const AArgs: array of const);

    /// <summary>
    ///  Truncates the string length to `ALength`.
    ///
    ///  It does nothing if the the string length is less than `ALength`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Truncate(const ALength: NativeInt); inline;

    procedure Append(const AChar: UTF8Char; const ACount: NativeInt = 1); overload; inline;
    procedure Append(const AOther: TBLString); overload; inline;
    procedure Append(const AView: TBLStringView); overload; inline;
    procedure Append(const AStr: PUTF8Char; const ALength: NativeInt = -1); overload; inline;
    procedure Append(const AStr: UTF8String); overload; inline;
    procedure Append(const AStr: String); overload; inline;

    procedure AppendFormat(const AFmt: String; const AArgs: array of const);

    procedure Prepend(const AChar: UTF8Char; const ACount: NativeInt = 1); overload; inline;
    procedure Prepend(const AOther: TBLString); overload; inline;
    procedure Prepend(const AView: TBLStringView); overload; inline;
    procedure Prepend(const AStr: PUTF8Char; const ALength: NativeInt = -1); overload; inline;
    procedure Prepend(const AStr: UTF8String); overload; inline;
    procedure Prepend(const AStr: String); overload; inline;

    procedure Insert(const AIndex: NativeInt; const AChar: UTF8Char;
      const ACount: NativeInt = 1); overload; inline;
    procedure Insert(const AIndex: NativeInt; const AOther: TBLString); overload; inline;
    procedure Insert(const AIndex: NativeInt; const AView: TBLStringView); overload; inline;
    procedure Insert(const AIndex: NativeInt; const AStr: PUTF8Char;
      const ALength: NativeInt = -1); overload; inline;
    procedure Insert(const AIndex: NativeInt; const AStr: UTF8String); overload; inline;
    procedure Insert(const AIndex: NativeInt; const AStr: String); overload; inline;

    procedure Remove(const AIndex: NativeInt); overload; inline;
    procedure Remove(const ARange: TBLRange); overload; inline;

    /// <summary>
    ///  Returns the first index at which a given character `AChar` can be found
    ///  in the string, or -1 if not present.
    /// </summary>
    function IndexOf(const AChar: UTF8Char): NativeInt; overload; inline;

    /// <summary>
    ///  Returns the index at which a given character `AChar` can be found in
    ///  the string starting from `AFromIndex`, or -1 if not present.
    /// </summary>
    function IndexOf(const AChar: UTF8Char; const AFromIndex: NativeInt): NativeInt; overload; inline;

    /// <summary>
    ///  Returns the last index at which a given character `AChar` can be found
    ///  in the string, or -1 if not present.
    /// </summary>
    function LastIndexOf(const AChar: UTF8Char): NativeInt; overload; inline;

    /// <summary>
    ///  Returns the index at which a given character `AChar` can be found in
    ///  the string starting from `AFromIndex` and ending at `0`, or -1 if not
    ///  present.
    /// </summary>
    function LastIndexOf(const AChar: UTF8Char; const AFromIndex: NativeInt): NativeInt; overload; inline;

    /// <summary>
    ///  Converts to a Delphi string
    /// </summary>
    function ToString: String; inline;

    /// <summary>
    ///  Whether the string is empty.
    /// </summary>
    property IsEmpty: Boolean read GetIsEmpty;

    /// <summary>
    ///  The size of the string [in bytes or number of UTF8 characters].
    /// </summary>
    property Length: NativeInt read GetLength;

    /// <summary>
    ///  The capacity of the string [in bytes or number of UTF8 characters].
    /// </summary>
    property Capacity: NativeInt read GetCapacity;

    /// <summary>
    ///  Pointer to the data of the string.
    /// </summary>
    property Data: PUTF8Char read GetData;

    /// <summary>
    ///  The characters at the given `AIndex` (0-based).
    /// </summary>
    /// <remarks>
    ///  This is the same as calling `At(AIndex)`.
    ///  Index must be valid and cannot be out of bounds - there is an assertion.
    /// </remarks>
    property Chars[const AIndex: NativeInt]: UTF8Char read GetChar; default;
  end;

{ ============================================================================
   [Containers - Bit Containers]
  ============================================================================ }

type
  /// <summary>
  ///  BitArray container.
  /// </summary>
  TBLBitArray = record
  {$REGION 'Internal Declarations'}
  private
    FBase: TBLObjectCore;
    function GetIsEmpty: Boolean; inline;
    function GetCount: Integer; inline;
    function GetWordCount: Integer; inline;
    function GetCapacity: Integer; inline;
    function GetCardinality: Integer; inline;
    function GetData: PUInt32; inline;
    function GetBit(const AIndex: Integer): Boolean; inline;
    procedure SetBit(const AIndex: Integer; const AValue: Boolean); overload; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Creates an empty bit array.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Initialize(out ADest: TBLBitArray);

    /// <summary>
    ///  Destroys the bit array.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Finalize(var ADest: TBLBitArray);

    /// <summary>
    ///  Copy constructor.
    ///
    ///  Performs weak copy of the data held by the `ASrc` bit array.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Assign(var ADest: TBLBitArray; const [ref] ASrc: TBLBitArray); inline;

    /// <summary>
    ///  Used to compare against `nil` (empty bit array).
    /// </summary>
    class operator Equal(const ALeft: TBLBitArray; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two bit arrays are equal (have the same contents).
    /// </summary>
    class operator Equal(const ALeft, ARight: TBLBitArray): Boolean; inline; static;

    /// <summary>
    ///  Used to compare against `nil` (empty bit array).
    /// </summary>
    class operator NotEqual(const ALeft: TBLBitArray; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two bit arrays are not equal (do not have the same contents).
    /// </summary>
    class operator NotEqual(const ALeft, ARight: TBLBitArray): Boolean; inline; static;

    class operator LessThan(const ALeft, ARight: TBLBitArray): Boolean; inline; static;
    class operator LessThanOrEqual(const ALeft, ARight: TBLBitArray): Boolean; inline; static;
    class operator GreaterThan(const ALeft, ARight: TBLBitArray): Boolean; inline; static;
    class operator GreaterThanOrEqual(const ALeft, ARight: TBLBitArray): Boolean; inline; static;

    /// <summary>
    ///  Clears the content of the bit array and releases its data.
    ///
    ///  After reset the bit array content matches a default constructed instance.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Reset; inline;

    /// <summary>
    ///  Swaps the content of this bit array with the `AOther` bit array.
    /// </summary>
    procedure Swap(var AOther: TBLBitArray); inline;

    /// <summary>
    ///  Returns whether this bit array and `AOther` are bitwise equal.
    /// </summary>
    function Equals(const AOther: TBLBitArray): Boolean; inline;

    /// <summary>
    ///  Compares this bit array with `AOther` and returns either `-1`, `0`,
    ///  or `1`.
    /// </summary>
    function Compare(const AOther: TBLBitArray): Integer; inline;

    /// <summary>
    ///  Returns the number of bits set in the given `[AStartBit, AEndBit)` range.
    /// </summary>
    function CardinalityInRange(const AStartBit, AEndBit: Integer): Integer; inline;

    /// <summary>
    ///  Returns a bit-value at the given `ABitIndex`.
    /// </summary>
    function HasBit(const ABitIndex: Integer): Boolean; inline;

    /// <summary>
    ///  Sets a bit to True at the given `ABitIndex`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetBit(const ABitIndex: Integer); overload; inline;

    /// <summary>
    ///  Sets a bit to False at the given `ABitIndex`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ClearBit(const ABitIndex: Integer); overload; inline;

    /// <summary>
    ///  Replaces a bit in the bit array at the given `ABitIndex` to match
    ///  `ABitValue`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ReplaceBit(const ABitIndex: Integer; const ABitValue: Boolean); inline;

    /// <summary>
    ///  Returns whether the bit-set has at least on bit in the given
    ///  `[AStartBit, AEndbit)` range.
    /// </summary>
    function HasBitsInRange(const AStartBit, AEndBit: Integer): Boolean; inline;

    /// <summary>
    ///  Returns whether this bit array subsumes `AOther`.
    /// </summary>
    function Subsumes(const AOther: TBLBitArray): Boolean; inline;

    /// <summary>
    ///  Returns whether this bit array intersects with `AOther`.
    /// </summary>
    function Intersects(const AOther: TBLBitArray): Boolean; inline;

    /// <summary>
    ///  Replaces the content of the bit array by bits specified by `AWordData`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AssignWords(const AWordData: TArray<UInt32>); overload; inline;

    /// <summary>
    ///  Replaces the content of the bit array by bits specified by `AWordData`
    ///  of size `AWordCount` [the size is in UInt32 units].
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AssignWords(const AWordData: PUInt32; const AWordCount: Integer); overload; inline;

    /// <summary>
    ///  Clears the content of the bit array without releasing its dynamically
    ///  allocated data, if possible.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Clear; inline;

    /// <summary>
    ///  Resizes the bit array so its size matches `ANumBits`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Resize(const ANumBits: Integer); inline;

    /// <summary>
    ///  Reserves `ANumBits` in the bit array (capacity would match `ANumBits`)
    ///  without changing its size.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Reserve(const ANumBits: Integer); inline;

    /// <summary>
    ///  Shrinks the capacity of the bit array to match the actual content with
    ///  the intention to save memory.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Shrink; inline;

    /// <summary>
    ///  Fills bits in `[AStartBit, AEndBit)` range to True.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRange(const AStartBit, AEndBit: Integer); inline;

    /// <summary>
    ///  Fills bits starting from `ABitIndex` specified by `AWordData` to True
    ///  (zeros in AWordData are ignored).
    /// </summary>
    /// <remarks>
    ///  This operation uses an `OR` operator - bits in `AWordData` are combined
    ///  with OR operator with existing bits in bit array.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillWords(const ABitIndex: Integer; const AWordData: TArray<UInt32>); overload; inline;

    /// <summary>
    ///  Fills bits starting from `ABitIndex` specified by `AWordData` and
    ///  `AWordCount` to True (zeros in AWordData are ignored).
    /// </summary>
    /// <remarks>
    ///  This operation uses an `OR` operator - bits in `AWordData` are combined
    ///  with OR operator with existing bits in bit array.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillWords(const ABitIndex: Integer; const AWordData: PUInt32;
      const AWordCount: UInt32); overload; inline;

    /// <summary>
    ///  Sets bits in `[AStartBit, EndBit)` range to False.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ClearRange(const AStartBit, AEndBit: Integer); inline;

    /// <summary>
    ///  Sets bits starting from `ABitIndex` specified by `AWordValue` to False
    ///  (zeros in ASordValue are ignored).
    /// </summary>
    /// <remarks>
    ///  This operation uses an `AND_NOT` operator - bits in `AWordData` are
    ///  negated and then combined with AND operator with existing bits in
    ///  bit array.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ClearWord(const ABitIndex: Integer; const AWordValue: UInt32); inline;

    /// <summary>
    ///  Sets bits starting from `ABitIndex` specified by `AWordData` to False
    ///  (zeros in AWordData are ignored).
    /// </summary>
    /// <remarks>
    ///  This operation uses an `AND_NOT` operator - bits in `AWordData` are
    ///  negated and then combined with AND operator with existing bits in
    ///  bit array.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ClearWords(const ABitIndex: Integer; const AWordData: TArray<UInt32>); overload; inline;

    /// <summary>
    ///  Sets bits starting from `ABitIndex` specified by `AWordData` and
    ///  `AWordCount` to False (zeros in AWordData are ignored).
    /// </summary>
    /// <remarks>
    ///  This operation uses an `AND_NOT` operator - bits in `AWordData` are
    ///  negated and then combined with AND operator with existing bits in
    ///  bit array.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ClearWords(const ABitIndex: Integer; const AWordData: PUInt32;
      const AWordCount: UInt32); overload; inline;

    /// <summary>
    ///  Makes the bit array mutable with the intention to replace all bits of it.
    /// </summary>
    /// <remarks>
    ///  All bits in the bit array will be set to zero.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function ReplaceOp(const ANumBits: Integer): PUInt32; inline;

    /// <summary>
    ///  Replaces bits starting from `ABitIndex` to match the bits specified by
    ///  `AWordValue`.
    /// </summary>
    /// <remarks>
    ///  Replaced bits from bit array are not combined by using any operator,
    ///  `AWordValue` is copied as is, thus replaces fully the existing bits.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ReplaceWord(const ABitIndex: Integer; const AWordValue: UInt32); inline;

    /// <summary>
    ///  Replaces bits starting from `ABitIndex` to match the bits specified by
    ///  `AWordData`.
    /// </summary>
    /// <remarks>
    ///  Replaced bits from bit array are not combined by using any operator,
    ///  `AWordData` is copied as is, thus replaces fully the existing bits.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ReplaceWords(const ABitIndex: Integer; const AWordData: TArray<UInt32>); overload; inline;

    /// <summary>
    ///  Replaces bits starting from `ABitIndex` to match the bits specified by
    ///  `AWordData` and `AWordCount`.
    /// </summary>
    /// <remarks>
    ///  Replaced bits from bit array are not combined by using any operator,
    ///  `AWordData` is copied as is, thus replaces fully the existing bits.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ReplaceWords(const ABitIndex: Integer; const AWordData: PUInt32;
      const AWordCount: UInt32); overload; inline;

    /// <summary>
    ///  Appends a bit `ABitValue` to the bit array.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AppendBit(const ABitValue: Boolean); inline;

    /// <summary>
    ///  Appends a single word `AWordValue` to the bit array.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AppendWord(const AWordValue: UInt32); inline;

    /// <summary>
    ///  Appends whole words to the bit array.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AppendWords(const AWordData: TArray<UInt32>); overload; inline;

    /// <summary>
    ///  Appends whole words to the bit array.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AppendWords(const AWordData: PUInt32; const AWordCount: Integer); overload; inline;

    /// <summary>
    ///  Whether the bit array is empty (has no content).
    /// </summary>
    property IsEmpty: Boolean read GetIsEmpty;

    /// <summary>
    ///  The number of bits of the bit array.
    /// </summary>
    property Count: Integer read GetCount;

    /// <summary>
    ///  The bits in the bit array.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property Bits[const AIndex: Integer]: Boolean read GetBit write SetBit; default;

    /// <summary>
    ///  The number of bit words this bit array uses.
    /// </summary>
    property WordCount: Integer read GetWordCount;

    /// <summary>
    ///  The capacity of the bit array in bits.
    /// </summary>
    property Capacity: Integer read GetCapacity;

    /// <summary>
    ///  The number of bits set in the bit array.
    /// </summary>
    property Cardinality: Integer read GetCardinality;

    /// <summary>
    ///  The bit data.
    /// </summary>
    property Data: PUInt32 read GetData;
  end;

{$ENDREGION 'Containers'}

{$REGION 'File System'}
type
  /// <summary>
  ///  File open flags.
  /// </summary>
  /// <seealso cref="TBLFile.Open"/>
  TBLFileOpenFlag = (
    /// <summary>
    ///  Opens the file for reading.
    ///
    ///  The following system flags are used when opening the file:
    ///    - `O_RDONLY` (Posix)
    ///    - `GENERIC_READ` (Windows)
    /// </summary>
    Read = 0,

    /// <summary>
    ///  Opens the file for writing:
    ///
    ///  The following system flags are used when opening the file:
    ///    - `O_WRONLY` (Posix)
    ///    - `GENERIC_WRITE` (Windows)
    /// </summary>
    Write = 1,

    /// <summary>
    ///  Creates the file if it doesn't exist or opens it if it does.
    ///
    ///  The following system flags are used when opening the file:
    ///    - `O_CREAT` (Posix)
    ///    - `CREATE_ALWAYS` or `OPEN_ALWAYS` depending on other flags (Windows)
    /// </summary>
    Create = 2,

    /// <summary>
    ///  Opens the file for deleting or renaming (Windows).
    ///
    ///  Adds `DELETE` flag when opening the file to `ACCESS_MASK`.
    /// </summary>
    Delete = 3,

    /// <summary>
    ///  Truncates the file.
    ///
    ///  The following system flags are used when opening the file:
    ///    - `O_TRUNC` (Posix)
    ///    - `TRUNCATE_EXISTING` (Windows)
    /// </summary>
    Truncate = 4,

    /// <summary>
    ///  Opens the file for reading in exclusive mode (Windows).
    ///
    ///  Exclusive mode means to not specify the `FILE_SHARE_READ` option.
    /// </summary>
    ReadExclusive = 28,

    /// <summary>
    ///  Opens the file for writing in exclusive mode (Windows).
    ///
    ///  Exclusive mode means to not specify the `FILE_SHARE_WRITE` option.
    /// </summary>
    WriteExclusive = 29,

    /// <summary>
    ///  Creates the file in exclusive mode - fails if the file already exists.
    ///
    ///  The following system flags are used when opening the file:
    ///    - `O_EXCL` (Posix)
    ///    - `CREATE_NEW` (Windows)
    /// </summary>
    CreateExclusive = 30,

    /// <summary>
    ///  Opens the file for deleting or renaming in exclusive mode (Windows).
    ///
    ///  Exclusive mode means to not specify the `FILE_SHARE_DELETE` option.
    /// </summary>
    DeleteExclusive = 31);

  /// <summary>
  ///  File open flags.
  /// </summary>
  /// <seealso cref="TBLFile.Open"/>
  TBLFileOpenFlags = set of TBLFileOpenFlag;

  /// <summary>
  ///  Adds functionality to `TBLFileOpenFlags`.
  /// </summary>
  _TBLFileOpenFlagsHelper = record helper for TBLFileOpenFlags
  public const
    /// <summary>
    ///  No flags.
    /// </summary>
    None = [];

    /// <summary>
    ///  Opens the file for reading & writing.
    ///
    ///  The following system flags are used when opening the file:
    ///    - `O_RDWR` (Posix)
    ///    - `GENERIC_READ or GENERIC_WRITE` (Windows)
    /// </summary>
    ReadWrite = [TBLFileOpenFlag.Read, TBLFileOpenFlag.Write];

    /// <summary>
    ///  Opens the file for both reading and writing (Windows).
    ///
    ///  This is a combination of both `BL_FILE_OPEN_READ_EXCLUSIVE` and `BL_FILE_OPEN_WRITE_EXCLUSIVE`.
    /// </summary>
    ReadWriteExclusive = [TBLFileOpenFlag.ReadExclusive, TBLFileOpenFlag.WriteExclusive];
  end;

type
  /// <summary>
  ///  File read flags used by `TBLFileSystem.ReadFile`.
  /// </summary>
  /// <seealso cref="TBLFileSystem.ReadFile"/>
  TBLFileReadFlag = (
    /// <summary>
    ///  Use memory mapping to read the content of the file.
    ///
    ///  The destination buffer `TBLArray<>` would be configured to use the
    ///  memory mapped buffer instead of allocating its own.
    /// </summary>
    MmapEnabled = 0,

    /// <summary>
    ///  Avoid memory mapping of small files.
    ///
    ///  The size of small file is determined by Blend2D, however, you should
    ///  expect it to be 16kB or 64kB depending on host operating system.
    /// </summary>
    MmapAvoidSmall = 1,

    /// <summary>
    ///  Do not fallback to regular read if memory mapping fails. It's worth
    ///  noting that memory mapping would fail for files stored on filesystem
    ///  that is not local (like a mounted network filesystem, etc...).
    /// </summary>
    MmapNoFallback = 3);

  /// <summary>
  ///  File read flags used by `TBLFileSystem.ReadFile`.
  /// </summary>
  /// <seealso cref="TBLFileSystem.ReadFile"/>
  TBLFileReadFlags = set of TBLFileReadFlag;

  /// <summary>
  ///  Adds functionality to `TBLFileReadFlags`.
  /// </summary>
  _TBLFileReadFlagsHelper = record helper for TBLFileReadFlags
  public const
    /// <summary>
    ///  No flags.
    /// </summary>
    None = [];
  end;

type
  /// <summary>
  ///  File seek mode.
  /// </summary>
  /// <remarks>
  ///  Seek constants should be compatible with constants used by both POSIX
  ///  and Windows API.
  /// </remarks>
  /// <seealso cref="TBLFile.Seek"/>
  TBLFileSeekType = (
    /// <summary>
    ///  Seek from the beginning of the file (SEEK_SET).
    /// </summary>
    FromBeginning,

    /// <summary>
    ///  Seek from the current position (SEEK_CUR).
    /// </summary>
    FromCurrent,

    /// <summary>
    ///  Seek from the end of the file (SEEK_END).
    /// </summary>
    FromEnd);

type
  /// <summary>
  ///  File information flags, used by `TBLFileInfo`.
  /// </summary>
  /// <seealso cref="TBLFileInfo"/>
  TBLFileInfoFlag = (
    /// <summary>
    ///  File owner has read permission (compatible with 0400 octal notation).
    /// </summary>
    OwnerR = 8,

    /// <summary>
    ///  File owner has write permission (compatible with 0200 octal notation).
    /// </summary>
    OwnerW = 7,

    /// <summary>
    ///  File owner has execute permission (compatible with 0100 octal notation).
    /// </summary>
    OwnerX = 6,

    /// <summary>
    ///  File group owner has read permission (compatible with 040 octal notation).
    /// </summary>
    GroupR = 5,

    /// <summary>
    ///  File group owner has write permission (compatible with 020 octal notation).
    /// </summary>
    GroupW = 4,

    /// <summary>
    ///  File group owner has execute permission (compatible with 010 octal notation).
    /// </summary>
    GroupX = 3,

      /// <summary>
    ///  Other users have read permission (compatible with 04 octal notation).
    /// </summary>
    OtherR = 2,

    /// <summary>
    ///  Other users have write permission (compatible with 02 octal notation).
    /// </summary>
    OtherW = 1,

    /// <summary>
    ///  Other users have execute permission (compatible with 01 octal notation).
    /// </summary>
    OtherX = 0,

    /// <summary>
    ///  Set user ID to file owner user ID on execution (compatible with 04000
    ///  octal notation).
    /// </summary>
    SetUid = 11,

    /// <summary>
    ///  Set group ID to file's user group ID on execution (compatible with
    ///  02000 octal notation).
    /// </summary>
    SetGid = 10,

    /// <summary>
    ///  A flag specifying that this is a regular file.
    /// </summary>
    Regular = 16,

    /// <summary>
    ///  A flag specifying that this is a directory.
    /// </summary>
    Directory = 17,

    /// <summary>
    ///  A flag specifying that this is a symbolic link.
    /// </summary>
    SymLink = 18,

    /// <summary>
    ///  A flag describing a character device.
    /// </summary>
    CharDevice = 20,

    /// <summary>
    ///  A flag describing a block device.
    /// </summary>
    BlockDevice = 21,

    /// <summary>
    ///  A flag describing a FIFO (named pipe).
    /// </summary>
    Fifo = 22,

    /// <summary>
    ///  A flag describing a socket.
    /// </summary>
    Socket = 23,

    /// <summary>
    ///  A flag describing a hidden file (Windows only).
    /// </summary>
    Hidden = 24,

    /// <summary>
    ///  A flag describing an executable file (Windows only).
    /// </summary>
    Executable = 25,

    /// <summary>
    ///  A flag describing an archive (Windows only).
    /// </summary>
    Archive = 26,

    /// <summary>
    ///  A flag describing a system file (Windows only).
    /// </summary>
    System = 27,

    /// <summary>
    ///  File information is valid (the request succeeded).
    /// </summary>
    Valid = 31);

  /// <summary>
  ///  File information flags, used by `TBLFileInfo`.
  /// </summary>
  /// <seealso cref="TBLFileInfo"/>
  TBLFileInfoFlags = set of TBLFileInfoFlag;

  /// <summary>
  ///  Adds functionality to `TBLFileReadFlags`.
  /// </summary>
  _TBLFileInfoFlagsHelper = record helper for TBLFileInfoFlags
  public const
    /// <summary>
    ///  A combination of `OwnerR`, `OwnerW` and `OwnerX`.
    /// </summary>
    OwnerMask = [TBLFileInfoFlag.OwnerR, TBLFileInfoFlag.OwnerW, TBLFileInfoFlag.OwnerX];

    /// <summary>
    ///  A combination of `GroupR`, `GroupW` and `GroupX`.
    /// </summary>
    GroupMask = [TBLFileInfoFlag.GroupR, TBLFileInfoFlag.GroupW, TBLFileInfoFlag.GroupX];

    /// <summary>
    ///  A combination of `OtherR`, `OtherW` and `OtherX`.
    /// </summary>
    OtherMask = [TBLFileInfoFlag.OtherR, TBLFileInfoFlag.OtherW, TBLFileInfoFlag.OtherX];

    /// <summary>
    ///  A combination of all file permission bits.
    /// </summary>
    PermissionMask = [
      TBLFileInfoFlag.OwnerR, TBLFileInfoFlag.OwnerW, TBLFileInfoFlag.OwnerX,
      TBLFileInfoFlag.GroupR, TBLFileInfoFlag.GroupW, TBLFileInfoFlag.GroupX,
      TBLFileInfoFlag.OtherR, TBLFileInfoFlag.OtherW, TBLFileInfoFlag.OtherX,
      TBLFileInfoFlag.SetUid, TBLFileInfoFlag.SetGid];
  end;

type
  /// <summary>
  ///  File information.
  /// </summary>
  TBLFileInfo = record
  {$REGION 'Internal Declarations'}
  private
    FSize: Int64;
    FModifiedTime: Int64;
    FFlags: TBLFileInfoFlags;
    FUid: UInt32;
    FGid: UInt32;
    {$HINTS OFF}
    FReserved: array [0..4] of UInt32;
    {$HINTS ON}
    function GetModifiedTime: TDateTime; inline;
    function GetHasOwnerR: Boolean; inline;
    function GetHasOwnerW: Boolean; inline;
    function GetHasOwnerX: Boolean; inline;
    function GetHasGroupR: Boolean; inline;
    function GetHasGroupW: Boolean; inline;
    function GetHasGroupX: Boolean; inline;
    function GetHasOtherR: Boolean; inline;
    function GetHasOtherW: Boolean; inline;
    function GetHasOtherX: Boolean; inline;
    function GetHasSetUid: Boolean; inline;
    function GetHasSetGid: Boolean; inline;
    function GetIsRegular: Boolean; inline;
    function GetIsDirectory: Boolean; inline;
    function GetIsSymLink: Boolean; inline;
    function GetIsCharDevice: Boolean; inline;
    function GetIsBlockDevice: Boolean; inline;
    function GetIsFifo: Boolean; inline;
    function GetIsSocket: Boolean; inline;
    function GetIsHidden: Boolean; inline;
    function GetIsExecutable: Boolean; inline;
    function GetIsArchive: Boolean; inline;
    function GetIsSystem: Boolean; inline;
    function GetIsValid: Boolean; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    function HasFlag(const AFlag: TBLFileInfoFlag): Boolean; inline;

    property Size: Int64 read FSize;
    property ModifiedTime: TDateTime read GetModifiedTime;
    property Flags: TBLFileInfoFlags read FFlags;
    property UserId: Cardinal read FUid;
    property GroupId: Cardinal read FGid;

    property HasOwnerR: Boolean read GetHasOwnerR;
    property HasOwnerW: Boolean read GetHasOwnerW;
    property HasOwnerX: Boolean read GetHasOwnerX;

    property HasGroupR: Boolean read GetHasGroupR;
    property HasGroupW: Boolean read GetHasGroupW;
    property HasGroupX: Boolean read GetHasGroupX;

    property HasOtherR: Boolean read GetHasOtherR;
    property HasOtherW: Boolean read GetHasOtherW;
    property HasOtherX: Boolean read GetHasOtherX;

    property HasSetUid: Boolean read GetHasSetUid;
    property HasSetGid: Boolean read GetHasSetGid;

    property IsRegular: Boolean read GetIsRegular;
    property IsDirectory: Boolean read GetIsDirectory;
    property IsSymLink: Boolean read GetIsSymLink;

    property IsCharDevice: Boolean read GetIsCharDevice;
    property IsBlockDevice: Boolean read GetIsBlockDevice;
    property IsFifo: Boolean read GetIsFifo;
    property IsSocket: Boolean read GetIsSocket;

    property IsHidden: Boolean read GetIsHidden;
    property IsExecutable: Boolean read GetIsExecutable;
    property IsArchive: Boolean read GetIsArchive;
    property IsSystem: Boolean read GetIsSystem;

    property IsValid: Boolean read GetIsValid;
  end;
  PBLFileInfo = ^TBLFileInfo;

type
  /// <summary>
  ///  A thin abstraction over a native OS file IO.
  ///
  ///  A thin wrapper around a native OS file support. The file handle is always
  ///  `THandle` and it refers to either a file descriptor on POSIX targets and
  ///  file handle on Windows targets.
  /// </summary>
  TBLFile = record
  {$REGION 'Internal Declarations'}
  private
    FHandle: THandle;
    function GetIsOpen: Boolean; inline;
    function GetSize: Int64; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Creates an empty file instance, which doesn't represent any open file.
    /// </summary>
    /// <remarks>
    ///  The internal file handle of non-opened files is set to `THandle.MaxValue`.
    /// <remarks>
    class operator Initialize(out ADest: TBLFile);

    /// <summary>
    ///  Destroys this file instance - closes the file descriptor or handle when
    ///  it's referencing an open file.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Finalize(var ADest: TBLFile);

    /// <summary>
    ///  Copying a file is not allowed. This will raise a `EBlend2DError`
    ///  exception with result `TBLResult.NotPermitted`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Assign(var ADest: TBLFile; const [ref] ASrc: TBLFile); inline;

    /// <summary>
    ///  Creates a file instance from an existing file `AHandle`, which either
    ///  represents a file descriptor or Windows handle.
    /// </summary>
    constructor Create(const AHandle: THandle);

    /// <summary>
    ///  Used to compare against `nil` (empty file instance).
    /// </summary>
    class operator Equal(const ALeft: TBLFile; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Used to compare against `nil` (empty file instance).
    /// </summary>
    class operator NotEqual(const ALeft: TBLFile; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Attempts to open a file specified by `AFilename` with the given
    ///  `AOpenFlags`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Open(const AFilename: String;
      const AOpenFlags: TBLFileOpenFlags); inline;

    /// <summary>
    ///  Closes the file (if open) and sets the file handle to `THandle.MaxValue`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Close; inline;

    /// <summary>
    ///  Sets the file position of the file to the given `AOffset` by using the
    ///  specified `ASeekType` and returns the new position.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function Seek(const AOffset: Int64; const ASeekType: TBLFileSeekType): Int64; inline;

    /// <summary>
    ///  Reads `ACount` bytes from the file into the given `ABuffer` and returns
    ///  the number of bytes actually read.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function Read(var ABuffer; const ACount: Int64): Int64; inline;

    /// <summary>
    ///  Writes `ACount` bytes to the file from the given `ABuffer` and returns
    ///  the number of bytes actually written.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function Write(const ABuffer; const ACount: Int64): Int64; inline;

    /// <summary>
    ///  Truncates the file to the given maximum size `AMaxSize`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Truncate(const AMaxSize: Int64); inline;

    /// <summary>
    ///  Queries information of the file.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function GetInfo: TBLFileInfo;

    /// <summary>
    ///  Whether the file is open.
    /// </summary>
    property IsOpen: Boolean read GetIsOpen;

    /// <summary>
    ///  The size of the file.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property Size: Int64 read GetSize;
  end;

type
  /// <summary>
  ///  File-system utilities.
  /// </summary>
  TBLFileSystem = record // static
  public
    class function FileInfo(const AFilename: String): TBLFileInfo; inline; static;
    class procedure ReadFile(const AFilename: String; const ADst: TBLArray<Byte>;
      const AMaxSize: NativeInt = 0; const AReadFlags: TBLFileReadFlags = []); inline; static;
    class function WriteFile(const AFilename: String; const AData;
      const ACount: NativeInt): NativeInt; overload; inline; static;
    class function WriteFile(const AFilename: String;
      const AData: TBLArrayView<Byte>): NativeInt; overload; inline; static;
    class function WriteFile(const AFilename: String; const AData: TBLArray<Byte>): NativeInt; overload; inline; static;
    class function WriteFile(const AFilename: String; const AData: TBytes): NativeInt; overload; inline; static;
  end;
{$ENDREGION 'File System'}

{$REGION 'Geometries'}

{ ============================================================================
   [Geometries - Geometry Enums]
  ============================================================================ }

type
  /// <summary>
  ///  Direction of a geometry used by geometric primitives and paths.
  /// </summary>
  TBLGeometryDirection = (
    /// <summary>
    ///  No direction specified.
    /// </summary>
    None,

    /// <summary>
    ///  Clockwise direction.
    /// </summary>
    CW,

    /// <summary>
    ///  Counter-clockwise direction.
    /// </summary>
    CCW);

type
  /// <summary>
  ///  Geometry type.
  ///
  ///  Geometry describes a shape or path that can be either rendered or added
  ///  to `TBLPath` container. Both `TBLPath` and `TBLContext` provide
  ///  functionality to work with all geometry types. Please note that each type
  ///  provided here requires to pass a matching record to the function that
  ///  consumes `AGeometryType` and `AGeometryData` arguments.
  /// </summary>
  /// <seealso cref="TBLPath"/>
  /// <seealso cref="TBLContext"/>
  TBLGeometryType = (
    /// <summary>
    ///  No geometry provided.
    /// </summary>
    None,

    /// <summary>
    ///  TBLBoxI record.
    /// </summary>
    BoxI,

    /// <summary>
    ///  TBLBox record.
    /// </summary>
    BoxD,

    /// <summary>
    ///  TBLRectI record.
    /// </summary>
    RectI,

    /// <summary>
    ///  TBLRect record.
    /// </summary>
    RectD,

    /// <summary>
    ///  TBLCircle record.
    /// </summary>
    Circle,

    /// <summary>
    ///  TBLEllipse record.
    /// </summary>
    Ellipse,

    /// <summary>
    ///  TBLRoundRect record.
    /// </summary>
    RoundRect,

    /// <summary>
    ///  TBLArc record.
    /// </summary>
    Arc,

    /// <summary>
    ///  TBLArc record representing chord.
    /// </summary>
    Chord,

    /// <summary>
    ///  TBLArc record representing pie.
    /// </summary>
    Pie,

    /// <summary>
    ///  TBLLine record.
    /// </summary>
    Line,

    /// <summary>
    ///  TBLTriangle record.
    /// </summary>
    Triangle,

    /// <summary>
    ///  TBLArrayView<TBLPointI> representing a polyline.
    /// </summary>
    PolylineI,

    /// <summary>
    ///  TBLArrayView<TBLPoint> representing a polyline.
    /// </summary>
    PolylineD,

    /// <summary>
    ///  TBLArrayView<BLPointI> representing a polygon.
    /// </summary>
    PolygonI,

    /// <summary>
    ///  TBLArrayView<BLPoint> representing a polygon.
    /// </summary>
    PolygonD,

    /// <summary>
    ///  TBLArrayView<BLBoxI> record.
    /// </summary>
    ArrayViewBoxI,

    /// <summary>
    ///  TBLArrayView<BLBox> record.
    /// </summary>
    ArrayViewBoxD,

    /// <summary>
    ///  TBLArrayView<BLRectI> record.
    /// </summary>
    ArrayViewRectI,

    /// <summary>
    ///  TBLArrayView<BLRect> record.
    /// </summary>
    ArrayViewRectD,

    /// <summary>
    ///  TBLPath.
    /// </summary>
    Path);

type
  /// <summary>
  ///  Fill rule.
  /// </summary>
  TBLFillRule = (
    /// <summary>
    ///  Non-zero fill-rule.
    /// </summary>
    NonZero,

    /// <summary>
    ///  Even-odd fill-rule.
    /// </summary>
    EvenOdd);

type
  /// <summary>
  ///  Hit-test result.
  /// </summary>
  TBLHitTest = (
    /// <summary>
    ///  Fully in.
    /// </summary>
    FullyIn,

    /// <summary>
    ///  Partially in/out.
    /// </summary>
    Partial,

    /// <summary>
    ///  Fully out.
    /// </summary>
    FullyOut,

    /// <summary>
    ///  Hit test failed (invalid argument, NaNs, etc).
    /// </summary>
    Invalid = Integer($FFFFFFFF));

{ ============================================================================
   [Geometries - Lightweight Geometries and Structs]
  ============================================================================ }

type
  /// <summary>
  ///  Point specified as [X, Y] using `Double` as a storage type.
  /// </summary>
  TBLPoint = record
  public
    X: Double;
    Y: Double;
  public
    constructor Create(const AX, AY: Double);

    class operator Equal(const ALeft, ARight: TBLPoint): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLPoint): Boolean; inline; static;
    class operator Negative(const AValue: TBLPoint): TBLPoint; inline; static;
    class operator Add(const ALeft: TBLPoint; const ARight: Double): TBLPoint; inline; static;
    class operator Subtract(const ALeft: TBLPoint; const ARight: Double): TBLPoint; inline; static;
    class operator Multiply(const ALeft: TBLPoint; const ARight: Double): TBLPoint; inline; static;
    class operator Divide(const ALeft: TBLPoint; const ARight: Double): TBLPoint; inline; static;
    class operator Add(const ALeft: Double; const ARight: TBLPoint): TBLPoint; inline; static;
    class operator Subtract(const ALeft: Double; const ARight: TBLPoint): TBLPoint; inline; static;
    class operator Multiply(const ALeft: Double; const ARight: TBLPoint): TBLPoint; inline; static;
    class operator Divide(const ALeft: Double; const ARight: TBLPoint): TBLPoint; inline; static;
    class operator Add(const ALeft, ARight: TBLPoint): TBLPoint; inline; static;
    class operator Subtract(const ALeft, ARight: TBLPoint): TBLPoint; inline; static;
    class operator Multiply(const ALeft, ARight: TBLPoint): TBLPoint; inline; static;
    class operator Divide(const ALeft, ARight: TBLPoint): TBLPoint; inline; static;

    procedure Reset; overload; inline;
    procedure Reset(const AX, AY: Double); overload; inline;
    procedure Reset(const AOther: TBLPoint); overload; inline;

    function Equals(const AOther: TBLPoint): Boolean; inline;
  end;
  PBLPoint = ^TBLPoint;

type
  /// <summary>
  ///  Adds functionality to TBLPoint
  /// </summary>
  _TBLPointHelper = record helper for TBLPoint
  public const
    Empty: TBLPoint = (X: 0; Y: 0);
  end;

function BLPoint(const AX, AY: Double): TBLPoint; inline;
function BLAbs(const AValue: TBLPoint): TBLPoint; overload; inline;
function BLMin(const AA, AB: TBLPoint): TBLPoint; overload; inline;
function BLMin(const AA: TBLPoint; const AB: Double): TBLPoint; overload; inline;
function BLMin(const AA: Double; const AB: TBLPoint): TBLPoint; overload; inline;
function BLMax(const AA, AB: TBLPoint): TBLPoint; overload; inline;
function BLMax(const AA: TBLPoint; const AB: Double): TBLPoint; overload; inline;
function BLMax(const AA: Double; const AB: TBLPoint): TBLPoint; overload; inline;
function BLClamp(const AA: TBLPoint; const AB, AC: Double): TBLPoint; inline;

type
  /// <summary>
  ///  Point specified as [X, Y] using `Integer` as a storage type.
  /// </summary>
  TBLPointI = record
  public
    X: Integer;
    Y: Integer;
  public
    constructor Create(const AX, AY: Integer);

    class operator Equal(const ALeft, ARight: TBLPointI): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLPointI): Boolean; inline; static;
    class operator Negative(const AValue: TBLPointI): TBLPointI; inline; static;
    class operator Add(const ALeft: TBLPointI; const ARight: Integer): TBLPointI; inline; static;
    class operator Subtract(const ALeft: TBLPointI; const ARight: Integer): TBLPointI; inline; static;
    class operator Multiply(const ALeft: TBLPointI; const ARight: Integer): TBLPointI; inline; static;
    class operator Add(const ALeft: Integer; const ARight: TBLPointI): TBLPointI; inline; static;
    class operator Subtract(const ALeft: Integer; const ARight: TBLPointI): TBLPointI; inline; static;
    class operator Multiply(const ALeft: Integer; const ARight: TBLPointI): TBLPointI; inline; static;
    class operator Add(const ALeft, ARight: TBLPointI): TBLPointI; inline; static;
    class operator Subtract(const ALeft, ARight: TBLPointI): TBLPointI; inline; static;
    class operator Multiply(const ALeft, ARight: TBLPointI): TBLPointI; inline; static;

    procedure Reset; overload; inline;
    procedure Reset(const AX, AY: Integer); overload; inline;
    procedure Reset(const AOther: TBLPointI); overload; inline;

    function Equals(const AOther: TBLPointI): Boolean; inline;
  end;
  PBLPointI = ^TBLPointI;

type
  /// <summary>
  ///  Adds functionality to TBLPointI
  /// </summary>
  _TBLPointIHelper = record helper for TBLPointI
  public const
    Empty: TBLPointI = (X: 0; Y: 0);
  end;

function BLPointI(const AX, AY: Integer): TBLPointI; inline;

type
  /// <summary>
  ///  Size specified as [W, H] using `Double` as a storage type.
  /// </summary>
  TBLSize = record
  public
    W: Double;
    H: Double;
  public
    constructor Create(const AW, AH: Double);

    class operator Equal(const ALeft, ARight: TBLSize): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLSize): Boolean; inline; static;

    procedure Reset; overload; inline;
    procedure Reset(const AW, AH: Double); overload; inline;
    procedure Reset(const AOther: TBLSize); overload; inline;

    function Equals(const AOther: TBLSize): Boolean; inline;
  end;
  PBLSize = ^TBLSize;

type
  /// <summary>
  ///  Adds functionality to TBLSize
  /// </summary>
  _TBLSizeHelper = record helper for TBLSize
  public const
    Empty: TBLSize = (W: 0; H: 0);
  end;

function BLSize(const AW, AH: Double): TBLSize; inline;
function BLAbs(const AValue: TBLSize): TBLSize; overload; inline;
function BLMin(const AA, AB: TBLSize): TBLSize; overload; inline;
function BLMax(const AA, AB: TBLSize): TBLSize; overload; inline;

type
  /// <summary>
  ///  Size specified as [W, H] using `Integer` as a storage type.
  /// </summary>
  TBLSizeI = record
  public
    W: Integer;
    H: Integer;
  public
    constructor Create(const AW, AH: Integer);

    class operator Equal(const ALeft, ARight: TBLSizeI): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLSizeI): Boolean; inline; static;

    procedure Reset; overload; inline;
    procedure Reset(const AW, AH: Integer); overload; inline;
    procedure Reset(const AOther: TBLSizeI); overload; inline;

    function Equals(const AOther: TBLSizeI): Boolean; inline;
  end;
  PBLSizeI = ^TBLSizeI;

type
  /// <summary>
  ///  Adds functionality to TBLSizeI
  /// </summary>
  _TBLSizeIHelper = record helper for TBLSizeI
  public const
    Empty: TBLSizeI = (W: 0; H: 0);
  end;

function BLSizeI(const AW, AH: Integer): TBLSizeI; inline;

type
  /// <summary>
  ///  Box specified as [X0, Y0, X1, Y1] using `Double` as a storage type.
  /// </summary>
  TBLBox = record
  public
    X0: Double;
    Y0: Double;
    X1: Double;
    Y1: Double;
  public
    constructor Create(const AX0, AY0, AX1, AY1: Double);

    class operator Equal(const ALeft, ARight: TBLBox): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLBox): Boolean; inline; static;
    class operator Add(const ALeft: TBLBox; const ARight: Double): TBLBox; inline; static;
    class operator Subtract(const ALeft: TBLBox; const ARight: Double): TBLBox; inline; static;
    class operator Multiply(const ALeft: TBLBox; const ARight: Double): TBLBox; inline; static;
    class operator Divide(const ALeft: TBLBox; const ARight: Double): TBLBox; inline; static;
    class operator Add(const ALeft: Double; const ARight: TBLBox): TBLBox; inline; static;
    class operator Subtract(const ALeft: Double; const ARight: TBLBox): TBLBox; inline; static;
    class operator Multiply(const ALeft: Double; const ARight: TBLBox): TBLBox; inline; static;
    class operator Divide(const ALeft: Double; const ARight: TBLBox): TBLBox; inline; static;
    class operator Add(const ALeft: TBLBox; const ARight: TBLPoint): TBLBox; inline; static;
    class operator Subtract(const ALeft: TBLBox; const ARight: TBLPoint): TBLBox; inline; static;
    class operator Multiply(const ALeft: TBLBox; const ARight: TBLPoint): TBLBox; inline; static;
    class operator Divide(const ALeft: TBLBox; const ARight: TBLPoint): TBLBox; inline; static;
    class operator Add(const ALeft: TBLPoint; const ARight: TBLBox): TBLBox; inline; static;
    class operator Subtract(const ALeft: TBLPoint; const ARight: TBLBox): TBLBox; inline; static;
    class operator Multiply(const ALeft: TBLPoint; const ARight: TBLBox): TBLBox; inline; static;
    class operator Divide(const ALeft: TBLPoint; const ARight: TBLBox): TBLBox; inline; static;

    procedure Reset; overload; inline;
    procedure Reset(const AX0, AY0, AX1, AY1: Double); overload; inline;
    procedure Reset(const AOther: TBLBox); overload; inline;

    function Equals(const AOther: TBLBox): Boolean; inline;
    function Contains(const AX, AY: Double): Boolean; overload; inline;
    function Contains(const APoint: TBLPoint): Boolean; overload; inline;
  end;
  PBLBox = ^TBLBox;

type
  /// <summary>
  ///  Adds functionality to TBLBox
  /// </summary>
  _TBLBoxHelper = record helper for TBLBox
  public const
    Empty: TBLBox = (X0: 0; Y0: 0; X1: 0; Y1: 0);
  end;

function BLBox(const AX0, AY0, AX1, AY1: Double): TBLBox; inline;

type
  /// <summary>
  ///  Box specified as [X0, Y0, X1, Y1] using `Integer` as a storage type.
  /// </summary>
  TBLBoxI = record
  public
    X0: Integer;
    Y0: Integer;
    X1: Integer;
    Y1: Integer;
  public
    constructor Create(const AX0, AY0, AX1, AY1: Integer);

    class operator Equal(const ALeft, ARight: TBLBoxI): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLBoxI): Boolean; inline; static;

    procedure Reset; overload; inline;
    procedure Reset(const AX0, AY0, AX1, AY1: Integer); overload; inline;
    procedure Reset(const AOther: TBLBoxI); overload; inline;

    function Equals(const AOther: TBLBoxI): Boolean; inline;
    function Contains(const AX, AY: Integer): Boolean; overload; inline;
    function Contains(const APoint: TBLPointI): Boolean; overload; inline;
  end;
  PBLBoxI = ^TBLBoxI;

type
  /// <summary>
  ///  Adds functionality to TBLBoxI
  /// </summary>
  _TBLBoxIHelper = record helper for TBLBoxI
  public const
    Empty: TBLBoxI = (X0: 0; Y0: 0; X1: 0; Y1: 0);
  end;

function BLBoxI(const AX0, AY0, AX1, AY1: Integer): TBLBoxI; inline;

type
  /// <summary>
  ///  Rectangle specified as [X, Y, W, H] using `Double` as a storage type.
  /// </summary>
  TBLRect = record
  public
    X: Double;
    Y: Double;
    W: Double;
    H: Double;
  public
    constructor Create(const AX, AY, AW, AH: Double);

    class operator Equal(const ALeft, ARight: TBLRect): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLRect): Boolean; inline; static;

    procedure Reset; overload; inline;
    procedure Reset(const AX, AY, AW, AH: Double); overload; inline;
    procedure Reset(const AOther: TBLRect); overload; inline;

    function Equals(const AOther: TBLRect): Boolean; inline;
  end;
  PBLRect = ^TBLRect;

type
  /// <summary>
  ///  Adds functionality to TBLRect
  /// </summary>
  _TBLRectHelper = record helper for TBLRect
  public const
    Empty: TBLRect = (X: 0; Y: 0; W: 0; H: 0);
  end;

function BLRect(const AX, AY, AW, AH: Double): TBLRect; inline;

type
  /// <summary>
  ///  Rectangle specified as [X, Y, W, H] using `Integer` as a storage type.
  /// </summary>
  TBLRectI = record
  public
    X: Integer;
    Y: Integer;
    W: Integer;
    H: Integer;
  public
    constructor Create(const AX, AY, AW, AH: Integer);

    class operator Equal(const ALeft, ARight: TBLRectI): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLRectI): Boolean; inline; static;

    procedure Reset; overload; inline;
    procedure Reset(const AX, AY, AW, AH: Integer); overload; inline;
    procedure Reset(const AOther: TBLRectI); overload; inline;

    function Equals(const AOther: TBLRectI): Boolean; inline;
  end;
  PBLRectI = ^TBLRectI;

type
  /// <summary>
  ///  Adds functionality to TBLRectI
  /// </summary>
  _TBLRectIHelper = record helper for TBLRectI
  public const
    Empty: TBLRectI = (X: 0; Y: 0; W: 0; H: 0);
  end;

function BLRectI(const AX, AY, AW, AH: Integer): TBLRectI; inline;

type
  /// <summary>
  ///  Rounded rectangle specified as [X, Y, W, H, RX, RY] using `Double` as a
  ///  storage type.
  /// </summary>
  TBLRoundRect = record
  public
    X: Double;
    Y: Double;
    W: Double;
    H: Double;
    RX: Double;
    RY: Double;
  public
    constructor Create(const ARect: TBLRect; const AR: Double); overload;
    constructor Create(const ARect: TBLRect; const ARX, ARY: Double); overload;
    constructor Create(const AX, AY, AW, AH, AR: Double); overload;
    constructor Create(const AX, AY, AW, AH, ARX, ARY: Double); overload;

    class operator Equal(const ALeft, ARight: TBLRoundRect): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLRoundRect): Boolean; inline; static;

    procedure Reset; overload; inline;
    procedure Reset(const ARect: TBLRect; const AR: Double); overload; inline;
    procedure Reset(const ARect: TBLRect; const ARX, ARY: Double); overload; inline;
    procedure Reset(const AX, AY, AW, AH, AR: Double); overload; inline;
    procedure Reset(const AX, AY, AW, AH, ARX, ARY: Double); overload; inline;
    procedure Reset(const AOther: TBLRoundRect); overload; inline;

    function Equals(const AOther: TBLRoundRect): Boolean; inline;
  end;
  PBLRoundRect = ^TBLRoundRect;

type
  /// <summary>
  ///  Adds functionality to TBLRoundRect
  /// </summary>
  _TBLRoundRectHelper = record helper for TBLRoundRect
  public const
    Empty: TBLRoundRect = (X: 0; Y: 0; W: 0; H: 0; RX: 0; RY: 0);
  end;

function BLRoundRect(const ARect: TBLRect; const AR: Double): TBLRoundRect; overload; inline;
function BLRoundRect(const ARect: TBLRect; const ARX, ARY: Double): TBLRoundRect; overload; inline;
function BLRoundRect(const AX, AY, AW, AH, AR: Double): TBLRoundRect; overload; inline;
function BLRoundRect(const AX, AY, AW, AH, ARX, ARY: Double): TBLRoundRect; overload; inline;

type
  /// <summary>
  ///  Circle specified as [CX, CY, R] using `Double` as a storage type.
  /// </summary>
  TBLCircle = record
  public
    CX: Double;
    CY: Double;
    R: Double;
  public
    constructor Create(const ACX, ACY, AR: Double);

    class operator Equal(const ALeft, ARight: TBLCircle): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLCircle): Boolean; inline; static;

    procedure Reset; overload; inline;
    procedure Reset(const ACX, ACY, AR: Double); overload; inline;
    procedure Reset(const AOther: TBLCircle); overload; inline;

    function Equals(const AOther: TBLCircle): Boolean; inline;
  end;
  PBLCircle = ^TBLCircle;

type
  /// <summary>
  ///  Adds functionality to TBLCircle
  /// </summary>
  _TBLCircleHelper = record helper for TBLCircle
  public const
    Empty: TBLCircle = (CX: 0; CY: 0; R: 0);
  end;

function BLCircle(const ACX, ACY, AR: Double): TBLCircle; inline;

type
  /// <summary>
  ///  Ellipse specified as [CX, CY, RX, RY] using `Double` as a storage type.
  /// </summary>
  TBLEllipse = record
  public
    CX: Double;
    CY: Double;
    RX: Double;
    RY: Double;
  public
    constructor Create(const ACX, ACY, AR: Double); overload;
    constructor Create(const ACX, ACY, ARX, ARY: Double); overload;

    class operator Equal(const ALeft, ARight: TBLEllipse): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLEllipse): Boolean; inline; static;

    procedure Reset; overload; inline;
    procedure Reset(const ACX, ACY, AR: Double); overload; inline;
    procedure Reset(const ACX, ACY, ARX, ARY: Double); overload; inline;
    procedure Reset(const AOther: TBLEllipse); overload; inline;

    function Equals(const AOther: TBLEllipse): Boolean; inline;
  end;
  PBLEllipse = ^TBLEllipse;

type
  /// <summary>
  ///  Adds functionality to TBLEllipse
  /// </summary>
  _TBLEllipseHelper = record helper for TBLEllipse
  public const
    Empty: TBLEllipse = (CX: 0; CY: 0; RX: 0; RY: 0);
  end;

function BLEllipse(const ACX, ACY, AR: Double): TBLEllipse; overload; inline;
function BLEllipse(const ACX, ACY, ARX, ARY: Double): TBLEllipse; overload; inline;

type
  /// <summary>
  ///  Arc specified as [CX, CY, RX, RY, Start, Sweep] using `Double` as a
  ///  storage type.
  /// </summary>
  TBLArc = record
  public
    CX: Double;
    CY: Double;
    RX: Double;
    RY: Double;
    Start: Double;
    Sweep: Double;
  public
    constructor Create(const ACX, ACY, ARX, ARY, AStart, ASweep: Double);

    class operator Equal(const ALeft, ARight: TBLArc): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLArc): Boolean; inline; static;

    procedure Reset; overload; inline;
    procedure Reset(const ACX, ACY, ARX, ARY, AStart, ASweep: Double); overload; inline;
    procedure Reset(const AOther: TBLArc); overload; inline;

    function Equals(const AOther: TBLArc): Boolean; inline;
  end;
  PBLArc = ^TBLArc;

type
  /// <summary>
  ///  Adds functionality to TBLArc
  /// </summary>
  _TBLArcHelper = record helper for TBLArc
  public const
    Empty: TBLArc = (CX: 0; CY: 0; RX: 0; RY: 0; Start: 0; Sweep: 0);
  end;

function BLArc(const ACX, ACY, ARX, ARY, AStart, ASweep: Double): TBLArc; inline;

type
  /// <summary>
  ///  Line specified as [X0, Y0, X1, Y1] using `Double` as a storage type.
  /// </summary>
  TBLLine = record
  public
    X0: Double;
    Y0: Double;
    X1: Double;
    Y1: Double;
  public
    constructor Create(const AX0, AY0, AX1, AY1: Double);

    class operator Equal(const ALeft, ARight: TBLLine): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLLine): Boolean; inline; static;

    procedure Reset; overload; inline;
    procedure Reset(const AX0, AY0, AX1, AY1: Double); overload; inline;
    procedure Reset(const AP0, AP1: TBLPoint); overload; inline;
    procedure Reset(const AOther: TBLLine); overload; inline;

    function Equals(const AOther: TBLLine): Boolean; inline;
  end;
  PBLLine = ^TBLLine;

type
  /// <summary>
  ///  Adds functionality to TBLLine
  /// </summary>
  _TBLLineHelper = record helper for TBLLine
  public const
    Empty: TBLLine = (X0: 0; Y0: 0; X1: 0; Y1: 0);
  end;

function BLLine(const AX0, AY0, AX1, AY1: Double): TBLLine; overload; inline;
function BLLine(const AP0, AP1: TBLPoint): TBLLine; overload; inline;

type
  /// <summary>
  ///  Triangle data specified as [X0, Y0, X1, Y1, X2, Y2] using `Double` as a
  ///  storage type.
  /// </summary>
  TBLTriangle = record
  public
    X0: Double;
    Y0: Double;
    X1: Double;
    Y1: Double;
    X2: Double;
    Y2: Double;
  public
    constructor Create(const AX0, AY0, AX1, AY1, AX2, AY2: Double);

    class operator Equal(const ALeft, ARight: TBLTriangle): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLTriangle): Boolean; inline; static;

    procedure Reset; overload; inline;
    procedure Reset(const AX0, AY0, AX1, AY1, AX2, AY2: Double); overload; inline;
    procedure Reset(const AOther: TBLTriangle); overload; inline;

    function Equals(const AOther: TBLTriangle): Boolean; inline;
  end;
  PBLTriangle = ^TBLTriangle;

type
  /// <summary>
  ///  Adds functionality to TBLTriangle
  /// </summary>
  _TBLTriangleHelper = record helper for TBLTriangle
  public const
    Empty: TBLTriangle = (X0: 0; Y0: 0; X1: 0; Y1: 0; X2: 0; Y2: 0);
  end;

function BLTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double): TBLTriangle; inline;

{ ============================================================================
   [Geometries - Transformations]
  ============================================================================ }

type
  /// <summary>
  ///  Transformation matrix operation type.
  /// </summary>
  TBLTransformOp = (
    /// <summary>
    ///  Reset matrix to identity (argument ignored, should be nil).
    /// </summary>
    Reset,

    /// <summary>
    ///  Assign (copy) the other matrix.
    /// </summary>
    Assign,

    /// <summary>
    ///  Translate the matrix by [X, Y].
    /// </summary>
    Translate,

    /// <summary>
    ///  Scale the matrix by [X, Y].
    /// </summary>
    Scale,

    /// <summary>
    ///  Skew the matrix by [X, Y].
    /// </summary>
    Skew,

    /// <summary>
    ///  Rotate the matrix by the given angle about [0, 0].
    /// </summary>
    Rotate,

    /// <summary>
    ///  Rotate the matrix by the given angle about [X, Y].
    /// </summary>
    RotatePoint,

    /// <summary>
    ///  Transform this matrix by other `TBLMatrix2D`.
    /// </summary>
    /// <seealso cref="TBLMatrix2D"/>
    Transform,

    /// <summary>
    ///  Post-translate the matrix by [X, Y].
    /// </summary>
    PostTranslate,

    /// <summary>
    ///  Post-scale the matrix by [X, Y].
    /// </summary>
    PostScale,

    /// <summary>
    ///  Post-skew the matrix by [X, Y].
    /// </summary>
    PostSkew,

    /// <summary>
    ///  Post-rotate the matrix about [0, 0].
    /// </summary>
    PostRotate,

    /// <summary>
    ///  Post-rotate the matrix about a reference `TBLPoint`.
    /// </summary>
    /// <seealso cref="TBLPoint"/>
    PostRotatePoint,

    /// <summary>
    ///  Post-transform this matrix by other `TBLMatrix2D`.
    /// </summary>
    /// <seealso cref="TBLMatrix2D"/>
    PostTransform);

type
  /// <summary>
  ///  Transformation matrix type that can be obtained by calling
  ///  `TBLMatrix2D.Kind`.
  ///
  ///  ```
  ///   Identity  Transl.  Scale     Swap    Affine
  ///    [1  0]   [1  0]   [.  0]   [0  .]   [.  .]
  ///    [0  1]   [0  1]   [0  .]   [.  0]   [.  .]
  ///    [0  0]   [.  .]   [.  .]   [.  .]   [.  .]
  ///  ```
  /// </summary>
  TBLTransformKind = (
    /// <summary>
    ///  Identity matrix.
    /// </summary>
    Identity,

    /// <summary>
    ///  Has translation part (the rest is like identity).
    /// </summary>
    Translate,

    /// <summary>
    ///  Has translation and scaling parts.
    /// </summary>
    Scale,

    /// <summary>
    ///  Has translation and scaling parts, however scaling swaps X/Y.
    /// </summary>
    Swap,

    /// <summary>
    ///  Generic affine matrix.
    /// </summary>
    Affine,

    /// <summary>
    ///  Invalid/degenerate matrix not useful for transformations.
    /// </summary>
    Invalid);

type
  /// <summary>
  ///  2D matrix represents an affine transformation matrix that can be used to
  ///  transform geometry and images.
  /// </summary>
  TBLMatrix2D = record
  {$REGION 'Internal Declarations'}
  private
    function GetKind: TBLTransformKind; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    M: array [0..5] of Double;
  public
    constructor Create(const AM00, AM01, AM10, AM11, AM20, AM21: Double);

    class operator Equal(const ALeft, ARight: TBLMatrix2D): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLMatrix2D): Boolean; inline; static;

    function Equals(const AOther: TBLMatrix2D): Boolean; inline;

    /// <summary>
    ///  Creates a new matrix initialized to identity.
    /// </summary>
    class function MakeIdentity: TBLMatrix2D; inline; static;

    /// <summary>
    ///  Creates a new matrix initialized to translation.
    /// </summary>
    class function MakeTranslation(const AX, AY: Double): TBLMatrix2D; overload; inline; static;
    class function MakeTranslation(const AP: TBLPoint): TBLMatrix2D; overload; inline; static;
    class function MakeTranslation(const AP: TBLPointI): TBLMatrix2D; overload; inline; static;

    /// <summary>
    ///  Creates a new matrix initialized to scaling.
    /// </summary>
    class function MakeScaling(const AXY: Double): TBLMatrix2D; overload; inline; static;
    class function MakeScaling(const AX, AY: Double): TBLMatrix2D; overload; inline; static;
    class function MakeScaling(const AP: TBLPoint): TBLMatrix2D; overload; inline; static;
    class function MakeScaling(const AP: TBLPointI): TBLMatrix2D; overload; inline; static;

    /// <summary>
    ///  Creates a new matrix initialized to rotation.
    /// </summary>
    class function MakeRotation(const AAngle: Double): TBLMatrix2D; overload; inline; static;
    class function MakeRotation(const AAngle, AX, AY: Double): TBLMatrix2D; overload; inline; static;
    class function MakeRotation(const AAngle: Double; const AOrigin: TBLPoint): TBLMatrix2D; overload; inline; static;

    /// <summary>
    ///  Create a new skewing matrix.
    /// </summary>
    class function MakeSkewing(const AX, AY: Double): TBLMatrix2D; overload; inline; static;
    class function MakeSkewing(const AOrigin: TBLPoint): TBLMatrix2D; overload; inline; static;

    class function MakeSinCos(const ASin, ACos: Double; const ATX: Double = 0;
      const ATY: Double = 0): TBLMatrix2D; overload; inline; static;
    class function MakeSinCos(const ASin, ACos: Double; const AP: TBLPoint): TBLMatrix2D; overload; inline; static;

    /// <summary>
    ///  Resets matrix to identity.
    /// </summary>
    procedure Reset; overload; inline;

    /// <summary>
    ///  Resets matrix to `AOther` (copy its content to this matrix).
    /// </summary>
    procedure Reset(const AOther: TBLMatrix2D); overload; inline;

    /// <summary>
    ///  Resets matrix to `[AM00, AM01, AM10, AM11, AM20, AM21]`.
    /// </summary>
    procedure Reset(const AM00, AM01, AM10, AM11, AM20, AM21: Double); overload; inline;

    /// <summary>
    ///  Resets matrix to translation.
    /// </summary>
    procedure ResetToTranslation(const AX, AY: Double); overload; inline;

    /// <summary>
    ///  Resets matrix to translation.
    /// </summary>
    procedure ResetToTranslation(const AP: TBLPoint); overload; inline;

    /// <summary>
    ///  Resets matrix to translation.
    /// </summary>
    procedure ResetToTranslation(const AP: TBLPointI); overload; inline;

    /// <summary>
    ///  Resets matrix to scaling.
    /// </summary>
    procedure ResetToScaling(const AXY: Double); overload; inline;

    /// <summary>
    ///  Resets matrix to scaling.
    /// </summary>
    procedure ResetToScaling(const AX, AY: Double); overload; inline;

    /// <summary>
    ///  Resets matrix to scaling.
    /// </summary>
    procedure ResetToScaling(const AP: TBLPoint); overload; inline;

    /// <summary>
    ///  Resets matrix to scaling.
    /// </summary>
    procedure ResetToScaling(const AP: TBLPointI); overload; inline;

    /// <summary>
    ///  Resets matrix to skewing.
    /// </summary>
    procedure ResetToSkewing(const AX, AY: Double); overload; inline;

    /// <summary>
    ///  Resets matrix to skewing.
    /// </summary>
    procedure ResetToSkewing(const AP: TBLPoint); overload; inline;

    /// <summary>
    ///  Resets matrix to rotation specified by `ASin` and `ACos` and optional
    ///  translation `ATX` and `ATY`.
    /// </summary>
    procedure ResetToSinCos(const ASin, ACos: Double; const ATX: Double = 0;
      const ATY: Double = 0); overload; inline;

    /// <summary>
    ///  Resets matrix to rotation specified by `ASin` and `ACos` and
    ///  translation `AP`.
    /// </summary>
    procedure ResetToSinCos(const ASin, ACos: Double; const AP: TBLPoint); overload; inline;

    /// <summary>
    ///  Resets matrix to rotation.
    /// </summary>
    procedure ResetToRotation(const AAngle: Double); overload; inline;

    /// <summary>
    ///  Resets matrix to rotation around a point `[X, Y]`.
    /// </summary>
    procedure ResetToRotation(const AAngle, AX, AY: Double); overload; inline;

    /// <summary>
    ///  Resets matrix to rotation around a point `p`.
    /// </summary>
    procedure ResetToRotation(const AAngle: Double; const AOrigin: TBLPoint); overload; inline;

    /// <summary>
    ///  Calculates the matrix determinant.
    /// </summary>
    function Determinant: Double; inline;

    procedure Translate(const AX, AY: Double); overload; inline;
    procedure Translate(const AP: TBLPoint); overload; inline;
    procedure Translate(const AP: TBLPointI); overload; inline;

    procedure Scale(const AXY: Double); overload; inline;
    procedure Scale(const AX, AY: Double); overload; inline;
    procedure Scale(const AP: TBLPoint); overload; inline;
    procedure Scale(const AP: TBLPointI); overload; inline;

    procedure Skew(const AX, AY: Double); overload; inline;
    procedure Skew(const AP: TBLPoint); overload; inline;

    procedure Rotate(const AAngle: Double); overload; inline;
    procedure Rotate(const AAngle, AX, AY: Double); overload; inline;
    procedure Rotate(const AAngle: Double; const AP: TBLPoint); overload; inline;
    procedure Rotate(const AAngle: Double; const AP: TBLPointI); overload; inline;

    procedure Transform(const AM: TBLMatrix2D); inline;

    procedure PostTranslate(const AX, AY: Double); overload; inline;
    procedure PostTranslate(const AP: TBLPoint); overload; inline;
    procedure PostTranslate(const AP: TBLPointI); overload; inline;

    procedure PostScale(const AXY: Double); overload; inline;
    procedure PostScale(const AX, AY: Double); overload; inline;
    procedure PostScale(const AP: TBLPoint); overload; inline;
    procedure PostScale(const AP: TBLPointI); overload; inline;

    procedure PostSkew(const AX, AY: Double); overload; inline;
    procedure PostSkew(const AP: TBLPoint); overload; inline;

    procedure PostRotate(const AAngle: Double); overload; inline;
    procedure PostRotate(const AAngle, AX, AY: Double); overload; inline;
    procedure PostRotate(const AAngle: Double; const AP: TBLPoint); overload; inline;
    procedure PostRotate(const AAngle: Double; const AP: TBLPointI); overload; inline;

    procedure PostTransform(const AM: TBLMatrix2D); inline;

    /// <summary>
    ///  Inverts the matrix.
    ///  Returns True if the matrix has been inverted successfully.
    /// </summary>
    function Invert: Boolean; overload; inline;

    /// <summary>
    ///  Inverts `ASrc` matrix and stores the result in `ADst`.
    ///  Returns True if the matrix has been inverted successfully.
    /// </summary>
    class function Invert(const ASrc: TBLMatrix2D; out ADst: TBLMatrix2D): Boolean; overload; inline; static;

    function MapPoint(const AX, AY: Double): TBLPoint; overload; inline;
    function MapPoint(const AP: TBLPoint): TBLPoint; overload; inline;

    function MapVector(const AX, AY: Double): TBLPoint; overload; inline;
    function MapVector(const AP: TBLPoint): TBLPoint; overload; inline;

    /// <summary>
    ///  Element [0, 0]. Contains X scaling.
    /// </summary>
    property M00: Double read M[0] write M[0];

    /// <summary>
    ///  Element [0, 1]. Contains rotation and skewing.
    /// </summary>
    property M01: Double read M[1] write M[1];

    /// <summary>
    ///  Element [1, 0]. Contains rotation and skewing.
    /// </summary>
    property M10: Double read M[2] write M[2];

    /// <summary>
    ///  Element [1, 1]. Contains Y scaling.
    /// </summary>
    property M11: Double read M[3] write M[3];

    /// <summary>
    ///  Element [2, 0]. Contains X translation.
    /// </summary>
    property M20: Double read M[4] write M[4];

    /// <summary>
    ///  Element [2, 1]. Contains Y translation.
    /// </summary>
    property M21: Double read M[5] write M[5];

    /// <summary>
    ///  The matrix kind.
    /// </summary>
    property Kind: TBLTransformKind read GetKind;
  end;
  PBLMatrix2D = ^TBLMatrix2D;

type
  /// <summary>
  ///  Adds functionality to TBLMatrix2D
  /// </summary>
  _TBLMatrix2DHelper = record helper for TBLMatrix2D
  public const
    Identity: TBLMatrix2D = (M: (1, 0, 0, 1, 0, 0));
  end;

{ ============================================================================
   [Geometries - Path Operations]
  ============================================================================ }

type
  /// <summary>
  ///  Mode that specifies how to construct offset curves.
  /// </summary>
  TBLOffsetMode = (
    /// <summary>
    ///  Use default mode (decided by Blend2D).
    /// </summary>
    Default,

    /// <summary>
    ///  Iterative offset construction.
    /// </summary>
    Iterative);

type
  /// <summary>
  ///  Mode that specifies how curves are approximated to line segments.
  /// </summary>
  TBLFlattenMode = (
    /// <summary>
    ///  Use default mode (decided by Blend2D).
    /// </summary>
    Default,

    /// <summary>
    ///  Recursive subdivision flattening.
    /// </summary>
    Recursive);

type
  /// <summary>
  ///  A presentation attribute defining the shape to be used at the end of open
  ///  sub-paths.
  /// </summary>
  TBLStrokeCap = (
    /// <summary>
    ///  Butt cap [default].
    /// </summary>
    Butt,

    /// <summary>
    ///  Square cap.
    /// </summary>
    Square,

    /// <summary>
    ///  Round cap.
    /// </summary>
    Round,

    /// <summary>
    ///  Round cap reversed.
    /// </summary>
    RoundRev,

    /// <summary>
    ///  Triangle cap.
    /// </summary>
    Triangle,

    /// <summary>
    ///  Triangle cap reversed.
    /// </summary>
    TriangleRev);

type
  /// <summary>
  ///  Position of a stroke-cap.
  /// </summary>
  TBLStrokeCapPosition = (
    /// <summary>
    ///  Start of the path.
    /// </summary>
    StartOfPath,

    /// <summary>
    ///  End of the path.
    /// </summary>
    EndOfPath);

type
  /// <summary>
  ///  Stroke join type.
  /// </summary>
  TBLStrokeJoin = (
    /// <summary>
    ///  Miter-join possibly clipped at `MiterLimit` [default].
    /// </summary>
    MiterClip,

    /// <summary>
    ///  Miter-join or bevel-join depending on miterLimit condition.
    /// </summary>
    MiterBevel,

    /// <summary>
    ///  Miter-join or round-join depending on miterLimit condition.
    /// </summary>
    MiterRound,

    /// <summary>
    ///  Bevel-join.
    /// </summary>
    Bevel,

    /// <summary>
    ///  Round-join.
    /// </summary>
    Round);

type
  /// <summary>
  ///  Stroke transform order.
  /// </summary>
  TBLStrokeTransformOrder = (
    /// <summary>
    ///  Transform after stroke  => `Transform(Stroke(Input))` [default].
    /// </summary>
    After,

    /// <summary>
    ///  Transform before stroke => `Stroke(Transform(Input))`.
    /// </summary>
    Before);

type
  /// <summary>
  ///  Stroke options.
  /// </summary>
  TBLStrokeOptions = record
  {$REGION 'Internal Declarations'}
  private type
    TValues = packed record
    case Byte of
      0: (StartCap: UInt8;
          EndCap: UInt8;
          Join: UInt8;
          TransformOrder: UInt8;
          Reserved: array [0..3] of UInt8);
      1: (Caps: array [TBLStrokeCapPosition] of UInt8);
      2: (Hints: UInt64);
    end;
  private
    FValues: TValues;
    FWidth: Double;
    FMiterLimit: Double;
    FDashOffset: Double;
    FDashArray: TBLArray<Double>;
    function GetStartCap: TBLStrokeCap; inline;
    procedure SetStartCap(const AValue: TBLStrokeCap); inline;
    function GetEndCap: TBLStrokeCap; inline;
    procedure SetEndCap(const AValue: TBLStrokeCap); inline;
    function GetCap(const AIndex: TBLStrokeCapPosition): TBLStrokeCap; inline;
    procedure SetCap(const AIndex: TBLStrokeCapPosition;
      const AValue: TBLStrokeCap); inline;
    function GetJoin: TBLStrokeJoin; inline;
    procedure SetJoin(const AValue: TBLStrokeJoin); inline;
    function GetTransformOrder: TBLStrokeTransformOrder; inline;
    procedure SetTransformOrder(const AValue: TBLStrokeTransformOrder); inline;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Creates a default constructed stroke options object.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Initialize(out ADest: TBLStrokeOptions);

    /// <summary>
    ///  Destroys the stroke options object.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Finalize(var ADest: TBLStrokeOptions);

    /// <summary>
    ///  Copy constructor.
    ///
    ///  Creates a weak-copy of the `ASrc`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Assign(var ADest: TBLStrokeOptions; const [ref] ASrc: TBLStrokeOptions); inline;

    class operator Equal(const ALeft, ARight: TBLStrokeOptions): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLStrokeOptions): Boolean; inline; static;

    function Equals(const AOther: TBLStrokeOptions): Boolean; inline;

    procedure Reset; inline;
    procedure SetCaps(const ACap: TBLStrokeCap); inline;

    property StartCap: TBLStrokeCap read GetStartCap write SetStartCap;
    property EndCap: TBLStrokeCap read GetEndCap write SetEndCap;
    property Caps[const AIndex: TBLStrokeCapPosition]: TBLStrokeCap read GetCap write SetCap;
    property Join: TBLStrokeJoin read GetJoin write SetJoin;
    property TransformOrder: TBLStrokeTransformOrder read GetTransformOrder write SetTransformOrder;
    property Width: Double read FWidth write FWidth;
    property MiterLimit: Double read FMiterLimit write FMiterLimit;
    property DashOffset: Double read FDashOffset write FDashOffset;
    property DashArray: TBLArray<Double> read FDashArray write FDashArray;
  end;
  PBLStrokeOptions = ^TBLStrokeOptions;

{ ============================================================================
   [Geometries - Paths]
  ============================================================================ }

type
  /// <summary>
  ///  Path command.
  /// </summary>
  TBLPathCmd = (
    /// <summary>
    ///  Move-to command (starts a new figure).
    /// </summary>
    Move,

    /// <summary>
    ///  On-path command (interpreted as line-to or the end of a curve).
    /// </summary>
    OnPath,

    /// <summary>
    ///  Quad-to control point.
    /// </summary>
    Quad,

    /// <summary>
    ///  Conic-to control point
    /// </summary>
    Conic,

    /// <summary>
    ///  Cubic-to control point (always used as a pair of commands).
    /// </summary>
    Cubic,

    /// <summary>
    ///  Close path.
    /// </summary>
    Close,

    /// <summary>
    ///  Conic weight.
    /// </summary>
    /// <remarks>
    ///  This is not a point. This is a pair of values from which only the first
    ///  (X) is used to represent weight as used by conic curve. The other value
    ///  (Y) is always set to NaN by Blend2D, but can be arbitrary as it has
    ///  no meaning.
    /// </remarks>
    Weight,

    /// <summary>
    ///  Used by `TBLPath.SetVertexAt` to preserve the current command value.
    /// </summary>
    /// <remarks>
    ///  This command is never stored in the path.
    /// </remarks>
    Preserve = Integer($FFFFFFFF));

type
  /// <summary>
  ///  Path flags.
  /// </summary>
  TBLPathFlag = (
    /// <summary>
    ///  Path is empty (no commands or close commands only).
    /// </summary>
    Empty = 0,

    /// <summary>
    ///  Path contains multiple figures.
    /// </summary>
    Multiple = 1,

    /// <summary>
    ///  Path contains one or more quad curves.
    /// </summary>
    Quads = 2,

    /// <summary>
    ///  Path contains one or more conic curves.
    /// </summary>
    Conics = 3,

    /// <summary>
    ///  Path contains one or more cubic curves.
    /// </summary>
    Cubics = 4,

    /// <summary>
    ///  Path is invalid.
    /// </summary>
    Invalid = 30,

    /// <summary>
    ///  Flags are dirty (not reflecting the current status).
    /// </summary>
    Dirty = 31);

type
  /// <summary>
  ///  Path flags.
  /// </summary>
  TBLPathFlags = set of TBLPathFlag;

type
  /// <summary>
  ///  Adds functionality to TBLPathFlags.
  /// </summary>
  _TBLPathFlagsHelper = record helper for TBLPathFlags
  public const
    None = [];
  end;

type
  /// <summary>
  ///  Path reversal mode.
  /// </summary>
  TBLPathReverseMode = (
    /// <summary>
    ///  Reverse each figure and their order as well (default).
    /// </summary>
    Complete,

    /// <summary>
    ///  Reverse each figure separately (keeps their order).
    /// </summary>
    Separate);

type
  /// <summary>
  ///  Options used to describe how geometry is approximated.
  ///
  ///  This record cannot be simply zeroed and then passed to functions that
  ///  accept approximation options. Use `TBLApproximationOptions.Default` to
  ///  setup defaults and then alter values you want to change.
  ///
  ///  Example of using `TBLApproximationOptions`:
  ///
  ///  ```Delphi
  ///  // Initialize with defaults first.
  ///  var Approx := TBLApproximationOptions.Default;
  ///
  ///  // Override values you want to change.
  ///  Ppprox.SimplifyTolerance = 0.02;
  ///
  ///  // ... now safely use approximation options in your code ...
  ///  ```
  /// </summary>
  TBLApproximationOptions = packed record
  {$REGION 'Internal Declarations'}
  private
    FFlattenMode: UInt8;
    FOffsetMode: UInt8;
    {$HINTS OFF}
    FReservedFlags: array [0..5] of UInt8;
    {$HINTS ON}
    FFlattenTolerance: Double;
    FSimplifyTolerance: Double;
    FOffsetParameter: Double;
    function GetFlattenMode: TBLFlattenMode; inline;
    procedure SetFlattenMode(const AValue: TBLFlattenMode); inline;
    function GetOffsetMode: TBLOffsetMode; inline;
    procedure SetOffsetMode(const AValue: TBLOffsetMode); inline;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Specifies how curves are flattened.
    /// </summary>
    property FlattenMode: TBLFlattenMode read GetFlattenMode write SetFlattenMode;

    /// <summary>
    ///  Specifies how curves are offsetted (used by stroking).
    /// </summary>
    property OffsetMode: TBLOffsetMode read GetOffsetMode write SetOffsetMode;

    /// <summary>
    ///  Tolerance used to flatten curves.
    /// </summary>
    property FlattenTolerance: Double read FFlattenTolerance write FFlattenTolerance;

    /// <summary>
    ///  Tolerance used to approximate cubic curves with quadratic curves.
    /// </summary>
    property SimplifyTolerance: Double read FSimplifyTolerance write FSimplifyTolerance;

    /// <summary>
    ///  Curve offsetting parameter, exact meaning depends on `offsetMode`.
    /// </summary>
    property OffsetParameter: Double read FOffsetParameter write FOffsetParameter;
  end;
  PBLApproximationOptions = ^TBLApproximationOptions;

type
  /// <summary>
  ///  Adds functionality to 2D vector path.
  /// </summary>
  _TBLApproximationOptionsHelper = record helper for TBLApproximationOptions
  public const
    /// <summary>
    ///  Default approximation options used by Blend2D.
    /// </summary>
    Default: TBLApproximationOptions = (
      FFlattenMode: 0;
      FOffsetMode: 0;
      FFlattenTolerance: 0.2;
      FSimplifyTolerance: 0.05;
      FOffsetParameter: 0.414213562);
  end;

type
  /// <summary>
  ///  2D vector path view provides pointers to vertex and command data along
  ///  with their size.
  /// </summary>
  TBLPathView = record
  {$REGION 'Internal Declarations'}
  private
    FCommandData: PByte;
    FVertexData: PBLPoint;
    FCount: NativeInt;
  {$ENDREGION 'Internal Declarations'}
  public
    procedure Reset; overload; inline;
    procedure Reset(const ACommandDataIn: PByte; const AVertexDataIn: PBLPoint;
      const ACountIn: NativeInt); overload; inline;

    property CommandData: PByte read FCommandData;
    property VertexData: PBLPoint read FVertexData;
    property Count: NativeInt read FCount;
  end;

type
  /// <summary>
  ///  2D vector path.
  /// </summary>
  TBLPath = record
  {$REGION 'Internal Declarations'}
  private
    FBase: TBLObjectCore;
    function GetIsEmpty: Boolean; inline;
    function GetCount: NativeInt; inline;
    function GetCapacity: NativeInt; inline;
    function GetVertexData: PBLPoint; inline;
    function GetVertexDataEnd: PBLPoint; inline;
    function GetCommandData: PByte; inline;
    function GetCommandDataEnd: PByte; inline;
    function GetInfoFlags: TBLPathFlags; inline;
    function GetControlBox: TBLBox; inline;
    function GetBoundingBox: TBLBox; inline;
    function GetFigureRange(const AIndex: Integer): TBLRange; inline;
    function GetLastVertex: TBLPoint; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Creates a default constructed path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Initialize(out ADest: TBLPath);

    /// <summary>
    ///  Destroys the path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Finalize(var ADest: TBLPath);

    /// <summary>
    ///  Copy constructor.
    ///
    ///  Creates a weak-copy of the `ASrc` path by increasing it's internal
    ///  reference counter. This path and `ASrc` would point to the same data
    ///  and would be otherwise identical. Any change to `ASrc` would also
    ///  affect this path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Assign(var ADest: TBLPath; const [ref] ASrc: TBLPath); inline;

    /// <summary>
    ///  Used to compare against `nil` (empty path).
    /// </summary>
    class operator Equal(const ALeft: TBLPath; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two paths are equal (have the same contents).
    /// </summary>
    /// <seealso cref="Equals"/>
    class operator Equal(const ALeft, ARight: TBLPath): Boolean; inline; static;

    /// <summary>
    ///  Used to compare against `nil` (empty path).
    /// </summary>
    class operator NotEqual(const ALeft: TBLPath; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two paths are not equal (do not have the same contents).
    /// </summary>
    /// <seealso cref="Equals"/>
    class operator NotEqual(const ALeft, ARight: TBLPath): Boolean; inline; static;

    procedure Reset; inline;
    procedure Swap(var AOther: TBLPath); inline;

    /// <summary>
    ///  Returns a read-only path data as `TBLPathView`.
    /// </summary>
    function View: TBLPathView; inline;

    /// <summary>
    ///  Clears the content of the path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Clear; inline;

    /// <summary>
    ///  Shrinks the capacity of the path to fit the current usage.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Shrink; inline;

    /// <summary>
    ///  Reserves the capacity of the path for at least `AMinCapacity` vertices
    ///  and commands.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Reserve(const AMinCapacity: NativeInt); inline;

    procedure ModifyOp(const AOp: TBLModifyOp; const ACount: NativeInt;
      out ACmdDataOut: PByte; out AVertexDataOut: PBLPoint); inline;

    procedure AssignDeep(const AOther: TBLPath); inline;

    /// <summary>
    ///  Sets vertex at `AIndex` to `ACmd` and `APt`.
    ///
    ///  Pass `TBLPathCmd.Preserve` in `ACmd` to preserve the current command.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetVertexAt(const AIndex: NativeInt; const ACmd: TBLPathCmd;
      const APt: TBLPoint); overload; inline;

    /// <summary>
    ///  Sets vertex at `AIndex` to `ACmd` and `[AX, AY]`.
    ///
    ///  Pass `TBLPathCmd.Preserve` in `ACmd` to preserve the current command.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetVertexAt(const AIndex: NativeInt; const ACmd: TBLPathCmd;
      const AX, AY: Double); overload; inline;

    /// <summary>
    ///  Moves to `AP0`.
    ///
    ///  Appends `TBLPathCmd.Move[AP0]` command to the path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure MoveTo(const AP0: TBLPoint); overload; inline;

    /// <summary>
    ///  Moves to `[AX0, AY0]`.
    ///
    ///  Appends `TBLPathCmd.Move[AX0, AY0]` command to the path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure MoveTo(const AX0, AY0: Double); overload; inline;

    /// <summary>
    ///  Adds line to `AP1`.
    ///
    ///  Appends `TBLPathCmd.OnPath[AP1]` command to the path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure LineTo(const AP1: TBLPoint); overload; inline;

    /// <summary>
    ///  Adds line to `[AX1, AY1]`.
    ///
    ///  Appends `TBLPathCmd.OnPath[AX1, AY1]` command to the path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure LineTo(const AX1, AY1: Double); overload; inline;

    /// <summary>
    ///  Adds a polyline (LineTo) of the given `APoly` array of size `ACount`.
    ///
    ///  Appends multiple `TBLPathCmd.OnPath[AX[I], AY[I]]` commands to the path
    ///  depending on `ACount` parameter.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure PolyTo(const APoly: PBLPoint; const ACount: NativeInt); overload; inline;

    /// <summary>
    ///  Adds a polyline (LineTo) of the given `APoly` array.
    ///
    ///  Appends multiple `TBLPathCmd.OnPath[AX[I], AY[I]]` commands to the path
    ///  depending on the length of the `APoly` array.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure PolyTo(const APoly: TArray<TBLPoint>); overload; inline;

    /// <summary>
    ///  Adds a quadratic curve to `AP1` and `AP2`.
    ///
    ///  Appends the following commands to the path:
    ///    - `TBLPathCmd.Quad[AP1]`
    ///    - `TBLPathCmd.OnPath[AP2]`
    ///
    ///  Matches <see href="https://www.w3.org/TR/SVG/paths.html#PathDataQuadraticBezierCommands">SVG 'Q' path command</see>.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure QuadTo(const AP1, AP2: TBLPoint); overload; inline;

    /// <summary>
    ///  Adds a quadratic curve to `[AX1, AY1]` and `[AX2, AY2]`.
    ///
    ///  Appends the following commands to the path:
    ///    - `TBLPathCmd.Quad[AX1, AY1]`
    ///    - `TBLPathCmd.OnPath[AX2, AY2]`
    ///
    ///  Matches <see href="https://www.w3.org/TR/SVG/paths.html#PathDataQuadraticBezierCommands">SVG 'Q' path command</see>.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure QuadTo(const AX1, AY1, AX2, AY2: Double); overload; inline;

    procedure ConicTo(const AP1, AP2: TBLPoint; const AWeight: Double); overload; inline;
    procedure ConicTo(const AX1, AY1, AX2, AY2, AWeight: Double); overload; inline;

    /// <summary>
    ///  Adds a cubic curve to `AP1`, `AP2`, and `AP3`.
    ///
    ///  Appends the following commands to the path:
    ///    - `TBLPathCmd.Cubic[AP1]`
    ///    - `TBLPathCmd.Cubic[AP2]`
    ///    - `TBLPathCmd.On[AP3]`
    ///
    ///  Matches <see href="https://www.w3.org/TR/SVG/paths.html#PathDataCubicBezierCommands">SVG 'C' path command</see>.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure CubicTo(const AP1, AP2, AP3: TBLPoint); overload; inline;

    /// <summary>
    ///  Adds a cubic curve to `[AX1, AY1]`, `[AX2, AY2]`, and `[AX3, AY3]`.
    ///
    ///  Appends the following commands to the path:
    ///    - `TBLPathCmd.Cubic[AX1, AY1]`
    ///    - `TBLPathCmd.Cubic[AX2, AY2]`
    ///    - `TBLPathCmd.On[AX3, AY3]`
    ///
    ///  Matches <see href="https://www.w3.org/TR/SVG/paths.html#PathDataCubicBezierCommands">SVG 'C' path command</see>.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure CubicTo(const AX1, AY1, AX2, AY2, AX3, AY3: Double); overload; inline;

    /// <summary>
    ///  Adds a smooth quadratic curve to `AP2`, calculating `AP1` from last
    ///  points.
    ///
    ///  Appends the following commands to the path:
    ///    - `TBLPathCmd.Quad[Calculated]`
    ///    - `TBLPathCmd.OnPath[AP2]`
    ///
    ///  Matches <see href="https://www.w3.org/TR/SVG/paths.html#PathDataQuadraticBezierCommands">SVG 'T' path command</see>.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SmoothQuadTo(const AP2: TBLPoint); overload; inline;

    /// <summary>
    ///  Adds a smooth quadratic curve to `[AX2, AY2]`, calculating `[AX1, AY1]`
    ///  from last points.
    ///
    ///  Appends the following commands to the path:
    ///    - `TBLPathCmd.Quad[Calculated]`
    ///    - `TBLPathCmd.OnPath[AX2, AY2]`
    ///
    ///  Matches <see href="https://www.w3.org/TR/SVG/paths.html#PathDataQuadraticBezierCommands">SVG 'T' path command</see>.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SmoothQuadTo(const AX2, AY2: Double); overload; inline;

    /// <summary>
    ///  Adds a smooth cubic curve to `AP2` and `AP3`, calculating `AP1` from
    ///  last points.
    ///
    ///  Appends the following commands to the path:
    ///    - `TBLPathCmd.Cubic[Calculated]`
    ///    - `TBLPathCmd.Cubic[AP2]`
    ///    - `TBLPathCmd.OnPath[AP3]`
    ///
    ///  Matches <see href="https://www.w3.org/TR/SVG/paths.html#PathDataCubicBezierCommands">SVG 'S' path command</see>.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SmoothCubicTo(const AP2, AP3: TBLPoint); overload; inline;

    /// <summary>
    ///  Adds a smooth cubic curve to `[AX2, AY2]` and `[AX3, AY3]`, calculating
    ///  `[AX1, AY1]` from last points.
    ///
    ///  Appends the following commands to the path:
    ///    - `TBLPathCmd.Cubic[Calculated]`
    ///    - `TBLPathCmd.Cubic[AX2, AY2]`
    ///    - `TBLPathCmd.OnPath[AX3, AY3]`
    ///
    ///  Matches <see href="https://www.w3.org/TR/SVG/paths.html#PathDataCubicBezierCommands">SVG 'S' path command</see>.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SmoothCubicTo(const AX2, AY2, AX3, AY3: Double); overload; inline;

    /// <summary>
    ///  Adds an arc to the path.
    ///
    ///  The center of the arc is specified by `AC` and radius by `AR`. Both
    ///  `AStart` and `ASweep` angles are in radians.
    ///  If the last vertex doesn't match the start of the arc then a `LineTo`
    ///  would be emitted before adding the arc.
    ///  Pass `True` in `AForceMoveTo` to always emit `MoveTo` at the beginning
    ///  of the arc, which starts a new figure.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ArcTo(const AC, AR: TBLPoint; const AStart, ASweep: Double;
      const AForceMoveTo: Boolean = False); overload; inline;

    /// <summary>
    ///  Adds an arc to the path.
    ///
    ///  The center of the arc is specified by `[ACX, ACY]` and radius by
    ///  `[ARX, ARY]`. Both `AStart` and `ASweep` angles are in radians.
    ///  If the last vertex doesn't match the start of the arc then a `LineTo`
    ///  would be emitted before adding the arc.
    ///  Pass `True` in `AForceMoveTo` to always emit `MoveTo` at the beginning
    ///  of the arc, which starts a new figure.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ArcTo(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
      const AForceMoveTo: Boolean = False); overload; inline;

    /// <summary>
    ///  Adds an arc quadrant (90deg) to the path. The first point `AP1`
    ///  specifies the quadrant corner and the last point `AP2` specifies the
    ///  end point.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ArcQuadrantTo(const AP1, AP2: TBLPoint); overload; inline;

    /// <summary>
    ///  Adds an arc quadrant (90deg) to the path. The first point `[AX1, AY1]`
    ///  specifies the quadrant corner and the last point `[AX2, AY2]` specifies
    ///  the end point.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ArcQuadrantTo(const AX1, AY1, AX2, AY2: Double); overload; inline;

    /// <summary>
    ///  Adds an elliptic arc to the path that follows the SVG specification.
    ///
    ///  Matches <see href="https://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands">SVG 'A' path command</see>.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure EllipticArcTo(const ARP: TBLPoint; const AXAxisRotation: Double;
      const ALargeArcFlag, ASweepFlag: Boolean; const AP1: TBLPoint); overload; inline;

    /// <summary>
    ///  Adds an elliptic arc to the path that follows the SVG specification.
    ///
    ///  Matches <see href="https://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands">SVG 'A' path command</see>.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure EllipticArcTo(const ARX, ARY, AXAxisRotation: Double;
      const ALargeArcFlag, ASweepFlag: Boolean; const AX1, AY1: Double); overload; inline;

    /// <summary>
    ///  Closes the current figure.
    ///
    ///  Appends `TBLPathCmd.Close` to the path.
    ///
    ///  Matches <see href="https://www.w3.org/TR/SVG/paths.html#PathDataClosePathCommand">SVG 'Z' path command</see>.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Close; inline;

    /// <summary>
    ///  Adds multiple LineTo segments to the path.
    ///  Provides high-performance path building in case that the user knows
    ///  the segments that will be added to the path in advance.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddLineToSegments(const APoints: TArray<TBLPoint>); overload; inline;

    /// <summary>
    ///  Adds multiple LineTo segments to the path.
    ///  Provides high-performance path building in case that the user knows
    ///  the segments that will be added to the path in advance.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddLineToSegments(const APoints: PBLPoint;
      const ACount: NativeInt); overload; inline;

    /// <summary>
    ///  Adds multiple QuadTo segments to the path.
    ///  Provides high-performance path building in case that the user knows
    ///  the segments that will be added to the path in advance.
    /// </summary>
    /// <remarks>
    ///  The APoints array contains pairs of points (P0, P1). Thus the length
    ///  of the array must be even.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddQuadToSegments(const APoints: TArray<TBLPoint>); overload; inline;

    /// <summary>
    ///  Adds multiple QuadTo segments to the path.
    ///  Provides high-performance path building in case that the user knows
    ///  the segments that will be added to the path in advance.
    /// </summary>
    /// <remarks>
    ///  The APoints array contains pairs of points (P0, P1).
    ///  ASegmentCount contains the number of segments (pairs), *not* the number
    ///  of points.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddQuadToSegments(const APoints: PBLPoint;
      const ASegmentCount: NativeInt); overload; inline;

    /// <summary>
    ///  Adds multiple CubicTo segments to the path.
    ///  Provides high-performance path building in case that the user knows
    ///  the segments that will be added to the path in advance.
    /// </summary>
    /// <remarks>
    ///  The APoints array contains triples of points (P0, P1, P2). Thus the
    ///  length of the array must be a multiple of 3.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddCubicToSegments(const APoints: TArray<TBLPoint>); overload; inline;

    /// <summary>
    ///  Adds multiple CubicTo segments to the path.
    ///  Provides high-performance path building in case that the user knows
    ///  the segments that will be added to the path in advance.
    /// </summary>
    /// <remarks>
    ///  The APoints array contains triples of points (P0, P1, P2).
    ///  ASegmentCount contains the number of segments (triples), *not* the
    ///  number of points.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddCubicToSegments(const APoints: PBLPoint;
      const ASegmentCount: NativeInt); overload; inline;

    /// <summary>
    ///  Adds a closed rectangle to the path specified by `ABox`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddBox(const ABox: TBLBoxI;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a closed rectangle to the path specified by `ABox`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddBox(const ABox: TBLBox;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a closed rectangle to the path specified by `[AX0, AY0, AX1, AY1]`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddBox(const AX0, AY0, AX1, AY1: Double;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a closed rectangle to the path specified by `ARect`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddRect(const ARect: TBLRectI;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a closed rectangle to the path specified by `ARect`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddRect(const ARect: TBLRect;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a closed rectangle to the path specified by `[AX, AY, AW, AH]`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddRect(const AX, AY, AW, AH: Double;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a geometry to the path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddGeometry(const AGeometryType: TBLGeometryType;
      const AGeometryData: Pointer;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a geometry to the path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddGeometry(const AGeometryType: TBLGeometryType;
      const AGeometryData: Pointer; const AMatrix: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a closed circle to the path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddCircle(const ACircle: TBLCircle;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a closed circle to the path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddCircle(const ACircle: TBLCircle; const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a closed ellipse to the path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddEllipse(const AEllipse: TBLEllipse;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a closed ellipse to the path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddEllipse(const AEllipse: TBLEllipse; const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a closed rounded rectangle to the path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddRoundRect(const ARR: TBLRoundRect;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a closed rounded rectangle to the path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddRoundRect(const ARR: TBLRoundRect; const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an unclosed arc to the path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddArc(const AArc: TBLArc;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an unclosed arc to the path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddArc(const AArc: TBLArc; const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a closed chord to the path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddChord(const AChord: TBLArc;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a closed chord to the path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddChord(const AChord: TBLArc; const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a closed pie to the path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPie(const APie: TBLArc;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a closed pie to the path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPie(const APie: TBLArc; const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an unclosed line to the path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddLine(const ALine: TBLLine;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an unclosed line to the path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddLine(const ALine: TBLLine; const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a closed triangle.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddTriangle(const ATriangle: TBLTriangle;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a closed triangle.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddTriangle(const ATriangle: TBLTriangle; const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a polyline.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPolyline(const APoly: TBLArrayView<TBLPointI>;
      const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a polyline.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPolyline(const APoly: TBLArrayView<TBLPointI>;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a polyline.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPolyline(const APoly: TArray<TBLPointI>;
      const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a polyline.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPolyline(const APoly: TArray<TBLPointI>;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a polyline.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPolyline(const APoly: PBLPointI; const ACount: NativeInt;
      const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a polyline.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPolyline(const APoly: PBLPointI; const ACount: NativeInt;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a polyline.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPolyline(const APoly: TBLArrayView<TBLPoint>;
      const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a polyline.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPolyline(const APoly: TBLArrayView<TBLPoint>;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a polyline.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPolyline(const APoly: TArray<TBLPoint>;
      const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a polyline.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPolyline(const APoly: TArray<TBLPoint>;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a polyline.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPolyline(const APoly: PBLPoint; const ACount: NativeInt;
      const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a polyline.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPolyline(const APoly: PBLPoint; const ACount: NativeInt;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a polygon.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPolygon(const APoly: TBLArrayView<TBLPointI>;
      const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a polygon.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPolygon(const APoly: TBLArrayView<TBLPointI>;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a polygon.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPolygon(const APoly: TArray<TBLPointI>;
      const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a polygon.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPolygon(const APoly: TArray<TBLPointI>;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a polygon.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPolygon(const APoly: PBLPointI; const ACount: NativeInt;
      const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a polygon.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPolygon(const APoly: PBLPointI; const ACount: NativeInt;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a polygon.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPolygon(const APoly: TBLArrayView<TBLPoint>;
      const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a polygon.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPolygon(const APoly: TBLArrayView<TBLPoint>;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a polygon.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPolygon(const APoly: TArray<TBLPoint>;
      const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a polygon.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPolygon(const APoly: TArray<TBLPoint>;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a polygon.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPolygon(const APoly: PBLPoint; const ACount: NativeInt;
      const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds a polygon.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPolygon(const APoly: PBLPoint; const ACount: NativeInt;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an array of closed boxes.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddBoxArray(const AArray: TBLArrayView<TBLBoxI>;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an array of closed boxes.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddBoxArray(const AArray: TBLArrayView<TBLBoxI>;
      const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an array of closed boxes.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddBoxArray(const AArray: TArray<TBLBoxI>;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an array of closed boxes.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddBoxArray(const AArray: TArray<TBLBoxI>;
      const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an array of closed boxes.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddBoxArray(const AArray: PBLBoxI; const ACount: NativeInt;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an array of closed boxes.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddBoxArray(const AArray: PBLBoxI; const ACount: NativeInt;
      const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an array of closed boxes.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddBoxArray(const AArray: TBLArrayView<TBLBox>;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an array of closed boxes.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddBoxArray(const AArray: TBLArrayView<TBLBox>;
      const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an array of closed boxes.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddBoxArray(const AArray: TArray<TBLBox>;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an array of closed boxes.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddBoxArray(const AArray: TArray<TBLBox>;
      const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an array of closed boxes.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddBoxArray(const AArray: PBLBox; const ACount: NativeInt;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an array of closed boxes.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddBoxArray(const AArray: PBLBox; const ACount: NativeInt;
      const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an array of closed rectangles.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddRectArray(const AArray: TBLArrayView<TBLRectI>;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an array of closed rectangles.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddRectArray(const AArray: TBLArrayView<TBLRectI>;
      const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an array of closed rectangles.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddRectArray(const AArray: TArray<TBLRectI>;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an array of closed rectangles.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddRectArray(const AArray: TArray<TBLRectI>;
      const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an array of closed rectangles.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddRectArray(const AArray: PBLRectI; const ACount: NativeInt;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an array of closed rectangles.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddRectArray(const AArray: PBLRectI; const ACount: NativeInt;
      const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an array of closed rectangles.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddRectArray(const AArray: TBLArrayView<TBLRect>;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an array of closed rectangles.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddRectArray(const AArray: TBLArrayView<TBLRect>;
      const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an array of closed rectangles.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddRectArray(const AArray: TArray<TBLRect>;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an array of closed rectangles.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddRectArray(const AArray: TArray<TBLRect>;
      const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an array of closed rectangles.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddRectArray(const AArray: PBLRect; const ACount: NativeInt;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds an array of closed rectangles.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddRectArray(const AArray: PBLRect; const ACount: NativeInt;
      const ATransform: TBLMatrix2D;
      const ADir: TBLGeometryDirection = TBLGeometryDirection.CW); overload; inline;

    /// <summary>
    ///  Adds other `APath` to this path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPath(const APath: TBLPath); overload; inline;

    /// <summary>
    ///  Adds other `APath` sliced by the given `ARange` to this path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPath(const APath: TBLPath; const ARange: TBLRange); overload; inline;

    /// <summary>
    ///  Adds other `APath` translated by `AP` to this path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPath(const APath: TBLPath; const AP: TBLPoint); overload; inline;

    /// <summary>
    ///  Adds other `APath` translated by `AP` and sliced by the given `ARange`
    ///  to this path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPath(const APath: TBLPath; const ARange: TBLRange;
      const AP: TBLPoint); overload; inline;

    /// <summary>
    ///  Adds other `APath` transformed by `ATransform` to this path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPath(const APath: TBLPath; const ATransform: TBLMatrix2D); overload; inline;

    /// <summary>
    ///  Adds other `APath` transformed by `ATransform` and sliced by the given
    ///  `ARange` to this path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddPath(const APath: TBLPath; const ARange: TBLRange;
      const ATransform: TBLMatrix2D); overload; inline;

    /// <summary>
    ///  Adds other `APath`, but reversed.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddReversedPath(const APath: TBLPath;
      const AReverseMode: TBLPathReverseMode); overload; inline;

    /// <summary>
    ///  Adds other `APath`, but reversed.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddReversedPath(const APath: TBLPath; const ARange: TBLRange;
      const AReverseMode: TBLPathReverseMode); overload; inline;

    /// <summary>
    ///  Adds a stroke of `APath` to this path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddStrokedPath(const APath: TBLPath;
      const AStrokeOptions: TBLStrokeOptions;
      const AApproximationOptions: TBLApproximationOptions); overload; inline;

    /// <summary>
    ///  Adds a stroke of `APath` to this path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddStrokedPath(const APath: TBLPath; const ARange: TBLRange;
      const AStrokeOptions: TBLStrokeOptions;
      const AApproximationOptions: TBLApproximationOptions); overload; inline;

    procedure RemoveRange(const ARange: TBLRange); inline;

    /// <summary>
    ///  Translates the whole path by `AP`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Translate(const AP: TBLPoint); overload; inline;

    /// <summary>
    ///  Translates a part of the path specified by the given `ARange` by `AP`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Translate(const ARange: TBLRange;
      const AP: TBLPoint); overload; inline;

    /// <summary>
    ///  Transforms the whole path by matrix `AM`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Transform(const AM: TBLMatrix2D); overload; inline;

    /// <summary>
    ///  Transforms a part of the path specified by the given `ARange` by
    ///  matrix `AM`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Transform(const ARange: TBLRange;
      const AM: TBLMatrix2D); overload; inline;

    /// <summary>
    ///  Fits the whole path into the given `ARect`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FitTo(const ARect: TBLRect); overload; inline;

    /// <summary>
    ///  Fits a part of the path specified by the given `ARange` into the given
    ///  `ARect`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FitTo(const ARange: TBLRange;
      const ARect: TBLRect); overload; inline;

    /// <summary>
    ///  Tests whether this path and the `AOther` path are equal.
    ///
    ///  The equality check is deep. The data of both paths is examined and
    ///  binary compared (thus a slight difference like -0 and +0 would make the
    ///  equality check to fail).
    /// </summary>
    function Equals(const AOther: TBLPath): Boolean; inline;

    function GetClosestVertex(const AP: TBLPoint;
      const AMaxDistance: Double): NativeInt; overload; inline;

    function GetClosestVertex(const AP: TBLPoint; const AMaxDistance: Double;
      out ADistanceOut: Double): NativeInt; overload; inline;

    /// <summary>
    ///  Hit tests the given point `AP` by respecting the given `AFillRule`.
    /// </summary>
    function HitTest(const AP: TBLPoint; const AFillRule: TBLFillRule): TBLHitTest; inline;

    /// <summary>
    ///  Whether the path is empty, which means its size equals to zero.
    /// </summary>
    property IsEmpty: Boolean read GetIsEmpty;

    /// <summary>
    ///  Path size (number of vertices used).
    /// </summary>
    property Count: NativeInt read GetCount;

    /// <summary>
    ///  Path capacity (number of allocated vertices).
    /// </summary>
    property Capacity: NativeInt read GetCapacity;

    /// <summary>
    ///  Path's vertex data (read-only).
    /// </summary>
    property VertexData: PBLPoint read GetVertexData;

    /// <summary>
    ///  The end of path's vertex data (read-only).
    /// </summary>
    property VertexDataEnd: PBLPoint read GetVertexDataEnd;

    /// <summary>
    ///  Path's command data (read-only).
    /// </summary>
    property CommandData: PByte read GetCommandData;

    /// <summary>
    ///  The end of path's command data (read-only).
    /// </summary>
    property CommandDataEnd: PByte read GetCommandDataEnd;

    /// <summary>
    ///  Update a path information if necessary.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property InfoFlags: TBLPathFlags read GetInfoFlags;

    /// <summary>
    ///  Bounding box of all vertices and control points to.
    ///
    ///  Control box is simply bounds of all vertices the path has without
    ///  further processing. It contains both on-path and off-path points.
    ///  Consider using `BoundingBox` if you need a visual bounding box.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="BoundingBox"/>
    property ControlBox: TBLBox read GetControlBox;

    /// <summary>
    ///  Bounding box of all on-path vertices and curve extrema.
    ///
    ///  The bounding box could be smaller than a bounding box obtained by
    ///  `ControlBox` as it's calculated by merging only start/end points and
    ///  curves at their extrema (not control points). The resulting bounding
    ///  box represents a visual bounds of the path.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="ControlBox"/>
    property BoundingBox: TBLBox read GetBoundingBox;

    /// <summary>
    ///  The ranges describing a figure at the given `AIndex`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property FigureRanges[const AIndex: Integer]: TBLRange read GetFigureRange;

    /// <summary>
    ///  The last vertex of the path. If the very last command of the path is
    ///  `TBLPathCmd.Close` then the path will be iterated in reverse order to
    ///  match the initial vertex of the last figure.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property LastVertex: TBLPoint read GetLastVertex;
  end;

type
  /// <summary>
  ///  Optional callback that can be used to consume a path data.
  /// </summary>
  TBLPathSinkFunc = function (const APath: TBLPath; const AInfo,
    AUserData: Pointer): TBLResult; cdecl;
{$ENDREGION 'Geometries'}

{$REGION 'Colors'}

{ ============================================================================
   [Styling - Colors]
  ============================================================================ }

type
  /// <summary>
  ///  32-bit RGBA color (8-bit per component) stored as `$AARRGGBB`.
  ///  This record is compatible with Delphi's `TAlphaColor` and
  ///  `TAlphaColorRec` and can be typecast to and from these.
  /// </summary>
  TBLRgba32 = record
  {$REGION 'Internal Declarations'}
  private
    function GetR: Byte; inline;
    procedure SetR(const AValue: Byte); inline;
    function GetG: Byte; inline;
    procedure SetG(const AValue: Byte); inline;
    function GetB: Byte; inline;
    procedure SetB(const AValue: Byte); inline;
    function GetA: Byte; inline;
    procedure SetA(const AValue: Byte); inline;
    function GetIsOpaque: Boolean; inline;
    function GetIsTransparent: Boolean; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Packed 32-bit RGBA value.
    /// </summary>
    Value: UInt32;
  public
    class function Create: TBLRgba32; overload; inline; static;
    constructor Create(const ARgba32: UInt32); overload;
    constructor Create(const AR, AG, AB: Byte; const AA: Byte = $FF); overload;
    constructor Create(const AColor: TAlphaColorRec); overload;

    /// <summary>
    ///  Implicitly converts from a packed 32-bit RGBA value (or `TAlphaColor`)
    ///  to a TBLRgba32.
    /// </summary>
    class operator Implicit(const AValue: UInt32): TBLRgba32; inline; static;

    /// <summary>
    ///  Implicitly converts from a `TAlphaColorRec` to a TBLRgba32.
    /// </summary>
    class operator Implicit(const AValue: TAlphaColorRec): TBLRgba32; inline; static;

    /// <summary>
    ///  Implicitly converts from a TBLRgba32 to a packed 32-bit RGBA value.
    /// </summary>
    class operator Implicit(const AValue: TBLRgba32): UInt32; inline; static;

    class operator Equal(const ALeft, ARight: TBLRgba32): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLRgba32): Boolean; inline; static;

    procedure Reset; overload; inline;
    procedure Reset(const ARgba32: UInt32); overload; inline;
    procedure Reset(const AR, AG, AB: Byte; const AA: Byte = $FF); overload; inline;
    procedure Reset(const AColor: TAlphaColorRec); overload; inline;
    function Equals(const AOther: TBLRgba32): Boolean; inline;

    property R: Byte read GetR write SetR;
    property G: Byte read GetG write SetG;
    property B: Byte read GetB write SetB;
    property A: Byte read GetA write SetA;

    /// <summary>
    ///  Whether the color is fully opaque (alpha equals $FF).
    /// </summary>
    property IsOpaque: Boolean read GetIsOpaque;

    /// <summary>
    ///  Whether the color is fully transparent (alpha equals $00).
    /// </summary>
    property IsTransparent: Boolean read GetIsTransparent;
  end;
  PBLRgba32 = ^TBLRgba32;

type
  /// <summary>
  ///  64-bit RGBA color (8-bit per component) stored as `$AAAARRRRGGGGBBBB`.
  /// </summary>
  TBLRgba64 = record
  {$REGION 'Internal Declarations'}
  private
    function GetR: Word; inline;
    procedure SetR(const AValue: Word); inline;
    function GetG: Word; inline;
    procedure SetG(const AValue: Word); inline;
    function GetB: Word; inline;
    procedure SetB(const AValue: Word); inline;
    function GetA: Word; inline;
    procedure SetA(const AValue: Word); inline;
    function GetIsOpaque: Boolean; inline;
    function GetIsTransparent: Boolean; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Packed 64-bit RGBA value.
    /// </summary>
    Value: UInt64;
  public
    class function Create: TBLRgba64; overload; inline; static;
    constructor Create(const ARgba64: UInt64); overload;
    constructor Create(const ARgba32: TBLRgba32); overload;
    constructor Create(const AR, AG, AB: Word; const AA: Word = $FFFF); overload;

    /// <summary>
    ///  Implicitly converts from a packed 64-bit RGBA value to a TBLRgba64.
    /// </summary>
    class operator Implicit(const AValue: UInt64): TBLRgba64; inline; static;

    /// <summary>
    ///  Implicitly converts from a TBLRgba64 to a packed 64-bit RGBA value.
    /// </summary>
    class operator Implicit(const AValue: TBLRgba64): UInt64; inline; static;

    class operator Equal(const ALeft, ARight: TBLRgba64): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLRgba64): Boolean; inline; static;

    procedure Reset; overload; inline;
    procedure Reset(const ARgba32: UInt32); overload; inline;
    procedure Reset(const ARgba64: UInt64); overload; inline;
    procedure Reset(const ARgba32: TBLRgba32); overload; inline;
    procedure Reset(const AR, AG, AB: Word; const AA: Word = $FFFF); overload; inline;
    function Equals(const AOther: TBLRgba64): Boolean; inline;

    property R: Word read GetR write SetR;
    property G: Word read GetG write SetG;
    property B: Word read GetB write SetB;
    property A: Word read GetA write SetA;

    /// <summary>
    ///  Whether the color is fully opaque (alpha equals $FFFF).
    /// </summary>
    property IsOpaque: Boolean read GetIsOpaque;

    /// <summary>
    ///  Whether the color is fully transparent (alpha equals $0000).
    /// </summary>
    property IsTransparent: Boolean read GetIsTransparent;
  end;
  PBLRgba64 = ^TBLRgba64;

type
  /// <summary>
  ///  Adds functionality to TBLRgba32
  /// </summary>
  _TBLRgba32Helper = record helper for TBLRgba32
  public
    constructor Create(const ARgba64: TBLRgba64); overload;
    procedure Reset(const ARgba64: TBLRgba64); overload; inline;
  end;

type
  /// <summary>
  ///  128-bit RGBA color stored as 4 32-bit floating point values in [RGBA] order.
  ///  This record is compatible with Delphi's `TAlphaColorF` and can be
  ///  typecase to and from it.
  /// </summary>
  TBLRgba = record
  {$REGION 'Internal Declarations'}
  private
    function GetIsOpaque: Boolean; inline;
    function GetIsTransparent: Boolean; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Red component.
    /// </summary>
    R: Single;

    /// <summary>
    ///  Green component.
    /// </summary>
    G: Single;

    /// <summary>
    ///  Blur component.
    /// </summary>
    B: Single;

    /// <summary>
    ///  Alpha component.
    /// </summary>
    A: Single;
  public
    class function Create: TBLRgba; overload; inline; static;
    constructor Create(const AR, AG, AB: Single; const AA: Single = 1); overload;
    constructor Create(const ARgba32: TBLRgba32); overload;
    constructor Create(const ARgba64: TBLRgba64); overload;
    constructor Create(const AColor: TAlphaColorF); overload;

    class operator Equal(const ALeft, ARight: TBLRgba): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLRgba): Boolean; inline; static;

    procedure Reset; overload; inline;
    procedure Reset(const ARgba32: TBLRgba32); overload; inline;
    procedure Reset(const ARgba64: TBLRgba64); overload; inline;
    procedure Reset(const AR, AG, AB: Single; const AA: Single = 1); overload; inline;
    procedure Reset(const AColor: TAlphaColorF); overload; inline;

    function Equals(const AOther: TBLRgba): Boolean; overload; inline;
    function Equals(const AOther: TBLRgba32): Boolean; overload; inline;
    function Equals(const AOther: TBLRgba64): Boolean; overload; inline;
    function Equals(const AR, AG, AB: Single; const AA: Single = 1): Boolean; overload; inline;

    function ToRgba32: TBLRgba32; inline;
    function ToRgba64: TBLRgba64; inline;

    /// <summary>
    ///  Whether the color is fully opaque (alpha equals 1.0).
    /// </summary>
    property IsOpaque: Boolean read GetIsOpaque;

    /// <summary>
    ///  Whether the color is fully transparent (alpha equals 0.0).
    /// </summary>
    property IsTransparent: Boolean read GetIsTransparent;
  end;
  PBLRgba = ^TBLRgba;

function BLRgba32: TBLRgba32; overload; inline;
function BLRgba32(const ARgba32: UInt32): TBLRgba32; overload; inline;
function BLRgba32(const ARgba64: TBLRgba64): TBLRgba32; overload; inline;
function BLRgba32(const AR, AG, AB: Byte; const AA: Byte = $FF): TBLRgba32; overload; inline;
function BLRgba32(const AColor: TAlphaColorRec): TBLRgba32; overload; inline;

function BLRgba64: TBLRgba64; overload; inline;
function BLRgba64(const ARgba32: UInt32): TBLRgba64; overload; inline;
function BLRgba64(const ARgba64: UInt64): TBLRgba64; overload; inline;
function BLRgba64(const ARgba32: TBLRgba32): TBLRgba64; overload; inline;
function BLRgba64(const AR, AG, AB: Word; const AA: Word = $FFFF): TBLRgba64; overload; inline;

function BLRgba: TBLRgba; overload; inline;
function BLRgba(const ARgba32: TBLRgba32): TBLRgba; overload; inline;
function BLRgba(const ARgba64: TBLRgba64): TBLRgba; overload; inline;
function BLRgba(const AR, AG, AB: Single; const AA: Single = 1): TBLRgba; overload; inline;
function BLRgba(const AColor: TAlphaColorF): TBLRgba; overload; inline;

function BLMin(const AA, AB: TBLRgba32): TBLRgba32; overload; inline;
function BLMax(const AA, AB: TBLRgba32): TBLRgba32; overload; inline;
function BLMin(const AA, AB: TBLRgba64): TBLRgba64; overload; inline;
function BLMax(const AA, AB: TBLRgba64): TBLRgba64; overload; inline;
function BLMin(const AA, AB: TBLRgba): TBLRgba; overload; inline;
function BLMax(const AA, AB: TBLRgba): TBLRgba; overload; inline;
{$ENDREGION 'Colors'}

{$REGION 'Imaging'}

{ ============================================================================
   [Imaging - Pixel Format]
  ============================================================================ }

type
  /// <summary>
  ///  Pixel format.
  /// </summary>
  TBLFormat = (
    /// <summary>
    /// None or invalid pixel format.
    /// </summary>
    None,

    /// <summary>
    /// 32-bit premultiplied ARGB pixel format (8-bit components).
    /// </summary>
    Prgb32,

    /// <summary>
    /// 32-bit (X)RGB pixel format (8-bit components, alpha ignored).
    /// </summary>
    Xrgb32,

    /// <summary>
    /// 8-bit alpha-only pixel format.
    /// </summary>
    A8);

type
  /// <summary>
  ///  Pixel format flags.
  /// </summary>
  TBLFormatFlag = (
    /// <summary>
    ///  Pixel format provides RGB components.
    /// </summary>
    Rgb = 0,

    /// <summary>
    ///  Pixel format provides only alpha component.
    /// </summary>
    Alpha = 1,

    /// <summary>
    ///  Pixel format provides LUM component (and not RGB components).
    /// </summary>
    Lum = 2,

    /// <summary>
    ///  Indexed pixel format the requires a palette (I/O only).
    /// </summary>
    Indexed = 4,

    /// <summary>
    ///  RGB components are premultiplied by alpha component.
    /// </summary>
    Premultiplied = 8,

    /// <summary>
    ///  Pixel format doesn't use native byte-order (I/O only).
    /// </summary>
    ByteSwap = 9,

    // The following flags are only informative. They are part of `TBLFormatInfo`,
    // but don't have to be passed to `TBLPixelConverter` as they will always be
    // calculated automatically.

    /// <summary>
    ///  Pixel components are byte aligned (all 8bpp).
    /// </summary>
    ByteAligned = 16,

    /// <summary>
    ///  Pixel has some undefined bits that represent no information.
    ///
    ///  For example a 32-bit XRGB pixel has 8 undefined bits that are usually
    ///  set to all ones so the format can be interpreted as premultiplied RGB
    ///  as well. There are other formats like 16_0555 where the bit has no
    ///  information and is usually set to zero. Blend2D doesn't rely on the
    ///  content of such bits.
    /// </summary>
    UndefinedBits = 17);

type
  /// <summary>
  ///  Pixel format flags.
  /// </summary>
  TBLFormatFlags = set of TBLFormatFlag;

type
  /// <summary>
  ///  Adds functionality to TBLFormatFlags.
  /// </summary>
  _TBLFormatFlagsHelper = record helper for TBLFormatFlags
  public const
    /// <summary>
    ///  No flags
    /// </summary>
    None = [];

    /// <summary>
    ///  A combination of `Rgb` and `Alpha`.
    /// </summary>
    Rgba = [TBLFormatFlag.Rgb, TBLFormatFlag.Alpha];

    /// <summary>
    ///  A combination of `Lum` and `Alpha`.
    /// </summary>
    Luma = [TBLFormatFlag.Lum, TBLFormatFlag.Alpha];
  end;

type
  TBLFourBytes = array [0..3] of Byte;

type
  /// <summary>
  ///  Provides a detailed information about a pixel format.
  ///  Use `Query` for information of Blend2D native pixel formats.
  /// </summary>
  TBLFormatInfo = packed record
  {$REGION 'Internal Declarations'}
  private
    FDepth: Int32;
    FFlags: TBLFormatFlags;
    FSizes: TBLFourBytes;
    FShifts: TBLFourBytes;
    function GetShift(const AIndex: Integer): Byte; inline;
    procedure SetShift(const AIndex: Integer; const AValue: Byte); inline;
    function GetSize(const AIndex: Integer): Byte; inline;
    procedure SetSize(const AIndex: Integer; const AValue: Byte); inline;
    function GetPalette: PBLRgba32; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    class operator Equal(const ALeft, ARight: TBLFormatInfo): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLFormatInfo): Boolean; inline; static;

    procedure Reset; inline;

    procedure Init(const ADepth: Integer; const AFlags: TBLFormatFlags;
      const ASizes, AShifts: TBLFourBytes); inline;
    procedure SetSizes(const AR, AG, AB, AA: Byte); inline;
    procedure SetShifts(const AR, AG, AB, AA: Byte); inline;

    function HasFlag(const AFlag: TBLFormatFlag): Boolean; inline;
    procedure AddFlags(const AFlags: TBLFormatFlags); inline;
    procedure ClearFlags(const AFlags: TBLFormatFlags); inline;

    /// <summary>
    ///  Query Blend2D `AFormat` and copy it to this format info.
    /// </summary>
    /// <remarks>
    ///  `TBLFormat.None` is considered invalid format, thus if it's passed to
    ///  `Query` it will raise an error.
    /// <.remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Query(const AFormat: TBLFormat); inline;

    /// <summary>
    ///  Sanitize this `TBLFormatInfo`.
    ///
    ///  Sanitizer verifies whether the format is valid and updates the format
    ///  information about flags to values that Blend2D expects. For example
    ///  format flags are properly examined and simplified if possible,
    ///  byte-swap is implicitly performed for formats where a single component
    ///  matches one byte, etc...
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Sanitize; inline;

    property Depth: Integer read FDepth write FDepth;
    property Flags: TBLFormatFlags read FFlags write FFlags;
    property Sizes[const AIndex: Integer]: Byte read GetSize write SetSize;
    property Shifts[const AIndex: Integer]: Byte read GetShift write SetShift;
    property RSize: Byte read FSizes[0] write FSizes[0];
    property GSize: Byte read FSizes[1] write FSizes[1];
    property BSize: Byte read FSizes[2] write FSizes[2];
    property ASize: Byte read FSizes[3] write FSizes[3];
    property RShift: Byte read FShifts[0] write FShifts[0];
    property GShift: Byte read FShifts[1] write FShifts[1];
    property BShift: Byte read FShifts[2] write FShifts[2];
    property AShift: Byte read FShifts[3] write FShifts[3];
    property Palette: PBLRgba32 read GetPalette;
  end;
  PBLFormatInfo = ^TBLFormatInfo;

type
  /// <summary>
  ///  Adds functionality to TBLFormat.
  /// </summary>
  _TBLFormatHelper = record helper for TBLFormat
  public
    /// <summary>
    ///  Get information about this format.
    /// </summary>
    /// <remarks>
    ///  `TBLFormat.None` is considered invalid format, thus if it's passed to
    ///  `Query` it will raise an error.
    /// <.remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function Info: TBLFormatInfo; inline;
  end;

{ ============================================================================
   [Imaging - Pixel Conversion]
  ============================================================================ }

type
  /// <summary>
  ///  Flags used by `TBLPixelConverter.Make` function.
  /// </summary>
  /// <seealso cref="TBLPixelConverter"/>
  TBLPixelConverterCreateFlag = (
    /// <summary>
    ///  Specifies that the source palette in `TBLFormatInfo` doesn't have to by
    ///  copied by `TBLPixelConverter`. The caller must ensure that the palette
    ///  would stay valid until the pixel converter is destroyed.
    /// </summary>
    /// <seealso cref="TBLFormatInfo"/>
    /// <seealso cref="TBLPixelConverter"/>
    DontCopyPalette = 0,

    /// <summary>
    ///  Specifies that the source palette in `TBLFormatInfo` is alterable and
    ///  the pixel converter can modify it when preparing the conversion. The
    ///  modification can be irreversible so only use this flag when you are
    ///  sure that the palette passed to `TBLPixelConverter.Make` won't be
    ///  needed outside of pixel conversion.
    /// </summary>
    /// <remarks>
    ///  The flag `DontCopyPalette` must be set as well, otherwise this flag
    ///  would be ignored.
    /// </remarks>
    /// <seealso cref="TBLFormatInfo"/>
    /// <seealso cref="TBLPixelConverter"/>
    AlterablePalette = 1,

    /// <summary>
    ///  When there is no built-in conversion between the given pixel formats
    ///  it's possible to use an intermediate format that is used during
    ///  conversion. In such case the base pixel converter creates two more
    ///  converters that are then used internally.
    ///
    ///  This option disables such feature - creating a pixel converter would
    ///  fail if direct conversion is not possible.
    /// </summary>
    NoMultiStep = 2);

type
  /// <summary>
  ///  Flags used by `TBLPixelConverter.Make` function.
  /// </summary>
  TBLPixelConverterCreateFlags = set of TBLPixelConverterCreateFlag;

type
  /// <summary>
  ///  Adds functionality to TBLPixelConverterCreateFlags.
  /// </summary>
  _TBLPixelConverterCreateFlagsHelper = record helper for TBLPixelConverterCreateFlags
  public const
    None = [];
  end;

type
  /// <summary>
  ///  Pixel conversion options.
  /// </summary>
  TBLPixelConverterOptions = record
  public
    Origin: TBLPointI;
    Gap: NativeInt;
  end;
  PBLPixelConverterOptions = ^TBLPixelConverterOptions;

type
  /// <summary>
  ///  Pixel converter.
  ///
  ///  Provides an interface to convert pixels between various pixel formats.
  ///  The primary purpose of this record is to allow efficient conversion
  ///  between pixel formats used natively by Blend2D and pixel formats used
  ///  elsewhere, for example image codecs or native framebuffers.
  /// </summary>
  /// <remarks>
  ///  A default-initialized converter has a valid conversion function that
  ///  would return fail if invoked. Use `IsInitialized` to test whether the
  ///  pixel converter was properly initialized.
  /// </remarks>
  TBLPixelConverter = record
  {$REGION 'Internal Declarations'}
  private type
    TCore = record
    case Byte of
      0: (ConvertFunc: Pointer;
          InternalFlags: Byte);
      1: (Data: array [0..79] of Byte);
    end;
  private
    FCore: TCore;
    function GetIsInitialized: Boolean; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Creates a new default-initialized pixel converter.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Initialize(out ADest: TBLPixelConverter);

    /// <summary>
    ///  Destroys the pixel-converter and releases all resources allocated by it.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Finalize(var ADest: TBLPixelConverter);

    /// <summary>
    ///  Creates a copy of the `AOther` converter.
    ///
    ///  If the `AOther` converter has dynamically allocated resources they will
    ///  be properly managed (reference counting). Only very specific converters
    ///  require such resources so this operation should be considered very
    ///  cheap.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Assign(var ADest: TBLPixelConverter; const [ref] ASrc: TBLPixelConverter); inline;

    /// <summary>
    ///  Reset the pixel converter.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Reset; inline;

    /// <summary>
    ///  Creates a new pixel converter that will convert pixels described by
    //   `ASrcInfo` into pixels described by `ADstInfo`.
    ///
    ///  Use `ACreateFlags` to further specify the parameters of the conversion.
    /// </summary>
    /// <remarks>
    ///  Destination and source format informattion must be valid, otherwise
    ///  this method will fail.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Make(const ADstInfo, ASrcInfo: TBLFormatInfo;
      const ACreateFlags: TBLPixelConverterCreateFlags = []); inline;

    /// <summary>
    ///  Creates a pixel converter appropriate for the current platform. This is
    ///  useful for platforms where the display format does not match the
    ///  internal Blend2D format. For example, on macOS, iOS and Android, the
    ///  red and blue color channels need to be swapped. On Windows, Blend2D's
    ///  internal format matches the display format and no conversion is needed.
    ///
    ///  On Windows, it returns a converter that doesn't convert, but just
    ///  copies the data. However, it is more efficient to not use a pixel
    ///  converter at all on Windows.
    ///
    ///  On other platforms, it creates a converter that swaps Red and Blue in
    ///  the given AFormat.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure MakePlatformConverter(const AFormat: TBLFormat);

    /// <summary>
    ///  Converts a single span of pixels of `AWidth`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ConvertSpan(const ADstData, ASrcData: Pointer;
      const AWidth: Integer); overload; inline;

    /// <summary>
    ///  Converts a single span of pixels of `AWidth`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ConvertSpan(const ADstData, ASrcData: Pointer;
      const AWidth: Integer; const AOptions: TBLPixelConverterOptions); overload; inline;

    /// <summary>
    ///  Converts a rectangular area of pixels from source format to destination.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ConvertRect(const ADstData: Pointer; const ADstStride: NativeInt;
      const ASrcData: Pointer; const ASrcStride: NativeInt;
      const AWidth, AHeight: Integer); overload; inline;

    /// <summary>
    ///  Converts a rectangular area of pixels from source format to destination.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ConvertRect(const ADstData: Pointer; const ADstStride: NativeInt;
      const ASrcData: Pointer; const ASrcStride: NativeInt; const AWidth,
      AHeight: Integer; const AOptions: TBLPixelConverterOptions); overload; inline;

    /// <summary>
    ///  Whether if the converter is initialized.
    /// </summary>
    property IsInitialized: Boolean read GetIsInitialized;
  end;

{ ============================================================================
   [Imaging - Image Codecs]
  ============================================================================ }

type
  /// <summary>
  ///  Flags used by `TBLImageInfo`.
  /// </summary>
  TBLImageInfoFlag = (
    /// <summary>
    ///  Progressive mode.
    /// </summary>
    Progressive = 0);

type
  /// <summary>
  ///  Flags used by `TBLImageInfo`.
  /// </summary>
  TBLImageInfoFlags = set of TBLImageInfoFlag;

type
  /// <summary>
  ///  Adds functionality to TBLImageInfoFlags
  /// </summary>
  _TBLImageInfoFlagsHelper = record helper for TBLImageInfoFlags
  public const
    None = [];
  end;

type
  /// <summary>
  ///  Image information provided by image codecs.
  /// </summary>
  TBLImageInfo = record
  {$REGION 'Internal Declarations'}
  private
    FSize: TBLSizeI;
    FDensity: TBLSize;
    FFlags: UInt32;
    FDepth: Int16;
    FPlaneCount: Int16;
    FFrameCount: Int64;
    FRepeatCount: Int32;
    {$HINTS OFF}
    FReserved: array [0..2] of UInt32;
    {$HINTS ON}
    FFormat: array [0..15] of UTF8Char;
    FCompression: array [0..15] of UTF8Char;
    function GetFlags: TBLImageInfoFlags; inline;
    function GetFormat: String; inline;
    function GetCompression: String; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Image size.
    /// </summary>
    property Size: TBLSizeI read FSize;

    /// <summary>
    ///  Pixel density per one meter, can contain fractions.
    /// </summary>
    property Density: TBLSize read FDensity;

    /// <summary>
    ///  Image flags.
    /// </summary>
    property Flags: TBLImageInfoFlags read GetFlags;

    /// <summary>
    ///  Image depth.
    /// </summary>
    property Depth: Smallint read FDepth;

    /// <summary>
    ///  Number of planes.
    /// </summary>
    property PlaneCount: Smallint read FPlaneCount;

    /// <summary>
    ///  Number of frames (0 = unknown/unspecified).
    /// </summary>
    property FrameCount: Int64 read FFrameCount;

    /// <summary>
    ///  Number of animation repeats (0 = infinite).
    /// </summary>
    property RepeatCount: Integer read FRepeatCount;

    /// <summary>
    ///  Image format (as understood by codec).
    /// </summary>
    property Format: String read GetFormat;

    /// <summary>
    ///  Image compression (as understood by codec).
    /// </summary>
    property Compression: String read GetCompression;
  public
    procedure Reset; inline;
  end;
  PBLImageInfo = ^TBLImageInfo;

type
  /// <summary>
  ///  Image codec feature bits.
  /// </summary>
  TBLImageCodecFeature = (
    /// <summary>
    ///  Image codec supports reading images (can create TBLImageDecoder).
    /// </summary>
    Read = 0,

    /// <summary>
    ///  Image codec supports writing images (can create TBLImageEncoder).
    /// </summary>
    Write = 1,

    /// <summary>
    ///  Image codec supports lossless compression.
    /// </summary>
    Lossless = 2,

    /// <summary>
    ///  Image codec supports lossy compression.
    /// </summary>
    Lossy = 3,

    /// <summary>
    ///  Image codec supports writing multiple frames (GIF).
    /// </summary>
    MultiFrame = 4,

    /// <summary>
    ///  Image codec supports IPTC metadata.
    /// </summary>
    Iptc = 28,

    /// <summary>
    ///  Image codec supports EXIF metadata.
    /// </summary>
    Exif = 29,

    /// <summary>
    ///  Image codec supports XMP metadata.
    /// </summary>
    Xmp = 30);

type
  /// <summary>
  ///  Image codec feature bits.
  /// </summary>
  TBLImageCodecFeatures = set of TBLImageCodecFeature;

type
  /// <summary>
  ///  Adds functionality to TBLImageCodecFeatures.
  /// </summary>
  _TBLImageCodecFeaturesHelper = record helper for TBLImageCodecFeatures
  public const
    None = [];
  end;

type
  /// <summary>
  ///  Image decoder.
  /// </summary>
  TBLImageDecoder = record
  {$REGION 'Internal Declarations'}
  private type
    TImpl = record
    public
      Virt: Pointer;
      Codec: TBLObjectCore;
      LastResult: Integer;
      Handle: Pointer;
      FrameIndex: Int64;
      BufferIndex: NativeInt;
    end;
    PImpl = ^TImpl;
  private
    FBase: TBLObjectCore;
    function GetIsValid: Boolean; inline;
    function GetLastResult: TBLResult; inline;
    function GetFrameIndex: Int64; inline;
    function GetBufferIndex: NativeInt; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Creates a new default-initialized image decoder.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Initialize(out ADest: TBLImageDecoder);

    /// <summary>
    ///  Destroys the image decoder and releases all resources allocated by it.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Finalize(var ADest: TBLImageDecoder);

    /// <summary>
    ///  Creates a copy of the `AOther` image decoder.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Assign(var ADest: TBLImageDecoder; const [ref] ASrc: TBLImageDecoder); inline;

    /// <summary>
    ///  Used to compare against `nil`.
    /// </summary>
    class operator Equal(const ALeft: TBLImageDecoder; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two image decoders are equal.
    /// </summary>
    class operator Equal(const ALeft, ARight: TBLImageDecoder): Boolean; inline; static;

    /// <summary>
    ///  Used to compare against `nil`.
    /// </summary>
    class operator NotEqual(const ALeft: TBLImageDecoder; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two image decoders are not equal.
    /// </summary>
    class operator NotEqual(const ALeft, ARight: TBLImageDecoder): Boolean; inline; static;

    function Equals(const AOther: TBLImageDecoder): Boolean; inline;
    procedure Reset; inline;
    procedure Swap(var AOther: TBLImageDecoder); inline;

    procedure Restart; inline;

    procedure ReadInfo(out ADst: TBLImageInfo; const ABuffer: TBLArray<Byte>); overload; inline;
    procedure ReadInfo(out ADst: TBLImageInfo; const ABuffer: TBytes); overload; inline;
    procedure ReadInfo(out ADst: TBLImageInfo; const AView: TBLArrayView<Byte>); overload; inline;
    procedure ReadInfo(out ADst: TBLImageInfo; const AData: Pointer;
      const ASize: NativeInt); overload; inline;

    /// <summary>
    ///  Tests whether the image decoder is not a built-in null instance.
    /// </summary>
    property IsValid: Boolean read GetIsValid;

    /// <summary>
    ///  The last decoding result.
    /// </summary>
    property LastResult: TBLResult read GetLastResult;

    /// <summary>
    ///  The current frame index (to be decoded).
    /// </summary>
    property FrameIndex: Int64 read GetFrameIndex;

    /// <summary>
    ///  The position in source buffer.
    /// </summary>
    property BufferIndex: NativeInt read GetBufferIndex;
  end;

type
  /// <summary>
  ///  Image encoder.
  /// </summary>
  TBLImageEncoder = record
  {$REGION 'Internal Declarations'}
  private type
    TImpl = record
    public
      Virt: Pointer;
      Codec: TBLObjectCore;
      LastResult: Integer;
      Handle: Pointer;
      FrameIndex: Int64;
      BufferIndex: NativeInt;
    end;
    PImpl = ^TImpl;
  private
    FBase: TBLObjectCore;
    function GetIsValid: Boolean; inline;
    function GetLastResult: TBLResult; inline;
    function GetFrameIndex: Int64; inline;
    function GetBufferIndex: NativeInt; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Creates a new default-initialized image encoder.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Initialize(out ADest: TBLImageEncoder);

    /// <summary>
    ///  Destroys the image encoder and releases all resources allocated by it.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Finalize(var ADest: TBLImageEncoder);

    /// <summary>
    ///  Creates a copy of the `AOther` image encoder.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Assign(var ADest: TBLImageEncoder; const [ref] ASrc: TBLImageEncoder); inline;

    /// <summary>
    ///  Used to compare against `nil`.
    /// </summary>
    class operator Equal(const ALeft: TBLImageEncoder; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two image encoders are equal.
    /// </summary>
    class operator Equal(const ALeft, ARight: TBLImageEncoder): Boolean; inline; static;

    /// <summary>
    ///  Used to compare against `nil`.
    /// </summary>
    class operator NotEqual(const ALeft: TBLImageEncoder; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two image encoders are not equal.
    /// </summary>
    class operator NotEqual(const ALeft, ARight: TBLImageEncoder): Boolean; inline; static;

    function Equals(const AOther: TBLImageEncoder): Boolean; inline;
    procedure Reset; inline;
    procedure Swap(var AOther: TBLImageEncoder); inline;

    procedure Restart; inline;

    /// <summary>
    ///  Tests whether the image encoder is not a built-in null instance.
    /// </summary>
    property IsValid: Boolean read GetIsValid;

    /// <summary>
    ///  The last encoding result.
    /// </summary>
    property LastResult: TBLResult read GetLastResult;

    /// <summary>
    ///  The current frame index (yet to be written).
    /// </summary>
    property FrameIndex: Int64 read GetFrameIndex;

    /// <summary>
    ///  The position in destination buffer.
    /// </summary>
    property BufferIndex: NativeInt read GetBufferIndex;
  end;

type
  /// <summary>
  ///  Image codec.
  ///
  ///  Provides a unified interface for inspecting image data and creating image
  ///  decoders & encoders.
  /// </summary>
  TBLImageCodec = record
  {$REGION 'Internal Declarations'}
  private type
    TImpl = record
    public
      Virt: Pointer;
      Name: TBLObjectCore;
      Vendor: TBLObjectCore;
      MimeType: TBLObjectCore;
      Extensions: TBLObjectCore;
      Features: UInt32;
    end;
    PImpl = ^TImpl;
  private
    FBase: TBLObjectCore;
    function GetIsValid: Boolean; inline;
    function GetName: TBLString; inline;
    function GetVendor: TBLString; inline;
    function GetMimeType: TBLString; inline;
    function GetExtensions: TBLString; inline;
    function GetFeatures: TBLImageCodecFeatures; inline;
    class function GetBuiltInCodecs: TBLArray<TBLImageCodec>; inline; static;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Creates a new default-initialized image codec.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Initialize(out ADest: TBLImageCodec);

    /// <summary>
    ///  Destroys the image codec and releases all resources allocated by it.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Finalize(var ADest: TBLImageCodec);

    /// <summary>
    ///  Creates a copy of the `AOther` image codec.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Assign(var ADest: TBLImageCodec; const [ref] ASrc: TBLImageCodec); inline;

    /// <summary>
    ///  Used to compare against `nil`.
    /// </summary>
    class operator Equal(const ALeft: TBLImageCodec; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two image codecs are equal.
    /// </summary>
    class operator Equal(const ALeft, ARight: TBLImageCodec): Boolean; inline; static;

    /// <summary>
    ///  Used to compare against `nil`.
    /// </summary>
    class operator NotEqual(const ALeft: TBLImageCodec; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two image codecs are not equal.
    /// </summary>
    class operator NotEqual(const ALeft, ARight: TBLImageCodec): Boolean; inline; static;

    function Equals(const AOther: TBLImageCodec): Boolean; inline;
    procedure Reset; inline;
    procedure Swap(var AOther: TBLImageCodec); inline;

    /// <summary>
    ///  Tests whether the image codec has the given feature.
    /// </summary>
    function HasFeature(const AFeature: TBLImageCodecFeature): Boolean; inline;

    procedure FindByName(const AName: String); overload; inline;
    procedure FindByName(const AName: String;
      const ACodecs: TBLArray<TBLImageCodec>); overload; inline;
    procedure FindByName(const AName: TBLStringView); overload; inline;
    procedure FindByName(const AName: TBLStringView;
      const ACodecs: TBLArray<TBLImageCodec>); overload; inline;

    procedure FindByExtension(const AExt: String); overload; inline;
    procedure FindByExtension(const AExt: String;
      const ACodecs: TBLArray<TBLImageCodec>); overload; inline;
    procedure FindByExtension(const AExt: TBLStringView); overload; inline;
    procedure FindByExtension(const AExt: TBLStringView;
      const ACodecs: TBLArray<TBLImageCodec>); overload; inline;

    procedure FindByData(const AData: Pointer; const ASize: NativeInt); overload; inline;
    procedure FindByData(const AData: Pointer; const ASize: NativeInt;
      const ACodecs: TBLArray<TBLImageCodec>); overload; inline;
    procedure FindByData(const AView: TBLArrayView<Byte>); overload; inline;
    procedure FindByData(const AView: TBLArrayView<Byte>;
      const ACodecs: TBLArray<TBLImageCodec>); overload; inline;
    procedure FindByData(const ABuffer: TBLArray<Byte>); overload; inline;
    procedure FindByData(const ABuffer: TBLArray<Byte>;
      const ACodecs: TBLArray<TBLImageCodec>); overload; inline;
    procedure FindByData(const ABuffer: TBytes); overload; inline;
    procedure FindByData(const ABuffer: TBytes;
      const ACodecs: TBLArray<TBLImageCodec>); overload; inline;

    function InspectData(const ABuffer: TBLArray<Byte>): Cardinal; overload; inline;
    function InspectData(const ABuffer: TBytes): Cardinal; overload; inline;
    function InspectData(const AView: TBLArrayView<Byte>): Cardinal; overload; inline;
    function InspectData(const AData: Pointer; const ASize: NativeInt): Cardinal; overload; inline;

    function CreateDecoder: TBLImageDecoder; inline;
    function CreateEncoder: TBLImageEncoder; inline;

    /// <summary>
    ///  Adds a codec to a global built-in codecs registry.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class procedure AddToBuiltIn(const ACodec: TBLImageCodec); inline; static;

    /// <summary>
    ///  Removes a codec from a global built-in codecs registry.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class procedure RemoveFromBuiltIn(const ACodec: TBLImageCodec); inline; static;

    /// <summary>
    ///  Tests whether the image codec is not a built-in null instance.
    /// </summary>
    property IsValid: Boolean read GetIsValid;

    /// <summary>
    ///  Image codec name (i.e, "PNG", "JPEG", etc...).
    /// </summary>
    property Name: TBLString read GetName;

    /// <summary>
    ///  The image codec vendor (i.e. "Blend2D" for all built-in codecs).
    /// </summary>
    property Vendor: TBLString read GetVendor;

    /// <summary>
    ///  A mime-type associated with the image codec's format.
    /// </summary>
    property MimeType: TBLString read GetMimeType;

    /// <summary>
    ///  A list of file extensions used to store image of this codec,
    ///  separated by '|' character.
    /// </summary>
    property Extensions: TBLString read GetExtensions;

    /// <summary>
    ///  Image codec flags.
    /// </summary>
    property Features: TBLImageCodecFeatures read GetFeatures;

    /// <summary>
    ///  Built-in codecs, which are present in a global registry.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class property BuiltInCodecs: TBLArray<TBLImageCodec> read GetBuiltInCodecs;
  end;

{ ============================================================================
   [Imaging - Images]
  ============================================================================ }

type
  /// <summary>
  ///  Filter type used by `TBLImage.Scale`.
  /// </summary>
  /// <seealso cref="TBLImage"/>
  TBLImageScaleFilter = (
    /// <summary>
    ///  No filter or uninitialized.
    /// </summary>
    None,

    /// <summary>
    ///  Nearest neighbor filter (radius 1.0).
    /// </summary>
    Nearest,

    /// <summary>
    ///  Bilinear filter (radius 1.0).
    /// </summary>
    Bilinear,

    /// <summary>
    ///  Bicubic filter (radius 2.0).
    /// </summary>
    Bicubic,

    /// <summary>
    ///  Lanczos filter (radius 2.0).
    /// </summary>
    Lanczos);

type
  /// <summary>
  ///  Data that describes a raster image. Used by `TBLImage`.
  /// </summary>
  /// <seealso cref="TBLImage"/>
  TBLImageData = record
  public
    /// <summary>
    ///  Pixel data, starting at the top left corner of the image.
    /// </summary>
    /// <remarks>
    ///  If the stride is negative the image data would start at the bottom.
    /// </remarks>
    PixelData: Pointer;

    /// <summary>
    ///  Stride (in bytes) of image data (positive when image data starts at
    ///  top-left, negative when it starts at bottom-left).
    /// </summary>
    Stride: IntPtr;

    /// <summary>
    ///  Size of the image.
    /// </summary>
    Size: TBLSizeI;

    /// <summary>
    ///  Pixel format.
    /// </summary>
    Format: TBLFormat;

    Flags: Cardinal;
  public
    /// <summary>
    ///  Resets the image data to represent an empty image (all members set to zeros).
    /// </summary>
    procedure Reset; inline;
  end;
  PBLImageData = ^TBLImageData;

type
  /// <summary>
  ///  2D raster image.
  ///
  ///  Raster image holds pixel data and additional information such as pixel
  ///  format. The underlying image data can be shared between multiple
  ///  instances of `TBLImage`, which can be used by multiple threads. Atomic
  ///  reference counting is used to safely manage the internal reference count
  ///  of the underlying image data.
  ///
  ///  When an image is copied to another TBLImage instance its called a
  ///  weak-copy as the underlying data is not copied, but the reference count
  ///  is increased instead (atomically).
  /// </summary>
  TBLImage = record
  {$REGION 'Internal Declarations'}
  private type
    TImpl = record
    public
      PixelData: Pointer;
      Stride: IntPtr;
      Size: TBLSizeI;
      Format: UInt8;
      Flags: UInt8;
      Depth: UInt16;
      Reserved: array [0..3] of UInt8;
    end;
    PImpl = ^TImpl;
  private
    FBase: TBLObjectCore;
    function GetIsEmpty: Boolean; inline;
    function GetWidth: Integer; inline;
    function GetHeight: Integer; inline;
    function GetSize: TBLSizeI; inline;
    function GetFormat: TBLFormat; inline;
    function GetDepth: Integer; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Creates a default constructed image, which is an empty image having
    //   pixel format equal to `TBLFormat.None`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="TBLFormat"/>
    class operator Initialize(out ADest: TBLImage);

    /// <summary>
    ///  Destroys the image data held by the instance.
    ///
    ///  The pixel data held by the image will only be deallocated if the
    ///  reference count of the underlying representation gets decremented to
    ///  zero.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Finalize(var ADest: TBLImage);

    /// <summary>
    ///  Creates a weak copy of `ASrc` image by incrementing the reference count
    ///  of the underlying representation.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Assign(var ADest: TBLImage; const [ref] ASrc: TBLImage); inline;

    /// <summary>
    ///  Creates a new image data of `[AWidth, AHeight]` size (specified in
    ///  pixels) having the given pixel `AFormat`.
    ///
    ///  To create a valid image, both `AWidth` and `AHeight` must be greater
    ///  than zero and the pixel `AFormat` cannot be TBLFormat.None.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    constructor Create(const AWidth, AHeight: Integer; const AFormat: TBLFormat);

    /// <summary>
    ///  Used to compare against `nil`.
    /// </summary>
    class operator Equal(const ALeft: TBLImage; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Tests whether the `ALeft` image is equal with `ARight` image.
    ///  See Equals for more details about image equality.
    /// </summary>
    class operator Equal(const ALeft, ARight: TBLImage): Boolean; inline; static;

    /// <summary>
    ///  Used to compare against `nil`.
    /// </summary>
    class operator NotEqual(const ALeft: TBLImage; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Tests whether the `ALeft` image is not equal with `ARight` image.
    ///  See Equals for more details about image equality.
    /// </summary>
    class operator NotEqual(const ALeft, ARight: TBLImage): Boolean; inline; static;

    /// <summary>
    ///  Resets the image to a default constructed image.
    ///
    ///  A default constructed image has zero size and a pixel format equal to
    ///  `TBLFormat.None`. Such image is considered `IsEmpty` and holds no data
    ///  that could be used by the rendering context or as a pattern.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="TBLFormat"/>
    /// <seealso cref="IsEmpty"/>
    procedure Reset; inline;

    /// <summary>
    ///  Swaps the underlying data with the `AOther` image.
    /// </summary>
    procedure Swap(var AOther: TBLImage); inline;

    /// <summary>
    ///  Copy assignment replaces the underlying data of this image with
    ///  `AOther`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AssignShallow(const AOther: TBLImage); inline;

    /// <summary>
    ///  Create a deep copy of the `AOther` image.
    /// </summary>
    procedure AssignDeep(const AOther: TBLImage); inline;

    /// <summary>
    ///  Tests whether the image is equal to `AOther` image.
    ///
    ///  Images are equal when the size, pixel format, and pixel data match.
    ///  This means that this operation could be very expensive if the images
    ///  are large.
    /// </summary>
    function Equals(const AOther: TBLImage): Boolean; inline;

    /// <summary>
    ///  Creates a new image of a specified 'AWidth`, `AHeight`, and `AFormat`.
    /// </summary>
    /// <remarks>
    ///  If invalid arguments (invalid size or format) were passed to the
    ///  method, an error with code `TBLResult.InvalidValue` will be returned
    ///  and no data will be allocated. It's also important to notice that this
    ///  method would not change anything if it fails (the previous image
    ///  content would be kept as is in such case).
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Make(const AWidth, AHeight: Integer; const AFormat: TBLFormat); inline;

    /// <summary>
    ///  Creates a new image from external data passed in `APixelData`.
    ///
    ///  Blend2D can use pixel-data allocated outside of Blend2D, which is
    ///  useful for rendering into images that can be allocated by other
    ///  libraries. The only thing that the user should pay extra attention to
    ///  is the passed pixel `AFormat` and `AStride`.
    ///
    ///  If the image data you are passing is read-only, pass
    ///  `TBLDataAccessFlag.Read` in `AAccessFlags`, in that case Blend2D would
    ///  never attempt to modify the passed data and would create a copy instead
    ///  if such image gets modified.
    ///
    ///  Additionally, if you would like to get notified about the destruction
    ///  of the image (and thus Blend2D not holding the passed `APixelData`
    ///  anymore, pass your own function in `ADestroyFunc` parameter with an
    ///  optional `AUserData`).
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure MakeFromData(const AWidth, AHeight: Integer;
      const AFormat: TBLFormat; const APixelData: Pointer; const AStride: IntPtr;
      const AAccessFlags: TBLDataAccessFlags = TBLDataAccessFlags.RW;
      const ADestroyFunc: TBLDestroyExternalDataFunc = nil;
      const AUserData: Pointer = nil); inline;

    /// <summary>
    ///  Returns immutable in `ADataOut`, which contains pixel pointer, stride,
    ///  and other image properties like size and pixel format.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <remarks>
    ///  Although the data is filled in `TBLImageData`, which holds a
    ///  `PixelData` pointer, the data is immutable. If you intend to modify the
    ///  data, use `MakeMutable` method instead, which would copy the image
    ///  data if it's shared with another `TBLImage` instance.
    /// </remarks>
    /// <seealso cref="TBLImageData"/>
    /// <seealso cref="MakeMutable"/>
    procedure GetData(out ADataOut: TBLImageData); inline;

    /// <summary>
    ///  Makes the image data mutable and returns them in `ADataOut`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure MakeMutable(out ADataOut: TBLImageData); inline;

    /// <summary>
    ///  Converts the image to a different pixel `AFormat`.
    ///
    ///  This operation could be lossy if the given pixel `AFormat` has less
    ///  channels than this image.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <remarks>
    ///  If the image `IsEmpty` the image format would not be changed. It will
    ///  stay `TBLFormat.None` and an error with code TBLResult.NotInitialized
    ///  will be raised.
    /// </remarks>
    /// <seealso cref="IsEmpty"/>
    procedure Convert(const AFormat: TBLFormat); inline;

    /// <summary>
    ///  Reads an image from a file specified by `AFileName`.
    ///
    ///  Image reader will automatically detect the image format by checking
    ///  whether it's supported by available image codecs, which can be
    ///  retrieved by `TBLImageCodec.BuiltInCodecs`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="TBLImageCodec.BuiltInCodecs"/>
    procedure ReadFromFile(const AFilename: String); overload; inline;

    /// <summary>
    ///  Reads an image from a file specified by `AFilename` by using image
    ///  codecs passed via `ACodecs` parameter.
    ///
    ///  Image reader will automatically detect the image format by checking
    ///  whether it's supported by the passed image `ACodecs` - only codecs
    ///  passed in will be considered.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ReadFromFile(const AFilename: String;
      const ACodecs: TBLArray<TBLImageCodec>); overload; inline;

    /// <summary>
    ///  Reads an image from an existing byte-array starting at `AData` and
    ///  having `ASize` bytes.
    ///
    ///  Image reader will automatically detect the image format by checking
    ///  whether it's supported by available image codecs, which can be
    ///  retrieved by `TBLImageCodec.BuiltInCodecs`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="TBLImageCodec.BuiltInCodecs"/>
    procedure ReadFromData(const AData: Pointer; const ASize: NativeInt); overload; inline;

    /// <summary>
    ///  Reads an image from an existing byte-array starting at `AData` and
    ///  having `ASize` bytes by using image codecs passed via `ACodecs`
    ///  parameter.
    ///
    ///  Image reader will automatically detect the image format by checking
    ///  whether it's supported by the passed image `ACodecs` - only codecs
    ///  passed in will be considered.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ReadFromData(const AData: Pointer; const ASize: NativeInt;
      const ACodecs: TBLArray<TBLImageCodec>); overload; inline;

    /// <summary>
    ///  Reads an image from an existing byte-buffer passed via `AArray`.
    ///
    ///  Image reader will automatically detect the image format by checking
    ///  whether it's supported by available image codecs, which can be
    ///  retrieved by `TBLImageCodec.BuiltInCodecs`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="TBLImageCodec.BuiltInCodecs"/>
    procedure ReadFromData(const AArray: TBLArray<Byte>); overload; inline;

    /// <summary>
    ///  Reads an image from an existing byte-buffer passed via `AArray` by
    ///  using image codecs passed via `ACodecs` parameter.
    ///
    ///  Image reader will automatically detect the image format by checking
    ///  whether it's supported by the passed image `ACodecs` - only codecs
    ///  passed in will be considered.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ReadFromData(const AArray: TBLArray<Byte>;
      const ACodecs: TBLArray<TBLImageCodec>); overload; inline;

    /// <summary>
    ///  Reads an image from an existing byte-buffer passed via `AArray`.
    ///
    ///  Image reader will automatically detect the image format by checking
    ///  whether it's supported by available image codecs, which can be
    ///  retrieved by `TBLImageCodec.BuiltInCodecs`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="TBLImageCodec.BuiltInCodecs"/>
    procedure ReadFromData(const AArray: TBytes); overload; inline;

    /// <summary>
    ///  Reads an image from an existing byte-buffer passed via `AArray` by
    ///  using image codecs passed via `ACodecs` parameter.
    ///
    ///  Image reader will automatically detect the image format by checking
    ///  whether it's supported by the passed image `ACodecs` - only codecs
    ///  passed in will be considered.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ReadFromData(const AArray: TBytes;
      const ACodecs: TBLArray<TBLImageCodec>); overload; inline;

    /// <summary>
    ///  Reads an image from an existing byte-view passed via `AView`.
    ///
    ///  Image reader will automatically detect the image format by checking
    ///  whether it's supported by available image codecs, which can be
    ///  retrieved by `TBLImageCodec.BuiltInCodecs`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="TBLImageCodec.BuiltInCodecs"/>
    procedure ReadFromData(const AView: TBLArrayView<Byte>); overload; inline;

    /// <summary>
    ///  Reads an image from an existing byte-view passed via `AView` by using
    ///  image codecs passed via `ACodecs` parameter.
    ///
    ///  Image reader will automatically detect the image format by checking
    ///  whether it's supported by the passed image `ACodecs` - only codecs
    ///  passed in will be considered.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ReadFromData(const AView: TBLArrayView<Byte>;
      const ACodecs: TBLArray<TBLImageCodec>); overload; inline;

    /// <summary>
    ///  Writes an encoded image to a file specified by `AFilename`.
    ///
    ///  Image writer detects the image codec by inspecting the extension of a
    ///  file passed via `AFilename`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure WriteToFile(const AFilename: String); overload; inline;

    /// <summary>
    ///  Writes an encoded image to a file specified by `AFileName` using the
    ///  specified image `ACodec` to encode the image.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure WriteToFile(const AFilename: String;
      const ACodec: TBLImageCodec); overload; inline;

    /// <summary>
    ///  Writes an encoded image to a buffer `ADst` using the specified image
    ///  `ACodec` to encode the image.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure WriteToData(const ADst: TBLArray<Byte>;
      const ACodec: TBLImageCodec); overload; inline;

    /// <summary>
    ///  Encodes the image using the specified image `ACodec` and returns the
    ///  encoded data.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function WriteToData(const ACodec: TBLImageCodec): TBytes; overload; inline;

    /// <summary>
    ///  Scales the `ASrc` image to the specified `ASize` by using `AFilter` and
    ///  writes the scaled image to `ADst`.
    ///
    ///  If the destination image `ADst` doesn't match `ASize` and the source
    ///  pixel format the underlying image data will be re-created.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class procedure Scale(const ADst, ASrc: TBLImage; const ASize: TBLSizeI;
      const AFilter: TBLImageScaleFilter); inline; static;

    /// <summary>
    ///  Whether the image is empty (such image has no size and a pixel format
    ///  is equal to `TBLFormat.None`.
    /// </summary>
    /// <seealso cref="TBLFormat"/>
    property IsEmpty: Boolean read GetIsEmpty;

    /// <summary>
    ///  Image width (in pixels).
    /// </summary>
    property Width: Integer read GetWidth;

    /// <summary>
    ///  Image height (in pixels).
    /// </summary>
    property Height: Integer read GetHeight;

    /// <summary>
    ///  Image size (in pixels).
    /// </summary>
    property Size: TBLSizeI read GetSize;

    /// <summary>
    ///  The image format.
    /// </summary>
    /// <remarks>
    ///  When an image `IsEmpty`, the pixel format returned is always
    ///  `TBLFormat.None`.
    /// </remarks>
    /// <seealso cref="TBLFormat"/>
    /// <seealso cref="IsEmpty"/>
    property Format: TBLFormat read GetFormat;

    /// <summary>
    ///  Image depth (in bits).
    /// </summary>
    property Depth: Integer read GetDepth;
  end;

type
  /// <summary>
  ///  Adds functionality to TBLImageDecoder
  /// </summary>
  _TBLImageDecoderHelper = record helper for TBLImageDecoder
  {$REGION 'Internal Declarations'}
  private
    function GetCodec: TBLImageCodec; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    procedure ReadFrame(out ADst: TBLImage; const ABuffer: TBLArray<Byte>); overload; inline;
    procedure ReadFrame(out ADst: TBLImage; const ABuffer: TBytes); overload; inline;
    procedure ReadFrame(out ADst: TBLImage; const AView: TBLArrayView<Byte>); overload; inline;
    procedure ReadFrame(out ADst: TBLImage; const AData: Pointer;
      const ASize: NativeInt); overload; inline;

    property Codec: TBLImageCodec read GetCodec;
  end;

type
  /// <summary>
  ///  Adds functionality to TBLImageEncoder
  /// </summary>
  _TBLImageEncoderHelper = record helper for TBLImageEncoder
  {$REGION 'Internal Declarations'}
  private
    function GetCodec: TBLImageCodec; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    /// Encodes the given `AImage` and writes the encoded data to the
    /// destination buffer `ADst`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure WriteFrame(const ADst: TBLArray<Byte>; const AImage: TBLImage); overload; inline;

    /// <summary>
    /// Encodes the given `AImage` and returns the encoded data.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function WriteFrame(const AImage: TBLImage): TBytes; overload; inline;

    property Codec: TBLImageCodec read GetCodec;
  end;
{$ENDREGION 'Imaging'}

{$REGION 'Styling'}

{ ============================================================================
   [Styling - Patterns]
  ============================================================================ }

type
  /// <summary>
  ///  Extend mode.
  /// </summary>
  TBLExtendMode = (
    /// <summary>
    ///  Pad extend [default].
    /// </summary>
    Pad,

    /// <summary>
    ///  Repeat extend.
    /// </summary>
    Repeating,

    /// <summary>
    ///  Reflect extend.
    /// </summary>
    Reflect,

    /// <summary>
    ///  Alias of `Pad`.
    /// </summary>
    PadXPadY = Pad,

    /// <summary>
    ///  Pad X and repeat Y.
    /// </summary>
    PadXRepeatY = 3,

    /// <summary>
    ///  Pad X and reflect Y.
    /// </summary>
    PadXReflectY,

    /// <summary>
    ///  Alias of `Repeating`.
    /// </summary>
    RepeatXRepeat = Repeating,

    /// <summary>
    ///  Repeat X and pad Y.
    /// </summary>
    RepeatXPadY = 5,

    /// <summary>
    ///  Repeat X and reflect Y.
    /// </summary>
    RepeatXReflectY,

    /// <summary>
    ///  Alias of `Reflect`.
    /// </summary>
    ReflectXReflectY = Reflect,

    /// <summary>
    ///  Reflect X and pad Y.
    /// </summary>
    ReflectXPadY = 7,

    /// <summary>
    ///  Reflect X and repeat Y.
    /// </summary>
    ReflectXRepeatY);

type
  /// <summary>
  ///  Pattern quality.
  /// </summary>
  TBLPatternQuality = (
    /// <summary>
    ///  Nearest neighbor interpolation.
    /// </summary>
    Nearest,

    /// <summary>
    ///  Bilinear interpolation.
    /// </summary>
    Bilinear);

type
  /// <summary>
  ///  Pattern.
  /// </summary>
  TBLPattern = record
  {$REGION 'Internal Declarations'}
  private
    FBase: TBLObjectCore;
    function GetImage: TBLImage; inline;
    procedure SetImage(const AValue: TBLImage); overload; inline;
    function GetArea: TBLRectI; inline;
    procedure SetArea(const AValue: TBLRectI); inline;
    function GetExtendMode: TBLExtendMode; inline;
    procedure SetExtendMode(const AValue: TBLExtendMode); inline;
    function GetTransform: TBLMatrix2D; inline;
    procedure SetTransform(const AValue: TBLMatrix2D); inline;
    function GetTransformKind: TBLTransformKind; inline;
    function GetHasTransform: Boolean; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Creates a default constructed pattern.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Initialize(out ADest: TBLPattern);

    /// <summary>
    ///  Destroys the pattern.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Finalize(var ADest: TBLPattern);

    /// <summary>
    ///  Copy constructor creates a weak copy of `ASrc`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Assign(var ADest: TBLPattern; const [ref] ASrc: TBLPattern); inline;

    /// <summary>
    ///  Equality operator, performs the same operation as `ALeft.Equals(ARight)`.
    /// </summary>
    class operator Equal(const ALeft, ARight: TBLPattern): Boolean; inline; static;

    /// <summary>
    ///  Equality operator, performs the same operation as `not ALeft.Equals(ARight)`.
    /// </summary>
    class operator NotEqual(const ALeft, ARight: TBLPattern): Boolean; inline; static;

    constructor Create(const AImage: TBLImage;
      const AExtendMode: TBLExtendMode = TBLExtendMode.Repeating); overload;
    constructor Create(const AImage: TBLImage; const AExtendMode: TBLExtendMode;
      const ATransform: TBLMatrix2D); overload;
    constructor Create(const AImage: TBLImage; const AArea: TBLRectI;
      const AExtendMode: TBLExtendMode = TBLExtendMode.Repeating); overload;
    constructor Create(const AImage: TBLImage; const AArea: TBLRectI;
      const AExtendMode: TBLExtendMode; const ATransform: TBLMatrix2D); overload;

    procedure Reset; inline;
    procedure Swap(var AOther: TBLPattern); inline;
    function Equals(const AOther: TBLPattern): Boolean; inline;

    procedure Make(const AImage: TBLImage;
      const AExtendMode: TBLExtendMode = TBLExtendMode.Repeating); overload; inline;
    procedure Make(const AImage: TBLImage; const AExtendMode: TBLExtendMode;
      const ATransform: TBLMatrix2D); overload; inline;
    procedure Make(const AImage: TBLImage; const AArea: TBLRectI;
      const AExtendMode: TBLExtendMode = TBLExtendMode.Repeating); overload; inline;
    procedure Make(const AImage: TBLImage; const AArea: TBLRectI;
      const AExtendMode: TBLExtendMode; const ATransform: TBLMatrix2D); overload; inline;

    procedure SetImage(const AValue: TBLImage; const AArea: TBLRectI); overload; inline;

    /// <summary>
    ///  Resets pattern image to empty image and clears pattern area rectangle
    ///  to [0, 0, 0, 0].
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ResetImage; inline;

    /// <summary>
    ///  Updates the pattern area rectangle to [0, 0, Image.Width, Image.Height].
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ResetArea; inline;

    procedure ResetExtendMode; inline;

    procedure ResetTransform; inline;

    procedure Translate(const AX, AY: Double); overload; inline;
    procedure Translate(const AP: TBLPoint); overload; inline;
    procedure Translate(const AP: TBLPointI); overload; inline;

    procedure Scale(const AXY: Double); overload; inline;
    procedure Scale(const AX, AY: Double); overload; inline;
    procedure Scale(const AP: TBLPoint); overload; inline;
    procedure Scale(const AP: TBLPointI); overload; inline;

    procedure Skew(const AX, AY: Double); overload; inline;
    procedure Skew(const AP: TBLPoint); overload; inline;

    procedure Rotate(const AAngle: Double); overload; inline;
    procedure Rotate(const AAngle, AX, AY: Double); overload; inline;
    procedure Rotate(const AAngle: Double; const AOrigin: TBLPoint); overload; inline;
    procedure Rotate(const AAngle: Double; const AOrigin: TBLPointI); overload; inline;

    procedure ApplyTransform(const ATransform: TBLMatrix2D); inline;

    procedure PostTranslate(const AX, AY: Double); overload; inline;
    procedure PostTranslate(const AP: TBLPoint); overload; inline;
    procedure PostTranslate(const AP: TBLPointI); overload; inline;

    procedure PostScale(const AXY: Double); overload; inline;
    procedure PostScale(const AX, AY: Double); overload; inline;
    procedure PostScale(const AP: TBLPoint); overload; inline;
    procedure PostScale(const AP: TBLPointI); overload; inline;

    procedure PostSkew(const AX, AY: Double); overload; inline;
    procedure PostSkew(const AP: TBLPoint); overload; inline;

    procedure PostRotate(const AAngle: Double); overload; inline;
    procedure PostRotate(const AAngle, AX, AY: Double); overload; inline;
    procedure PostRotate(const AAngle: Double; const AOrigin: TBLPoint); overload; inline;
    procedure PostRotate(const AAngle: Double; const AOrigin: TBLPointI); overload; inline;

    procedure PostTransform(const ATransform: TBLMatrix2D); inline;

    property Image: TBLImage read GetImage write SetImage;
    property Area: TBLRectI read GetArea write SetArea;
    property ExtendMode: TBLExtendMode read GetExtendMode write SetExtendMode;
    property Transform: TBLMatrix2D read GetTransform write SetTransform;
    property TransformKind: TBLTransformKind read GetTransformKind;
    property HasTransform: Boolean read GetHasTransform;
  end;

{ ============================================================================
   [Styling - Gradients]
  ============================================================================ }

type
  /// <summary>
  ///  Gradient type.
  /// </summary>
  TBLGradientKind = (
    /// <summary>
    ///  Linear gradient type.
    /// </summary>
    Linear,

    /// <summary>
    ///  Radial gradient type.
    /// </summary>
    Radial,

    /// <summary>
    ///  Conic gradient type.
    /// </summary>
    Conic);

type
  /// <summary>
  ///  Gradient data index.
  /// </summary>
  TBLGradientValue = (
    /// <summary>
    ///  X0 - start 'X' for a Linear gradient and `X` center for both Radial and
    ///  Conic gradients.
    /// </summary>
    CommonX0,

    /// <summary>
    ///  Y0 - start 'Y' for a Linear gradient and `Y` center for both Radial and
    ///  Conic gradients.
    /// </summary>
    CommonY0,

    /// <summary>
    ///  X1 - end 'X' for a Linear gradient and focal point `X` for a Radial
    ///  gradient.
    /// </summary>
    CommonX1,

    /// <summary>
    ///  Y1 - end 'Y' for a Linear/gradient and focal point `Y` for a Radial
    ///  gradient.
    /// </summary>
    CommonY1,

    /// <summary>
    ///  Radial gradient center radius.
    /// </summary>
    RadialR0,

    /// <summary>
    ///  Radial gradient focal radius.
    /// </summary>
    RadialR1,

    /// <summary>
    ///  Conic gradient angle.
    /// </summary>
    ConicAngle = 2,

    /// <summary>
    ///  Conic gradient angle.
    /// </summary>
    ConicRepeat = 3);

type
  /// <summary>
  ///  Gradient rendering quality.
  /// </summary>
  TBLGradientQuality = (
    /// <summary>
    ///  Nearest neighbor.
    /// </summary>
    Nearest,

    /// <summary>
    ///  Use smoothing, if available (currently never available).
    /// </summary>
    Smooth,

    /// <summary>
    ///  The renderer will use an implementation-specific dithering algorithm to
    ///  prevent banding.
    /// </summary>
    Dither);

type
  /// <summary>
  ///  Defines an `Offset` and `Rgba` color that is used by `TBLGradient` to
  ///  define a linear transition between colors.
  /// </summary>
  /// <seealso cref="TBLGradient"/>
  TBLGradientStop = record
  public
    Offset: Double;
    Rgba: TBLRgba64;
  public
    class function Create: TBLGradientStop; overload; inline; static;
    constructor Create(const AOffset: Double; const ARgba32: TBLRgba32); overload;
    constructor Create(const AOffset: Double; const ARgba64: TBLRgba64); overload;
    constructor Create(const AOffset: Double; const AColor: TAlphaColor); overload;

    class operator Equal(const ALeft, ARight: TBLGradientStop): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLGradientStop): Boolean; inline; static;

    procedure Reset; overload; inline;
    procedure Reset(const AOffset: Double; const ARgba32: TBLRgba32); overload; inline;
    procedure Reset(const AOffset: Double; const ARgba64: TBLRgba64); overload; inline;
    procedure Reset(const AOffset: Double; const AColor: TAlphaColor); overload; inline;

    function Equals(const AOther: TBLGradientStop): Boolean; inline;
  end;
  {$POINTERMATH ON}
  PBLGradientStop = ^TBLGradientStop;
  {$POINTERMATH OFF}

function BLGradientStop: TBLGradientStop; overload; inline;
function BLGradientStop(const AOffset: Double; const ARgba32: TBLRgba32): TBLGradientStop; overload; inline;
function BLGradientStop(const AOffset: Double; const ARgba64: TBLRgba64): TBLGradientStop; overload; inline;
function BLGradientStop(const AOffset: Double; const AColor: TAlphaColor): TBLGradientStop; overload; inline;

type
  /// <summary>
  ///  Linear gradient values packed into a structure.
  /// </summary>
  TBLLinearGradientValues = record
  public
    X0: Double;
    Y0: Double;
    X1: Double;
    Y1: Double;
  public
    class function Create: TBLLinearGradientValues; overload; inline; static;
    constructor Create(const AX0, AY0, AX1, AY1: Double); overload;

    procedure Reset; overload; inline;
    procedure Reset(const AX0, AY0, AX1, AY1: Double); overload; inline;
  end;
  PBLLinearGradientValues = ^TBLLinearGradientValues;

function BLLinearGradientValues: TBLLinearGradientValues; overload; inline;
function BLLinearGradientValues(const AX0, AY0, AX1, AY1: Double): TBLLinearGradientValues; overload; inline;

type
  /// <summary>
  ///  Radial gradient values packed into a structure.
  /// </summary>
  TBLRadialGradientValues = record
  public
    X0: Double;
    Y0: Double;
    X1: Double;
    Y1: Double;
    R0: Double;
    R1: Double;
  public
    class function Create: TBLRadialGradientValues; overload; inline; static;
    constructor Create(const AX0, AY0, AX1, AY1, AR0: Double;
      const AR1: Double = 0); overload;

    procedure Reset; overload; inline;
    procedure Reset(const AX0, AY0, AX1, AY1, AR0: Double;
      const AR1: Double = 0); overload; inline;
  end;
  PBLRadialGradientValues = ^TBLRadialGradientValues;

function BLRadialGradientValues: TBLRadialGradientValues; overload; inline;
function BLRadialGradientValues(const AX0, AY0, AX1, AY1, AR0: Double;
  const AR1: Double = 0): TBLRadialGradientValues; overload; inline;

type
  /// <summary>
  ///  Conic gradient values packed into a structure.
  /// </summary>
  TBLConicGradientValues = record
  public
    X0: Double;
    Y0: Double;
    Angle: Double;
    Repetition: Double;
  public
    class function Create: TBLConicGradientValues; overload; inline; static;
    constructor Create(const AX0, AY0, AAngle: Double;
      const ARepeat: Double = 1); overload;

    procedure Reset; overload; inline;
    procedure Reset(const AX0, AY0, AAngle: Double;
      const ARepeat: Double = 1); overload; inline;
  end;
  PBLConicGradientValues = ^TBLConicGradientValues;

function BLConicGradientValues: TBLConicGradientValues; overload; inline;
function BLConicGradientValues(const AX0, AY0, AAngle: Double;
  const ARepeat: Double = 1): TBLConicGradientValues; overload; inline;

type
  /// <summary>
  ///  Gradient.
  /// </summary>
  TBLGradient = record
  {$REGION 'Internal Declarations'}
  private type
    TImpl = record
    public
      Stops: PBLGradientStop;
      Size: Size_T;
      Capacity: Size_T;
      Transform: TBLMatrix2D;
      case Byte of
        0: (Values: array [TBLGradientValue] of Double);
        1: (Linear: TBLLinearGradientValues);
        2: (Radial: TBLRadialGradientValues);
        3: (Conic: TBLConicGradientValues);
    end;
    PImpl = ^TImpl;
  private
    FBase: TBLObjectCore;
    function GetKind: TBLGradientKind; inline;
    procedure SetKind(const AValue: TBLGradientKind); inline;
    function GetExtendMode: TBLExtendMode; inline;
    procedure SetExtendMode(const AValue: TBLExtendMode); inline;
    function GetValue(const AIndex: NativeInt): Double; inline;
    procedure SetValue(const AIndex: NativeInt; const AValue: Double); inline;
    function GetLinear: TBLLinearGradientValues; inline;
    procedure SetLinear(const AValue: TBLLinearGradientValues); inline;
    function GetRadial: TBLRadialGradientValues; inline;
    procedure SetRadial(const AValue: TBLRadialGradientValues); inline;
    function GetConic: TBLConicGradientValues; inline;
    procedure SetConic(const AValue: TBLConicGradientValues); inline;
    function GetX0: Double; inline;
    procedure SetX0(const AValue: Double); inline;
    function GetY0: Double; inline;
    procedure SetY0(const AValue: Double); inline;
    function GetX1: Double; inline;
    procedure SetX1(const AValue: Double); inline;
    function GetY1: Double; inline;
    procedure SetY1(const AValue: Double); inline;
    function GetR0: Double; inline;
    procedure SetR0(const AValue: Double); inline;
    function GetR1: Double; inline;
    procedure SetR1(const AValue: Double); inline;
    function GetAngle: Double; inline;
    procedure SetAngle(const AValue: Double); inline;
    function GetConicAngle: Double; inline;
    procedure SetConicAngle(const AValue: Double); inline;
    function GetConicRepeat: Double; inline;
    procedure SetConicRepeat(const AValue: Double); inline;
    function GetIsEmpty: Boolean; inline;
    function GetCount: NativeInt; inline;
    function GetCapacity: NativeInt; inline;
    function GetStopData: PBLGradientStop; inline;
    function GetStop(const AIndex: NativeInt): TBLGradientStop; inline;
    function GetTransform: TBLMatrix2D; inline;
    procedure SetTransform(const AValue: TBLMatrix2D); inline;
    function GetTransformKind: TBLTransformKind; inline;
    function GetHasTransform: Boolean; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Creates a default constructed gradient.
    ///
    ///  A default constructed gradient has `TBLGradientKind.Linear` type, all
    ///  values set to zero, and has no color stops.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Initialize(out ADest: TBLGradient);

    /// <summary>
    ///  Destroys the gradient.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Finalize(var ADest: TBLGradient);

    /// <summary>
    ///  Copy constructor creates a weak copy of `ASrc`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Assign(var ADest: TBLGradient; const [ref] ASrc: TBLGradient); inline;

    /// <summary>
    ///  Used to compare against `nil`.
    /// </summary>
    class operator Equal(const ALeft: TBLGradient; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Equality operator, performs the same operation as `ALeft.Equals(ARight)`.
    /// </summary>
    class operator Equal(const ALeft, ARight: TBLGradient): Boolean; inline; static;

    /// <summary>
    ///  Used to compare against `nil`.
    /// </summary>
    class operator NotEqual(const ALeft: TBLGradient; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Equality operator, performs the same operation as `not ALeft.Equals(ARight)`.
    /// </summary>
    class operator NotEqual(const ALeft, ARight: TBLGradient): Boolean; inline; static;

    constructor Create(const AKind: TBLGradientKind;
      const AValues: TArray<Double>); overload;
    constructor Create(const AKind: TBLGradientKind;
      const AValues: PDouble = nil); overload;

    constructor Create(const AValues: TBLLinearGradientValues;
      const AExtendMode: TBLExtendMode = TBLExtendMode.Pad); overload;
    constructor Create(const AValues: TBLRadialGradientValues;
      const AExtendMode: TBLExtendMode = TBLExtendMode.Pad); overload;
    constructor Create(const AValues: TBLConicGradientValues;
      const AExtendMode: TBLExtendMode = TBLExtendMode.Pad); overload;

    constructor Create(const AValues: TBLLinearGradientValues;
      const AExtendMode: TBLExtendMode; const AStops: TArray<TBLGradientStop>); overload;
    constructor Create(const AValues: TBLRadialGradientValues;
      const AExtendMode: TBLExtendMode; const AStops: TArray<TBLGradientStop>); overload;
    constructor Create(const AValues: TBLConicGradientValues;
      const AExtendMode: TBLExtendMode; const AStops: TArray<TBLGradientStop>); overload;

    constructor Create(const AValues: TBLLinearGradientValues;
      const AExtendMode: TBLExtendMode; const AStops: TArray<TBLGradientStop>;
      const ATransform: TBLMatrix2D); overload;
    constructor Create(const AValues: TBLRadialGradientValues;
      const AExtendMode: TBLExtendMode; const AStops: TArray<TBLGradientStop>;
      const ATransform: TBLMatrix2D); overload;
    constructor Create(const AValues: TBLConicGradientValues;
      const AExtendMode: TBLExtendMode; const AStops: TArray<TBLGradientStop>;
      const ATransform: TBLMatrix2D); overload;

    /// <summary>
    ///  Resets the gradient to its construction state.
    /// </summary>
    procedure Reset; inline;

    /// <summary>
    ///  Swaps this gradient with `AOther`.
    /// </summary>
    procedure Swap(var AOther: TBLGradient); inline;

    procedure Make(const AValues: TBLLinearGradientValues;
      const AExtendMode: TBLExtendMode = TBLExtendMode.Pad); overload; inline;
    procedure Make(const AValues: TBLRadialGradientValues;
      const AExtendMode: TBLExtendMode = TBLExtendMode.Pad); overload; inline;
    procedure Make(const AValues: TBLConicGradientValues;
      const AExtendMode: TBLExtendMode = TBLExtendMode.Pad); overload; inline;

    procedure Make(const AValues: TBLLinearGradientValues;
      const AExtendMode: TBLExtendMode; const AStops: TArray<TBLGradientStop>); overload; inline;
    procedure Make(const AValues: TBLRadialGradientValues;
      const AExtendMode: TBLExtendMode; const AStops: TArray<TBLGradientStop>); overload; inline;
    procedure Make(const AValues: TBLConicGradientValues;
      const AExtendMode: TBLExtendMode; const AStops: TArray<TBLGradientStop>); overload; inline;

    procedure Make(const AValues: TBLLinearGradientValues;
      const AExtendMode: TBLExtendMode; const AStops: TArray<TBLGradientStop>;
      const ATransform: TBLMatrix2D); overload; inline;
    procedure Make(const AValues: TBLRadialGradientValues;
      const AExtendMode: TBLExtendMode; const AStops: TArray<TBLGradientStop>;
      const ATransform: TBLMatrix2D); overload; inline;
    procedure Make(const AValues: TBLConicGradientValues;
      const AExtendMode: TBLExtendMode; const AStops: TArray<TBLGradientStop>;
      const ATransform: TBLMatrix2D); overload; inline;

    /// <summary>
    ///  Resets the gradient extend mode to `TBLExtendMode.Pad`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="TBLExtendMode"/>
    procedure ResetExtendMode; inline;

    procedure SetValues(const AIndex: NativeInt; const AValues: TArray<Double>); overload; inline;
    procedure SetValues(const AIndex: NativeInt; const AValues: PDouble;
      const ACount: NativeInt); overload; inline;
    procedure SetValues(const AValues: TBLLinearGradientValues); overload; inline;
    procedure SetValues(const AValues: TBLRadialGradientValues); overload; inline;
    procedure SetValues(const AValues: TBLConicGradientValues); overload; inline;

    /// <summary>
    ///  Reserves the capacity of gradient for at least `AMinCapacity` stops.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Reserve(const AMinCapacity: NativeInt); inline;

    /// <summary>
    ///  Shrinks the capacity of gradient stops to fit the current use.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Shrink; inline;

    /// <summary>
    ///  Returns gradient stops and their count as `TBLArrayView<TBLGradientStop>`.
    /// </summary>
    function StopsView: TBLArrayView<TBLGradientStop>; inline;

    /// <summary>
    ///  Resets all stops of the gradient.
    ///
    ///  After the operation the gradient will have no color stops.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ResetStops; inline;

    /// <summary>
    ///  Assigns colors stops of the gradient to `AStops`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AssignStops(const AStops: TArray<TBLGradientStop>); overload; inline;

    /// <summary>
    ///  Assigns colors stops of the gradient to `AStops` of size `ACount`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AssignStops(const AStops: PBLGradientStop; const ACount: NativeInt); overload; inline;

    /// <summary>
    ///  Assigns colors stops of the gradient to `AStops`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AssignStops(const AStops: TBLArrayView<TBLGradientStop>); overload; inline;

    /// <summary>
    ///  Adds a color stop described as a 32-bit color `ARgba32` at the given
    ///  `AOffset`.
    /// </summary>
    /// <remarks>
    ///  The offset value must be in `[0, 1]` range.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddStop(const AOffset: Double; const ARgba32: TBLRgba32); overload; inline;

    /// <summary>
    ///  Adds a color stop described as a 64-bit color `ARgba64` at the given
    ///  `AOffset`.
    /// </summary>
    /// <remarks>
    ///  The offset value must be in `[0, 1]` range.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddStop(const AOffset: Double; const ARgba64: TBLRgba64); overload; inline;

    /// <summary>
    ///  Adds a color stop described as a `AColor` at the given `AOffset`.
    /// </summary>
    /// <remarks>
    ///  The offset value must be in `[0, 1]` range.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure AddStop(const AOffset: Double; const AColor: TAlphaColor); overload; inline;

    /// <summary>
    ///  Removes stop at the given `AIndex`.
    /// </summary>
    /// <remarks>
    ///  This method should be used together with `IndexOfStop`, which returns
    ///  index to the stop array.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="IndexOfStop"/>
    procedure RemoveStop(const AIndex: NativeInt); inline;

    /// <summary>
    ///  Removes stop at the given `AOffset`, which should be in `[0, 1]` range.
    ///
    ///  The `AAll` parameter specifies whether all stops at the given offset
    ///  should be removed as there are cases in which two stops can occupy the
    ///  same offset to create sharp transitions. If `AAll` is False and there
    ///  is a sharp transition only the first stop would be removed. If `AAll`
    ///  is True both stops will be removed.
    /// </summary>
    /// <remarks>
    ///  There are never 3 stops occupying the same `AOffset`.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure RemoveStopByOffset(const AOffset: Double;
      const AAll: Boolean = True); inline;

    /// <summary>
    ///  Removes all stops in the given range, which describes indexes in the
    ///  stop array.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure RemoveStops(const ARange: TBLRange); inline;

    /// <summary>
    ///  Removes all stops in the given interval `[AOffsetMin, AOffsetMax]`,
    ///  which specifies stop offsets, which are between [0, 1].
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure RemoveStopsByOffset(const AOffsetMin, AOffsetMax: Double); inline;

    /// <summary>
    ///  Replaces stop at the given `AIndex` with a new color stop described by
    ///  `AOffset` and `ARgba32`.
    ///
    ///  The operation leads to the same result as `RemoveStop(AIndex)` followed
    ///  by `AddStop(AOffset, ARgba32)`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="RemoveStop"/>
    /// <seealso cref="AddStop"/>
    procedure ReplaceStop(const AIndex: NativeInt; const AOffset: Double;
      const ARgba32: TBLRgba32); overload; inline;

    /// <summary>
    ///  Replaces stop at the given `AIndex` with a new color stop described by
    ///  `AOffset` and `ARgba64`.
    ///
    ///  The operation leads to the same result as `RemoveStop(AIndex)` followed
    ///  by `AddStop(AOffset, ARgba64)`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="RemoveStop"/>
    /// <seealso cref="AddStop"/>
    procedure ReplaceStop(const AIndex: NativeInt; const AOffset: Double;
      const ARgba64: TBLRgba64); overload; inline;

    /// <summary>
    ///  Replaces stop at the given `AIndex` with a new color stop described by
    ///  `AOffset` and `AColor`.
    ///
    ///  The operation leads to the same result as `RemoveStop(AIndex)` followed
    ///  by `AddStop(AOffset, AColor)`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="RemoveStop"/>
    /// <seealso cref="AddStop"/>
    procedure ReplaceStop(const AIndex: NativeInt; const AOffset: Double;
      const AColor: TAlphaColor); overload; inline;

    /// <summary>
    ///  Returns the index of a color stop in Stops array of the given `AOffset`.
    /// </summary>
    /// <remarks>
    ///  If there is no such offset, `-1` is returned.
    /// </remarks>
    function IndexOfStop(const AOffset: Double): NativeInt; inline;

    /// <summary>
    ///  Tests whether the gradient equals `AOther`.
    /// </summary>
    /// <remarks>
    ///  The equality check returns True if both gradients are the same value-wise.
    /// </remarks>
    function Equals(const AOther: TBLGradient): Boolean; inline;

    procedure ResetTransform; inline;

    procedure Translate(const AX, AY: Double); overload; inline;
    procedure Translate(const AP: TBLPoint); overload; inline;
    procedure Translate(const AP: TBLPointI); overload; inline;

    procedure Scale(const AXY: Double); overload; inline;
    procedure Scale(const AX, AY: Double); overload; inline;
    procedure Scale(const AP: TBLPoint); overload; inline;
    procedure Scale(const AP: TBLPointI); overload; inline;

    procedure Skew(const AX, AY: Double); overload; inline;
    procedure Skew(const AP: TBLPoint); overload; inline;

    procedure Rotate(const AAngle: Double); overload; inline;
    procedure Rotate(const AAngle, AX, AY: Double); overload; inline;
    procedure Rotate(const AAngle: Double; const AOrigin: TBLPoint); overload; inline;
    procedure Rotate(const AAngle: Double; const AOrigin: TBLPointI); overload; inline;

    procedure ApplyTransform(const ATransform: TBLMatrix2D); inline;

    procedure PostTranslate(const AX, AY: Double); overload; inline;
    procedure PostTranslate(const AP: TBLPoint); overload; inline;
    procedure PostTranslate(const AP: TBLPointI); overload; inline;

    procedure PostScale(const AXY: Double); overload; inline;
    procedure PostScale(const AX, AY: Double); overload; inline;
    procedure PostScale(const AP: TBLPoint); overload; inline;
    procedure PostScale(const AP: TBLPointI); overload; inline;

    procedure PostSkew(const AX, AY: Double); overload; inline;
    procedure PostSkew(const AP: TBLPoint); overload; inline;

    procedure PostRotate(const AAngle: Double); overload; inline;
    procedure PostRotate(const AAngle, AX, AY: Double); overload; inline;
    procedure PostRotate(const AAngle: Double; const AOrigin: TBLPoint); overload; inline;
    procedure PostRotate(const AAngle: Double; const AOrigin: TBLPointI); overload; inline;

    procedure PostTransform(const ATransform: TBLMatrix2D); inline;

    /// <summary>
    ///  The type of the gradient.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property Kind: TBLGradientKind read GetKind write SetKind;

    /// <summary>
    ///  The gradient extend mode.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property ExtendMode: TBLExtendMode read GetExtendMode write SetExtendMode;

    property Values[const AIndex: NativeInt]: Double read GetValue write SetValue;

    property Linear: TBLLinearGradientValues read GetLinear write SetLinear;
    property Radial: TBLRadialGradientValues read GetRadial write SetRadial;
    property Conic: TBLConicGradientValues read GetConic write SetConic;

    property X0: Double read GetX0 write SetX0;
    property Y0: Double read GetY0 write SetY0;
    property X1: Double read GetX1 write SetX1;
    property Y1: Double read GetY1 write SetY1;
    property R0: Double read GetR0 write SetR0;
    property R1: Double read GetR1 write SetR1;
    property Angle: Double read GetAngle write SetAngle;
    property ConicAngle: Double read GetConicAngle write SetConicAngle;
    property ConicRepeat: Double read GetConicRepeat write SetConicRepeat;

    /// <summary>
    ///  Whether the gradient is empty.
    ///
    ///  Empty gradient is considered any gradient that has no stops.
    /// </summary>
    property IsEmpty: Boolean read GetIsEmpty;

    /// <summary>
    ///  The number of stops the gradient has.
    /// </summary>
    property Count: NativeInt read GetCount;

    /// <summary>
    ///  The gradient capacity [in stops].
    /// </summary>
    property Capacity: NativeInt read GetCapacity;

    /// <summary>
    ///  The gradient stop data.
    /// </summary>
    property StopData: PBLGradientStop read GetStopData;

    /// <summary>
    ///  Gradient stop at `AIndex`.
    /// </summary>
    property Stops[const AIndex: NativeInt]: TBLGradientStop read GetStop;

    /// <summary>
    ///  The transformation matrix applied to the gradient.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property Transform: TBLMatrix2D read GetTransform write SetTransform;

    /// <summary>
    ///  Returns the type of the transformation matrix returned by `Transform`.
    /// </summary>
    /// <seealso cref="Transform"/>
    property TransformKind: TBLTransformKind read GetTransformKind;

    /// <summary>
    ///  Tests whether the gradient has a non-identity transformation matrix.
    /// </summary>
    property HasTransform: Boolean read GetHasTransform;
  end;

{$ENDREGION 'Styling'}

{$REGION 'Text'}

{ ============================================================================
   [Text - Text]
  ============================================================================ }

type
  /// <summary>
  ///  Orientation.
  /// </summary>
  TBLOrientation = (
    /// <summary>
    ///  Horizontal orientation.
    /// </summary>
    Horizontal,

    /// <summary>
    ///  Vertical orientation.
    /// </summary>
    Vertical);

type
  /// <summary>
  ///  Text direction.
  /// </summary>
  TBLTextDirection = (
    /// <summary>
    ///  Left-to-right direction.
    /// </summary>
    LeftToRight,

    /// <summary>
    ///  Right-to-left direction.
    /// </summary>
    RightToLeft);

type
  /// <summary>
  ///  Text encoding.
  /// </summary>
  TBLTextEncoding = (
    /// <summary>
    ///  UTF-8 encoding.
    /// </summary>
    Utf8,

    /// <summary>
    ///  UTF-16 encoding.
    /// </summary>
    Utf16,

    /// <summary>
    ///  UTF-32 encoding.
    /// </summary>
    Utf32,

    /// <summary>
    ///  LATIN1 encoding (one byte per character).
    /// </summary>
    Latin1);

type
  /// <summary>
  ///  Text metrics.
  /// </summary>
  TBLTextMetrics = record
  {$REGION 'Internal Declarations'}
  private
    FAdvance: TBLPoint;
    FLeadingBearing: TBLPoint;
    FTrailingBearing: TBLPoint;
    FBoundingBox: TBLBox;
  {$ENDREGION 'Internal Declarations'}
  public
    procedure Reset; inline;

    property Advance: TBLPoint read FAdvance;
    property LeadingBearing: TBLPoint read FLeadingBearing;
    property TrailingBearing: TBLPoint read FTrailingBearing;
    property BoundingBox: TBLBox read FBoundingBox;
  end;
  PBLTextMetrics = ^TBLTextMetrics;

{ ============================================================================
   [Text - Glyph Containers & Processing]
  ============================================================================ }

type
  /// <summary>
  ///  Flags used by `TBLGlyphRun`.
  /// </summary>
  /// <seealso cref="TBLGlyphRun"/>
  TBLGlyphRunFlag = (
    _Reserved = 0,

    /// <summary>
    ///  Glyph-run contains UCS-4 string and not glyphs (glyph-buffer only).
    /// </summary>
    Ucs4Content = 28,

    /// <summary>
    ///  Glyph-run was created from text that was not a valid unicode.
    /// </summary>
    InvalidText = 29,

    /// <summary>
    ///  Not the whole text was mapped to glyphs (contains undefined glyphs).
    /// </summary>
    UndefinedGlyphs = 30,

    /// <summary>
    ///  Encountered invalid font data during text / glyph processing.
    /// </summary>
    InvalidFontData = 31);

  /// <summary>
  ///  Flags used by `TBLGlyphRun`.
  /// </summary>
  /// <seealso cref="TBLGlyphRun"/>
  TBLGlyphRunFlags = set of TBLGlyphRunFlag;

  /// <summary>
  ///  Adds functionality to `TBLGlyphRunFlags`.
  /// </summary>
  _TBLGlyphRunFlagsHelper = record helper for TBLGlyphRunFlags
  public const
    /// <summary>
    ///  No flags.
    /// </summary>
    None = [];
  end;

type
  /// <summary>
  ///  Placement of glyphs stored in a `TBLGlyphRun`.
  /// </summary>
  /// <seealso cref="TBLGlyphRun"/>
  TBLGlyphPlacementType = (
    /// <summary>
    ///  No placement (custom handling by `TBLPathSinkFunc`).
    /// </summary>
    None,

    /// <summary>
    ///  Each glyph has a TBLGlyphPlacement (advance + offset).
    /// </summary>
    AdvanceOffset,

    /// <summary>
    ///  Each glyph has a TBLPoint offset in design-space units.
    /// </summary>
    DesignUnits,

    /// <summary>
    ///  Each glyph has a TBLPoint offset in user-space units.
    /// </summary>
    UserUnits,

    /// <summary>
    ///  Each glyph has a TBLPoint offset in absolute units.
    /// </summary>
    AbsoluteUnits);

type
  /// <summary>
  ///  Glyph id - a 32-bit unsigned integer.
  /// </summary>
  TBLGlyphId = UInt32;

  {$POINTERMATH ON}
  PBLGlyphId = ^TBLGlyphId;
  {$POINTERMATH OFF}

type
  /// <summary>
  ///  Glyph placement.
  ///
  ///  Provides information about glyph offset (X/Y) and advance (X/Y).
  /// </summary>
  TBLGlyphPlacement = record
  public
    Placement: TBLPointI;
    Advance: TBLPointI;
  public
    procedure Reset; inline;
  end;
  PBLGlyphPlacement = ^TBLGlyphPlacement;

type
  /// <summary>
  ///  TBLGlyphRun describes a set of consecutive glyphs and their placements.
  ///
  ///  TBLGlyphRun should only be used to pass glyph IDs and their placements to
  ///  the rendering context. The purpose of TBLGlyphRun is to allow rendering
  ///  glyphs, which could be shaped by various shaping engines (Blend2D,
  ///  Harfbuzz, etc).
  ///
  ///  TBLGlyphRun allows to render glyphs that are stored as UInt32[] array or
  ///  part of a bigger structure (for example `hb_glyph_info_t` used by
  ///  HarfBuzz). Glyph placements at the moment use Blend2D's
  ///  `TBLGlyphPlacement` or `TBLPoint`, but it's possible to extend the data
  ///  type in the future.
  /// </summary>
  /// <seealso cref="TBLGlyphPlacement"/>
  /// <seealso cref="TBLPoint"/>
  TBLGlyphRun = record
  {$REGION 'Internal Declarations'}
  private
    FGlyphData: Pointer;
    FPlacementData: Pointer;
    FCount: Size_T;
    {$HINTS OFF}
    FReserved: UInt8;
    {$HINTS ON}
    FPlacementType: UInt8;
    FGlyphAdvance: Int8;
    FPlacementAdvance: Int8;
    FFlags: UInt32;
    function GetGlyphDataAsGlyphIds: PBLGlyphId; inline;
    function GetPlacementDataAsGlyphPlacements: PBLGlyphPlacement; inline;
    function GetPlacementDataAsPoints: PBLPoint; inline;
    function GetFlags: TBLGlyphRunFlags; inline;
    function GetPlacementType: TBLGlyphPlacementType; inline;
    function GetCount: NativeInt; inline;
    function GetIsEmpty: Boolean; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    procedure Reset; inline;

    procedure SetGlyphData(const AGlyphData: PBLGlyphId); overload; inline;
    procedure SetGlyphData(const AData: Pointer; const AAdvance: ShortInt); overload; inline;
    procedure ResetGlyphIdData; inline;

    procedure SetPlacementData(const AData: PBLGlyphPlacement); overload; inline;
    procedure SetPlacementData(const AData: PBLPoint); overload; inline;
    procedure SetPlacementData(const AData: Pointer; const AAdvance: ShortInt); overload; inline;
    procedure ResetPlacementData; inline;

    /// <summary>
    ///  Glyph id data (abstract, incremented by `GlyphAdvance`).
    /// </summary>
    property GlyphData: Pointer read FGlyphData;

    property GlyphDataAsGlyphIds: PBLGlyphId read GetGlyphDataAsGlyphIds;

    /// <summary>
    ///  Glyph placement data (abstract, incremented by `PlacementAdvance`).
    /// </summary>
    property PlacementData: Pointer read FPlacementData;

    property PlacementDataAsGlyphPlacements: PBLGlyphPlacement read GetPlacementDataAsGlyphPlacements;
    property PlacementDataAsPoints: PBLPoint read GetPlacementDataAsPoints;

    /// <summary>
    ///  Size of the glyph-run in glyph units.
    /// </summary>
    property Count: NativeInt read GetCount;

    /// <summary>
    ///  Type of placement.
    /// </summary>
    property PlacementType: TBLGlyphPlacementType read GetPlacementType;

    /// <summary>
    ///  Advance of `GlyphData` array.
    /// </summary>
    property GlyphAdvance: ShortInt read FGlyphAdvance;

    /// <summary>
    ///  Advance of `PlacementData` array.
    /// </summary>
    property PlacementAdvance: ShortInt read FPlacementAdvance;

    /// <summary>
    ///  Glyph-run flags.
    /// </summary>
    property Flags: TBLGlyphRunFlags read GetFlags;

    property IsEmpty: Boolean read GetIsEmpty;
  end;
  PBLGlyphRun = ^TBLGlyphRun;

type
  /// <summary>
  ///  A helper to iterate over a `TBLGlyphRun`.
  ///
  ///  Takes into consideration glyph-id advance and glyph-offset advance.
  ///
  ///  Example:
  ///
  ///  ```Delphi
  ///  procedure InspectGlyphRun(const AGlyphRun: TBLGlyphRun);
  ///  begin
  ///    var It := TBLGlyphRunIterator.Create(AGlyphRun);
  ///    if (It.HasPlacement) then
  ///    begin
  ///      while (not It.AtEnd) do
  ///      begin
  ///        var GlyphId := It.GlyphId;
  ///        var Offset := It.Placement<TBLPoint>;
  ///
  ///        // Do something with `GlyphId` and `Offset`.
  ///
  ///        It.Advance;
  ///      end;
  ///    end
  ///    else
  ///    begin
  ///      while (not It.AtEnd) do
  ///      begin
  ///        var GlyphId := It.GlyphId;
  ///
  ///        // Do something with `GlyphId`.
  ///
  ///        It.Advance;
  ///      end;
  ///    end;
  ///  end;
  ///  ```
  /// </summary>
  TBLGlyphRunIterator = record
  {$REGION 'Internal Declarations'}
  private
    FIndex: NativeInt;
    FCount: NativeInt;
    FGlyphData: Pointer;
    FPlacementData: Pointer;
    FGlyphAdvance: NativeInt;
    FPlacementAdvance: NativeInt;
    function GetIsEmpty: Boolean; inline;
    function GetHasPlacement: Boolean; inline;
    function GetGlyphId: TBLGlyphId; inline;
    function GetPlacementAsPoint: TBLPoint; inline;
    function GetPlacementAsGlyphPlacement: TBLGlyphPlacement; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    class operator Initialize(out ADest: TBLGlyphRunIterator);
    constructor Create(const AGlyphRun: TBLGlyphRun);

    procedure Reset; overload;inline;
    procedure Reset(const AGlyphRun: TBLGlyphRun); overload;inline;

    procedure Advance; inline;
    function AtEnd: Boolean; inline;
    function Placement<T: record>: T; inline;

    property IsEmpty: Boolean read GetIsEmpty;
    property HasPlacement: Boolean read GetHasPlacement;
    property GlyphId: TBLGlyphId read GetGlyphId;
    property PlacementAsPoint: TBLPoint read GetPlacementAsPoint;
    property PlacementAsGlyphPlacement: TBLGlyphPlacement read GetPlacementAsGlyphPlacement;
  end;

type
  /// <summary>
  ///  Contains additional information associated with a glyph used by
  ///  `TBLGlyphBuffer`.
  /// </summary>
  /// <seealso cref="TBLGlyphBuffer"/>
  TBLGlyphInfo = record
  {$REGION 'Internal Declarations'}
  private
    FCluster: UInt32;
    FReserved: UInt32;
  {$ENDREGION 'Internal Declarations'}
  public
    procedure Reset; inline;

    property Cluster: UInt32 read FCluster;
  end;
  PBLGlyphInfo = ^TBLGlyphInfo;

type
  /// <summary>
  ///  Glyph buffer.
  ///
  ///  Can hold either text or glyphs and provides basic memory management that
  ///  is used for text shaping, character to glyph mapping, glyph substitution,
  ///  and glyph positioning.
  ///
  ///  Glyph buffer provides two separate buffers called 'Primary' and
  ///  'Secondary' that serve different purposes during processing. Primary
  ///  buffer always holds actual text/glyph array, and secondary buffer is
  ///  either used as a scratch buffer during glyph substitution or to hold
  ///  glyph positions after the processing is complete and glyph positions
  ///  were calculated.
  /// </summary>
  TBLGlyphBuffer = record
  {$REGION 'Internal Declarations'}
  private type
    TImpl = record
    public
      case Byte of
        0: (Content: PUInt32;
            PlacementData: PBLGlyphPlacement;
            Size: Size_T;
            Reserved: UInt32;
            Flags: UInt32);
        1: (GlyphRun: TBLGlyphRun;
            InfoData: PBLGlyphInfo);
    end;
    PImpl = ^TImpl;
  private
    FBase: TBLObjectCore;
    function GetIsEmpty: Boolean; inline;
    function GetCount: NativeInt; inline;
    function GetFlags: TBLGlyphRunFlags; inline;
    function GetContent: PUInt32; inline;
    function GetInfoData: PBLGlyphInfo; inline;
    function GetPlacementData: PBLGlyphPlacement; inline;
    function GetGlyphRun: TBLGlyphRun; inline;
    function GetHasText: Boolean; inline;
    function GetHasGlyphs: Boolean; inline;
    function GetHasInvalidChars: Boolean; inline;
    function GetHasUndefinedChars: Boolean; inline;
    function GetHasInvalidFontData: Boolean; inline;
  private
    class function ConvertSize(const ASize: NativeInt): Size_T; inline; static;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Creates a default constructed glyph buffer.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Initialize(out ADest: TBLGlyphBuffer);

    /// <summary>
    ///  Destroys the glyph buffer.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Finalize(var ADest: TBLGlyphBuffer);

    /// <summary>
    ///  Copying a glyph buffer is not allowed. This will raise a
    ///  `EBlend2DError` exception with result `TBLResult.NotPermitted`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Assign(var ADest: TBLGlyphBuffer; const [ref] ASrc: TBLGlyphBuffer); inline;

    /// <summary>
    ///  Used to compare against `nil`.
    /// </summary>
    class operator Equal(const ALeft: TBLGlyphBuffer; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Used to compare against `nil`.
    /// </summary>
    class operator NotEqual(const ALeft: TBLGlyphBuffer; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Tests whether the glyph-buffer has `AFlag` set.
    /// </summary>
    function HasFlag(const AFlag: TBLGlyphRunFlag): Boolean; inline;

    /// <summary>
    ///  Resets the `TBLGlyphBuffer` into its default constructed state. The
    ///  content will be cleared and allocated memory released.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Reset; inline;

    /// <summary>
    ///  Clears the content of `TBLGlyphBuffer` without releasing internal
    ///  buffers.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Clear; inline;

    /// <summary>
    ///  Assigns a text content of this `TBLGlyphBuffer`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetText(const AText: String); overload; inline;

    /// <summary>
    ///  Assigns a text content of this `TBLGlyphBuffer`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetText(const AText: UTF8String); overload; inline;

    /// <summary>
    ///  Assigns a text content of this `TBLGlyphBuffer`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetText(const AText: UCS4String); overload; inline;

    /// <summary>
    ///  Assigns a text content of this `TBLGlyphBuffer`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetText(const AText: AnsiString); overload; inline;

    /// <summary>
    ///  Assigns a text content of this `TBLGlyphBuffer`.
    ///
    ///  This is a generic function that accepts a pointer to data, which is
    ///  specified by `AEncoding`. The `ASize` argument depends on encoding as
    ///  well. If the encoding specifies byte string (Latin1 or Utf8) then it's
    ///  bytes, if the encoding specifies Utf16 or Utf32 then it would describe
    ///  the number of `UInt16` or `UInt32` code points, respectively.
    ///
    ///  Null-terminated string can be specified by passing `-1` as `ASize`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetText(const ATextData: Pointer; const ASize: NativeInt;
      const AEncoding: TBLTextEncoding); overload; inline;

    /// <summary>
    ///  Assigns a text content of this `TBLGlyphBuffer` from LATIN1
    ///  (ISO/IEC 8859-1) string.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetLatin1Text(const AText: PAnsiChar; const ALength: NativeInt = -1); inline;

    /// <summary>
    ///  Assigns a text content of this `TBLGlyphBuffer` from UTF-8 encoded
    ///  string. The `ALength` parameter represents the length of the `AText` in
    ///  bytes.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetUtf8Text(const AText: PUTF8Char; const ALength: NativeInt = -1); inline;

    /// <summary>
    ///  Assigns a text content of this `TBLGlyphBuffer` from UTF-16 encoded
    ///  string. The `ALength` parameter represents the  length of the `AText`
    ///  in 16-bit units.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetUtf16Text(const AText: PWideChar; const ALength: NativeInt = -1); inline;

    /// <summary>
    ///  Assigns a text content of this `TBLGlyphBuffer` from UTF-32 encoded
    ///  string. The `ALength` parameter represents the length of the `AText` in
    ///  32-bit units.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetUtf32Text(const AText: PUCS4Char; const ALength: NativeInt = -1); inline;

    /// <summary>
    ///  Assigns a glyph content of this `TBLGlyphBuffer` from the given
    ///  `AGlyphData`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetGlyphs(const AGlyphData: TArray<UInt32>); overload; inline;

    /// <summary>
    ///  Assigns a glyph content of this `TBLGlyphBuffer` from the given
    ///  `AGlyphData`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetGlyphs(const AGlyphData: PUInt32; const ACount: NativeInt); overload; inline;

    /// <summary>
    ///  Assigns a glyph content of this `TBLGlyphBuffer` from an array of
    ///  glyphs or from a foreign record that contains glyphs and possibly other
    ///  members that have to be skipped. The glyph size can be either 16-bit
    ///  (2) or 32-bit (4). The last parameter `AGlyphAdvance` specifies how
    ///  many bytes to advance after a glyph value is read.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetGlyphsFromRecord(const AGlyphData: Pointer; const ACount,
      AGlyphIdSize, AGlyphAdvance: NativeInt); inline;

    procedure SetDebugSink(const ASink: TBLDebugMessageSinkFunc;
      const AUserData: Pointer = nil); inline;
    procedure ResetDebugSink; inline;

    property IsEmpty: Boolean read GetIsEmpty;
    property Count: NativeInt read GetCount;
    property Flags: TBLGlyphRunFlags read GetFlags;
    property Content: PUInt32 read GetContent;
    property InfoData: PBLGlyphInfo read GetInfoData;
    property PlacementData: PBLGlyphPlacement read GetPlacementData;
    property GlyphRun: TBLGlyphRun read GetGlyphRun;

    /// <summary>
    ///  Whether the buffer contains unicode data.
    /// </summary>
    property HasText: Boolean read GetHasText;

    /// <summary>
    ///  Whether the buffer contains glyph-id data.
    /// </summary>
    property HasGlyphs: Boolean read GetHasGlyphs;

    /// <summary>
    ///  Tests whether the input string contained invalid characters (unicode
    ///  encoding errors).
    /// </summary>
    property HasInvalidChars: Boolean read GetHasInvalidChars;

    /// <summary>
    ///  Whether the input string contained undefined characters that weren't
    ///  mapped properly to glyphs.
    /// </summary>
    property HasUndefinedChars: Boolean read GetHasUndefinedChars;

    /// <summary>
    ///  Whether one or more operation was terminated before completion because
    ///  of invalid data in a font.
    /// </summary>
    property HasInvalidFontData: Boolean read GetHasInvalidFontData;
  end;

type
  /// <summary>
  ///  Character to glyph mapping state.
  /// </summary>
  TBLGlyphMappingState = record
  {$REGION 'Internal Declarations'}
  private
    FGlyphCount: Size_T;
    FUndefinedFirst: Size_T;
    FUndefinedCount: Size_T;
    function GetGlyphCount: NativeInt; inline;
    function GetUndefinedFirst: NativeInt; inline;
    function GetUndefinedCount: NativeInt; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    procedure Reset; inline;

    /// <summary>
    ///  Number of glyphs or glyph-items on output.
    /// </summary>
    property GlyphCount: NativeInt read GetGlyphCount;

    /// <summary>
    ///  Index of the first undefined glyph (-1 if none).
    /// </summary>
    property UndefinedFirst: NativeInt read GetUndefinedFirst;

    /// <summary>
    ///  Undefined glyph count (chars that have no mapping).
    /// </summary>
    property UndefinedCount: NativeInt read GetUndefinedCount;
  end;
  PBLGlyphMappingState = ^TBLGlyphMappingState;

{ ============================================================================
   [Text - Fonts]
  ============================================================================ }

type
  /// <summary>
  ///  Flags used by `TBLFontFace`
  /// </summary>
  /// <seealso cref="TBLFontFace"/>
  TBLFontFaceFlag = (
    /// <summary>
    ///  Font uses typographic family and subfamily names.
    /// </summary>
    TypographicNames = 0,

    /// <summary>
    ///  Font uses typographic metrics.
    /// </summary>
    TypographicMetrics = 1,

    /// <summary>
    ///  Character to glyph mapping is available.
    /// </summary>
    CharToGlyphMapping = 2,

    /// <summary>
    ///  Horizontal glyph metrics (advances, side bearings) is available.
    /// </summary>
    HorizontalMetrics = 4,

    /// <summary>
    ///  Vertical glyph metrics (advances, side bearings) is available.
    /// </summary>
    VerticalMetrics = 5,

    /// <summary>
    ///  Legacy horizontal kerning feature ('kern' table with horizontal kerning data).
    /// </summary>
    HorizontalKerning = 6,

    /// <summary>
    ///  Legacy vertical kerning feature ('kern' table with vertical kerning data).
    /// </summary>
    VerticalKerning = 7,

    /// <summary>
    ///  OpenType features (GDEF, GPOS, GSUB) are available.
    /// </summary>
    OpenTypeFeatures = 8,

    /// <summary>
    ///  Panose classification is available.
    /// </summary>
    PanoseData = 9,

    /// <summary>
    ///  Unicode coverage information is available.
    /// </summary>
    UnicodeCoverage = 10,

    /// <summary>
    ///  Baseline for font at `Y` equals 0.
    /// </summary>
    BaselineYEquals0 = 12,

    /// <summary>
    ///  Left sidebearing point at `X = 0` (TT only).
    /// </summary>
    LsbPointXEquals0 = 13,

    /// <summary>
    ///  Unicode variation sequences feature is available.
    /// </summary>
    VariationSequences = 28,

    /// <summary>
    ///  OpenType Font Variations feature is available.
    /// </summary>
    OpenTypeVariations = 29,

    /// <summary>
    ///  This is a symbol font.
    /// </summary>
    SymbolFont = 30,

    /// <summary>
    ///  This is a last resort font.
    /// </summary>
    LastResortFont = 31);

  /// <summary>
  ///  Flags used by `TBLFontFace`
  /// </summary>
  /// <seealso cref="TBLFontFace"/>
  TBLFontFaceFlags = set of TBLFontFaceFlag;

  /// <summary>
  ///  Adds functionality to `TBLFontFaceFlags`.
  /// </summary>
  _TBLFontFaceFlagsHelper = record helper for TBLFontFaceFlags
  public const
    None = [];
  end;

  /// <summary>
  ///  Diagnostic flags offered by `TBLFontFace`.
  /// </summary>
  /// <seealso cref="TBLFontFace"/>
  TBLFontFaceDiagFlag = (
    /// <summary>
    ///  Wrong data in 'name' table.
    /// </summary>
    WrongNameData = 0,

    /// <summary>
    ///  Fixed data read from 'name' table and possibly fixed font
    ///  family/subfamily name.
    /// </summary>
    FixedNameData = 1,

    /// <summary>
    ///  Wrong data in 'kern' table [kerning disabled].
    /// </summary>
    WrongKernData = 2,

    /// <summary>
    ///  Fixed data read from 'kern' table so it can be used.
    /// </summary>
    FixedKernData = 3,

    /// <summary>
    ///  Wrong data in 'cmap' table.
    /// </summary>
    WrongCmapData = 4,

    /// <summary>
    ///  Wrong format in 'cmap' (sub)table.
    /// </summary>
    WrongCmapFormat = 5);

  /// <summary>
  ///  Diagnostic flags offered by `TBLFontFace`.
  /// </summary>
  /// <seealso cref="TBLFontFace"/>
  TBLFontFaceDiagFlags = set of TBLFontFaceDiagFlag;

  /// <summary>
  ///  Adds functionality to `TBLFontFaceDiagFlags`.
  /// </summary>
  _TBLFontFaceDiagFlagsHelper = record helper for TBLFontFaceDiagFlags
  public const
    None = [];
  end;

type
  /// <summary>
  ///  Format of an outline stored in a font.
  /// </summary>
  TBLFontOutlineType = (
    /// <summary>
    ///  None.
    /// </summary>
    None,

    /// <summary>
    ///  Truetype outlines.
    /// </summary>
    Truetype,

    /// <summary>
    ///  OpenType (CFF) outlines.
    /// </summary>
    Cff,

    /// <summary>
    ///  OpenType (CFF2) outlines with font variations support.
    /// </summary>
    Cff2);

type
  /// <summary>
  ///  Type of a font or font face, see `TBLFontFace`.
  /// </summary>
  /// <seealso cref="TBLFontFace"/>
  TBLFontFaceType = (
    /// <summary>
    ///  None or unknown font type.
    /// </summary>
    None,

    /// <summary>
    ///  TrueType/OpenType font type (.ttf/.otf files and font collections).
    /// </summary>
    OpenType);

type
  /// <summary>
  ///  Flags used by `TBLFontData'.
  /// </summary>
  /// <seealso cref="TBLFontData"/>
  TBLFontDataFlag = (
    /// <summary>
    ///< Font data references a font-collection.
    /// </summary>
    Collection = 0);

  /// <summary>
  ///  Flags used by `TBLFontData'.
  /// </summary>
  /// <seealso cref="TBLFontData"/>
  TBLFontDataFlags = set of TBLFontDataFlag;

  /// <summary>
  ///  Adds functionality to `TBLFontDataFlags`.
  /// </summary>
  _TBLFontDataFlagsHelper = record helper for TBLFontDataFlags
  public const
    None = [];
  end;

type
  /// <summary>
  ///  Font stretch.
  /// </summary>
  TBLFontStretch = (
    /// <summary>
    ///  Ultra condensed stretch.
    /// </summary>
    UltraCondensed = 1,

    /// <summary>
    ///  Extra condensed stretch.
    /// </summary>
    ExtraCondensed,

    /// <summary>
    ///  Condensed stretch.
    /// </summary>
    Condensed,

    /// <summary>
    ///  Semi condensed stretch.
    /// </summary>
    SemiCondensed,

    /// <summary>
    ///  Normal stretch.
    /// </summary>
    Normal,

    /// <summary>
    ///  Semi expanded stretch.
    /// </summary>
    SemiExpanded,

    /// <summary>
    ///  Expanded stretch.
    /// </summary>
    Expanded,

    /// <summary>
    ///  Extra expanded stretch.
    /// </summary>
    ExtraExpanded,

    /// <summary>
    ///  Ultra expanded stretch.
    /// </summary>
    UltraExpanded);

type
  /// <summary>
  ///  Font style.
  /// </summary>
  TBLFontStyle = (
    /// <summary>
    ///  Normal style.
    /// </summary>
    Normal,

    /// <summary>
    ///  Oblique.
    /// </summary>
    Oblique,

    /// <summary>
    ///  Italic.
    /// </summary>
    Italic);

type
  /// <summary>
  ///  Font weight.
  /// </summary>
  TBLFontWeight = (
    /// <summary>
    ///  Thin weight (100).
    /// </summary>
    Thin = 100,

    /// <summary>
    ///  Extra light weight (200).
    /// </summary>
    ExtraLight = 200,

    /// <summary>
    ///  Light weight (300).
    /// </summary>
    Light = 300,

    /// <summary>
    ///  Semi light weight (350).
    /// </summary>
    SemiLight = 350,

    /// <summary>
    ///  Normal weight (400).
    /// </summary>
    Normal = 400,

    /// <summary>
    ///  Medium weight (500).
    /// </summary>
    Medium = 500,

    /// <summary>
    ///  Semi bold weight (600).
    /// </summary>
    SemiBold = 600,

    /// <summary>
    ///  Bold weight (700).
    /// </summary>
    Bold  = 700,

    /// <summary>
    ///  Extra bold weight (800).
    /// </summary>
    ExtraBold = 800,

    /// <summary>
    ///  Black weight (900).
    /// </summary>
    Black = 900,

    /// <summary>
    ///  Extra black weight (950).
    /// </summary>
    ExtraBlack = 950);

type
  /// <summary>
  ///  A read only data that represents a font table or its sub-table.
  /// </summary>
  TBLFontTable = record
  {$REGION 'Internal Declarations'}
  private
    FData: Pointer;
    FSize: Size_T;
    function GetSize: NativeInt; inline;
    function GetIsEmpty: Boolean; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    procedure Reset; overload; inline;
    procedure Reset(const AData: Pointer; const ASize: NativeInt); overload; inline;

    /// <summary>
    ///  Pointer to the beginning of the data.
    /// </summary>
    property Data: Pointer read FData;

    /// <summary>
    ///  Size of `Data` in bytes.
    /// </summary>
    property Size: NativeInt read GetSize;

    /// <summary>
    ///  Whether the table is empty (has no content).
    /// </summary>
    property IsEmpty: Boolean read GetIsEmpty;
  end;
  PBLFontTable = ^TBLFontTable;

type
  /// <summary>
  ///  Font data.
  /// </summary>
  TBLFontData = record
  {$REGION 'Internal Declarations'}
  private type
    TImpl = record
    public
      Virt: Pointer;
      FaceType: UInt8;
      FaceCount: Int32;
      Flags: UInt32;
    end;
    PImpl = ^TImpl;
  private
    FBase: TBLObjectCore;
    function GetIsValid: Boolean; inline;
    function GetIsEmpty: Boolean; inline;
    function GetFaceType: TBLFontFaceType; inline;
    function GetFaceCount: Integer; inline;
    function GetFlags: TBLFontDataFlags; inline;
    function GetIsCollection: Boolean; inline;
  private
    class procedure DestroyDynArray(impl, externalData, userData: Pointer); cdecl; static;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Creates a default initialized font data.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Initialize(out ADest: TBLFontData);

    /// <summary>
    ///  Destroys the font data.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Finalize(var ADest: TBLFontData);

    /// <summary>
    ///  Copy constructor makes a weak copy of the underlying representation of
    ///  the `ASrc` font data.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Assign(var ADest: TBLFontData; const [ref] ASrc: TBLFontData); inline;

    /// <summary>
    ///  Used to compare against `nil` (empty font data).
    /// </summary>
    class operator Equal(const ALeft: TBLFontData; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two font data instances are equal (have the same contents).
    /// </summary>
    class operator Equal(const ALeft, ARight: TBLFontData): Boolean; inline; static;

    /// <summary>
    ///  Used to compare against `nil` (empty font data).
    /// </summary>
    class operator NotEqual(const ALeft: TBLFontData; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two font data instances are not equal (do not have the
    ///  same contents).
    /// </summary>
    class operator NotEqual(const ALeft, ARight: TBLFontData): Boolean; inline; static;

    /// <summary>
    ///  Tests whether this and `AOther` font data are equal.
    /// </summary>
    function Equals(const AOther: TBLFontData): Boolean; inline;

    procedure Reset; inline;
    procedure Swap(var AOther: TBLFontData); inline;

    /// <summary>
    ///  Creates a `TBLFontData` from a file specified by the given `AFilename`.
    /// </summary>
    /// <remarks>
    ///  The `AReadFlags` argument allows to specify flags that will be passed
    ///  to `TBLFileSystem.ReadFile` to read the content of the file. It's
    ///  possible to use memory mapping to get its content, which is the
    ///  recommended way for reading system fonts. The best combination is to
    ///  use `TBLFileReadFlag.MmapEnabled` flag combined with
    ///  `TBLFileReadFlag.MmapAvoidSmall`. This combination means to try to use
    ///  memory mapping only when the size of the font is greater than a minimum
    ///  value (determined by Blend2D), and would fallback to a regular
    ///  open/read in case the memory mapping is not possible or failed for some
    ///  other reason. Please note that not all files can be memory mapped so
    ///  `TBLFileReadFlag.MmapNoFallback`flag is not recommended.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure MakeFromFile(const AFilename: String;
      const AReadFlags: TBLFileReadFlags = []); inline;

    /// <summary>
    ///  Creates a `TBLFontData` from the given `AData`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure MakeFromData(const AData: TBytes); overload; inline;

    /// <summary>
    ///  Creates a `TBLFontData` from the given `AData` stored in
    ///  `TBLArray<Byte>`.
    ///
    ///  The given `AData` would be weak copied on success so the given array
    ///  can be safely destroyed after the function returns.
    /// </summary>
    /// <remarks>
    ///  The weak copy of the passed `AData` is internal and there is no API to
    ///  access it after the function returns. The reason for making it internal
    ///  is that multiple implementations of `TBLFontData` may exist and some
    ///  can only store data at table level, so Blend2D doesn't expose the
    ///  detail about how the data is stored.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure MakeFromData(const AData: TBLArray<Byte>); overload; inline;

    /// <summary>
    ///  Creates `TBLFontData` from the given `AData` of the given `ASize`.
    /// </summary>
    /// <remarks>
    ///  Optionally an `ADestroyFunc` can be used as a notifier that will be
    ///  called when the data is no longer needed. Destroy func will be called
    ///  with `AUserData`.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure MakeFromData(const AData: Pointer; const ASize: NativeInt;
      const ADestroyFunc: TBLDestroyExternalDataFunc = nil;
      const AUserData: Pointer = nil); overload; inline;

    /// <summary>
    ///  Populates `ADst` array with all table tags provided by font face at the
    ///  given `AFaceIndex`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure GetTableTags(const AFaceIndex: Integer;
      const ADst: TBLArray<TBLTag>); overload; inline;

    /// <summary>
    ///  Returns an array with all table tags provided by font face at the
    ///  given `AFaceIndex`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function GetTableTags(const AFaceIndex: Integer): TArray<TBLTag>; overload; inline;

    function GetTable(const AFaceIndex: Integer; const ATag: TBLTag): TBLFontTable; inline;
    function GetTables(const AFaceIndex: Integer; const ATags: TArray<TBLTag>): TArray<TBLFontTable>; inline;

    /// <summary>
    ///  Whether the font data is not a built-in null instance.
    /// </summary>
    property IsValid: Boolean read GetIsValid;

    /// <summary>
    ///  Whether the font data is empty, which is the same as `not IsValid`.
    /// </summary>
    property IsEmpty: Boolean read GetIsEmpty;

    /// <summary>
    ///  Type of font face that this data describes.
    ///
    ///  It doesn't matter if the content is a single font or a collection. In
    ///  any case the `FaceType` would always return the type of the font face
    ///  that will be created by `TBLFontFace.MakeFromData`.
    /// </summary>
    /// <seealso cref="TBLFontFace.MakeFromData"/>
    property FaceType: TBLFontFaceType read GetFaceType;

    /// <summary>
    ///  The number of faces of this font data.
    ///
    ///  If the data is not initialized the result would be always zero. If the
    ///  data is initialized to a single font it would be 1, and if the data is
    ///  initialized to a font collection then the return would correspond to
    ///  the number of font faces within that collection.
    /// </summary>
    /// <remarks>
    ///  You should not use `FaceCount` to check whether the font is a
    ///  collection as it's possible to have a font-collection with just a
    ///  single font. Using `IsCollection` is more reliable and would always
    ///  return the right value.
    /// </remarks>
    /// <seealso cref="IsCollection"/>
    property FaceCount: Integer read GetFaceCount;

    /// <summary>
    ///  Returns font data flags.
    /// </summary>
    property Flags: TBLFontDataFlags read GetFlags;

    /// <summary>
    ///  Whether this font data is a font-collection.
    /// </summary>
    property IsCollection: Boolean read GetIsCollection;
  end;

type
  /// <summary>
  ///  Information of `TBLFontFace`.
  /// </summary>
  /// <seealso cref="TBLFontFace"/>
  TBLFontFaceInfo = record
  {$REGION 'Internal Declarations'}
  private
    FFaceType: UInt8;
    FOutlineType: UInt8;
    {$HINTS OFF}
    FReserved8: array [0..1] of UInt8;
    {$HINTS ON}
    FGlyphCount: Int32;
    FRevision: UInt32;
    FFaceIndex: Int32;
    FFaceFlags: UInt32;
    FDiagFlags: UInt32;
    {$HINTS OFF}
    FReserved: array [0..1] of UInt32;
    {$HINTS ON}
    function GetFaceType: TBLFontFaceType; inline;
    function GetOutlineType: TBLFontOutlineType; inline;
    function GetFaceFlags: TBLFontFaceFlags; inline;
    function GetDiagFlags: TBLFontFaceDiagFlags; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    procedure Reset; inline;

    /// <summary>
    ///  Font face type.
    /// </summary>
    property FaceType: TBLFontFaceType read GetFaceType;

    /// <summary>
    ///  Type of outlines used by the font face.
    /// </summary>
    property OutlineType: TBLFontOutlineType read GetOutlineType;

    /// <summary>
    ///  Number of glyphs provided by this font face.
    /// </summary>
    property GlyphCount: Integer read FGlyphCount;

    /// <summary>
    ///  Revision (read from 'head' table, represented as 16.16 fixed point).
    /// </summary>
    property Revision: Cardinal read FRevision;

    /// <summary>
    ///  Face face index in a TTF/OTF collection or zero if not part of a collection.
    /// </summary>
    property FaceIndex: Integer read FFaceIndex;

    /// <summary>
    ///  Font face flags.
    /// </summary>
    property FaceFlags: TBLFontFaceFlags read GetFaceFlags;

    /// <summary>
    ///  Font face diagnostic flags.
    /// </summary>
    property DiagFlags: TBLFontFaceDiagFlags read GetDiagFlags;
  end;
  PBLFontFaceInfo = ^TBLFontFaceInfo;

type
  /// <summary>
  ///  Design metrics of a font.
  ///
  ///  Design metrics is information that `TBLFontFace` collected directly from
  ///  the font data. It means that all fields are measured in font design units.
  ///
  ///  When a new `TBLFont` instance is created a scaled metrics
  ///  `TBLFontMetrics` is automatically calculated from `TBLFontDesignMetrics`
  ///  including other members like transformation, etc...
  /// </summary>
  /// <seealso cref="TBLFontFace"/>
  /// <seealso cref="TBLFont"/>
  /// <seealso cref="TBLFontMetrics"/>
  TBLFontDesignMetrics = record
  {$REGION 'Internal Declarations'}
  private
    FUnitsPerEm: Integer;
    FLowestPpEm: Integer;
    FLineGap: Integer;
    FXHeight: Integer;
    FCapHeight: Integer;
    FAscent: Integer;
    FVAscent: Integer;
    FDescent: Integer;
    FVDescent: Integer;
    FHMinLsb: Integer;
    FVMinLsb: Integer;
    FHMinTsb: Integer;
    FVMinTsb: Integer;
    FHMaxAdvance: Integer;
    FVMaxAdvance: Integer;
    FGlyphBoundingBox: TBLBoxI;
    FUnderlinePosition: Integer;
    FUnderlineThickness: Integer;
    FStrikethroughPosition: Integer;
    FStrikethroughThickness: Integer;
  {$ENDREGION 'Internal Declarations'}
  public
    procedure Reset; inline;

    /// <summary>
    ///  Units per EM square.
    /// </summary>
    property UnitsPerEm: Integer read FUnitsPerEm;

    /// <summary>
    ///  Lowest readable size in pixels.
    /// </summary>
    property LowestPpEm: Integer read FLowestPpEm;

    /// <summary>
    ///  Line gap.
    /// </summary>
    property LineGap: Integer read FLineGap;

    /// <summary>
    ///  Distance between the baseline and the mean line of lower-case letters.
    /// </summary>
    property XHeight: Integer read FXHeight;

    /// <summary>
    ///  Maximum height of a capital letter above the baseline.
    /// </summary>
    property CapHeight: Integer read FCapHeight;

    /// <summary>
    ///  Ascent (horizontal layout).
    /// </summary>
    property Ascent: Integer read FAscent;

    /// <summary>
    ///  Ascent (vertical layout).
    /// </summary>
    property VAscent: Integer read FVAscent;

    /// <summary>
    ///  Descent (horizontal layout).
    /// </summary>
    property Descent: Integer read FDescent;

    /// <summary>
    ///  Descent (vertical layout).
    /// </summary>
    property VDescent: Integer read FVDescent;

    /// <summary>
    ///  Minimum leading-side bearing (horizontal layout).
    /// </summary>
    property HMinLsb: Integer read FHMinLsb;

    /// <summary>
    ///  Minimum leading-side bearing (vertical layout).
    /// </summary>
    property VMinLsb: Integer read FVMinLsb;

    /// <summary>
    ///  Minimum trailing-side bearing (horizontal layout).
    /// </summary>
    property HMinTsb: Integer read FHMinTsb;

    /// <summary>
    ///  Minimum trailing-side bearing (vertical layout).
    /// </summary>
    property VMinTsb: Integer read FVMinTsb;

    /// <summary>
    ///  Maximum advance (horizontal layout).
    /// </summary>
    property HMaxAdvance: Integer read FHMaxAdvance;

    /// <summary>
    ///  Maximum advance (vertical layout).
    /// </summary>
    property VMaxAdvance: Integer read FVMaxAdvance;

    /// <summary>
    ///  Aggregated bounding box of all glyphs in the font.
    /// </summary>
    /// <remarks>
    ///  This value is reported by the font data so it's not granted to be true.
    /// <remarks>
    property GlyphBoundingBox: TBLBoxI read FGlyphBoundingBox;

    /// <summary>
    ///  Text underline position.
    /// </summary>
    property UnderlinePosition: Integer read FUnderlinePosition;

    /// <summary>
    ///  Text underline thickness.
    /// </summary>
    property UnderlineThickness: Integer read FUnderlineThickness;

    /// <summary>
    ///  Text strikethrough position.
    /// </summary>
    property StrikethroughPosition: Integer read FStrikethroughPosition;

    /// <summary>
    ///  Text strikethrough thickness.
    /// </summary>
    property StrikethroughThickness: Integer read FStrikethroughThickness;
  end;
  PBLFontDesignMetrics = ^TBLFontDesignMetrics;

type
  /// <summary>
  ///  Font unicode coverage.
  ///
  ///  Unicode coverage describes which unicode characters are provided by a
  ///  font. Blend2D accesses this information by reading "OS/2" table, if
  ///  available.
  /// </summary>
  TBLFontUnicodeCoverage = record
  {$REGION 'Internal Declarations'}
  private
    FData: array [0..3] of UInt32;
    function GetIsEmpty: Boolean; inline;
    procedure SetBitValue(const AIndex: Integer; const AValue: Boolean); inline;
  {$ENDREGION 'Internal Declarations'}
  public
    class operator Equal(const ALeft, ARight: TBLFontUnicodeCoverage): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLFontUnicodeCoverage): Boolean; inline; static;

    procedure Reset; inline;
    function HasBit(const AIndex: Integer): Boolean; inline;
    procedure SetBit(const AIndex: Integer); inline;
    procedure ClearBit(const AIndex: Integer); inline;
    function Equals(const AOther: TBLFontUnicodeCoverage): Boolean; inline;

    property IsEmpty: Boolean read GetIsEmpty;
    property Bits[const AIndex: Integer]: Boolean read HasBit write SetBitValue;
  end;
  PBLFontUnicodeCoverage = ^TBLFontUnicodeCoverage;

type
  /// <summary>
  ///  Font PANOSE classification.
  /// </summary>
  TBLFontPanose = record
  public type
    TText = record
    public
      FamilyKind: Byte;
      SerifStyle: Byte;
      Weight: Byte;
      Proportion: Byte;
      Contrast: Byte;
      StrokeVariation: Byte;
      ArmStyle: Byte;
      Letterform: Byte;
      Midline: Byte;
      XHeight: Byte;
    end;
  public type
    TScript = record
    public
      FamilyKind: Byte;
      ToolKind: Byte;
      Weight: Byte;
      Spacing: Byte;
      AspectRatio: Byte;
      Contrast: Byte;
      Topology: Byte;
      Form: Byte;
      Finals: Byte;
      XAscent: Byte;
    end;
  public type
    TDecorative = record
    public
      FamilyKind: Byte;
      DecorativeClass: Byte;
      Weight: Byte;
      Aspect: Byte;
      Contrast: Byte;
      SerifVariant: Byte;
      Treatment: Byte;
      Lining: Byte;
      Topology: Byte;
      CharacterRange: Byte;
    end;
  public type
    TSymbol = record
    public
      FamilyKind: Byte;
      SymbolKind: Byte;
      Weight: Byte;
      Spacing: Byte;
      AspectRatioAndContrast: Byte;
      AspectRatio94: Byte;
      AspectRatio119: Byte;
      AspectRatio157: Byte;
      AspectRatio163: Byte;
      AspectRatio211: Byte;
    end;
  {$REGION 'Internal Declarations'}
  private
    FData: array [0..9] of Byte;
    function GetFamilyKind: Byte; inline;
    function GetText: TText; inline;
    function GetScript: TScript; inline;
    function GetDecorative: TDecorative; inline;
    function GetSymbol: TSymbol; inline;
    function GetIsEmpty: Boolean; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    procedure Reset; inline;

    property FamilyKind: Byte read GetFamilyKind;
    property Text: TText read GetText;
    property Script: TScript read GetScript;
    property Decorative: TDecorative read GetDecorative;
    property Symbol: TSymbol read GetSymbol;
    property IsEmpty: Boolean read GetIsEmpty;
  end;
  PBLFontPanose = ^TBLFontPanose;

type
  /// <summary>
  ///  Font face.
  /// </summary>
  TBLFontFace = record
  {$REGION 'Internal Declarations'}
  private type
    TImpl = record
    public
      Virt: Pointer;
      Weight: UInt16;
      Stretch: UInt8;
      Style: UInt8;
      FaceInfo: TBLFontFaceInfo;
      UniqueId: TBLUniqueId;
      Data: TBLObjectCore;
      FullName: TBLObjectCore;
      FamilyName: TBLObjectCore;
      SubfamilyName: TBLObjectCore;
      PostscriptName: TBLObjectCore;
      DesignMetrics: TBLFontDesignMetrics;
      UnicodeCoverage: TBLFontUnicodeCoverage;
      Panose: TBLFontPanose;
    end;
    PImpl = ^TImpl;
  private
    FBase: TBLObjectCore;
    function GetIsValid: Boolean; inline;
    function GetIsEmpty: Boolean; inline;
    function GetWeight: TBLFontWeight; inline;
    function GetStretch: TBLFontStretch; inline;
    function GetStyle: TBLFontStyle; inline;
    function GetFaceInfo: PBLFontFaceInfo; inline;
    function GetFaceType: TBLFontFaceType; inline;
    function GetOutlineType: TBLFontOutlineType; inline;
    function GetGlyphCount: Integer; inline;
    function GetFaceIndex: Integer; inline;
    function GetFaceFlags: TBLFontFaceFlags; inline;
    function GetHasTypographicNames: Boolean; inline;
    function GetHasTypographicMetrics: Boolean; inline;
    function GetHasCharToGlyphMapping: Boolean; inline;
    function GetHasHorizontalMetrics: Boolean; inline;
    function GetHasVerticalMetrics: Boolean; inline;
    function GetHasHorizontalKerning: Boolean; inline;
    function GetHasVerticalKerning: Boolean; inline;
    function GetHasOpenTypeFeatures: Boolean; inline;
    function GetHasPanoseData: Boolean; inline;
    function GetHasUnicodeCoverage: Boolean; inline;
    function GetHasBaselineYAt0: Boolean; inline;
    function GetHasLsbPointXAt0: Boolean; inline;
    function GetHasVariationSequences: Boolean; inline;
    function GetHasOpenTypeVariations: Boolean; inline;
    function GetIsSymbolFont: Boolean; inline;
    function GetIsLastResortFont: Boolean; inline;
    function GetDiagFlags: TBLFontFaceDiagFlags; inline;
    function GetUniqueId: TBLUniqueId; inline;
    function GetData: TBLFontData; inline;
    function GetFullName: TBLString; inline;
    function GetFamilyName: TBLString; inline;
    function GetSubfamilyName: TBLString; inline;
    function GetPostScriptName: TBLString; inline;
    function GetDesignMetrics: PBLFontDesignMetrics; inline;
    function GetUnitsPerEm: Integer; inline;
    function GetPanose: PBLFontPanose; inline;
    function GetUnicodeCoverage: PBLFontUnicodeCoverage; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Creates a default initialized font face.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Initialize(out ADest: TBLFontFace);

    /// <summary>
    ///  Destroys the font face.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Finalize(var ADest: TBLFontFace);

    /// <summary>
    ///  Copy constructor makes a weak copy of the underlying representation of
    ///  the `ASrc` font face.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Assign(var ADest: TBLFontFace; const [ref] ASrc: TBLFontFace); inline;

    /// <summary>
    ///  Used to compare against `nil` (null font face).
    /// </summary>
    class operator Equal(const ALeft: TBLFontFace; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two font faces are equal (have the same contents).
    /// </summary>
    class operator Equal(const ALeft, ARight: TBLFontFace): Boolean; inline; static;

    /// <summary>
    ///  Used to compare against `nil` (null font face).
    /// </summary>
    class operator NotEqual(const ALeft: TBLFontFace; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two font faces are not equal (do not have the same contents).
    /// </summary>
    class operator NotEqual(const ALeft, ARight: TBLFontFace): Boolean; inline; static;

    /// <summary>
    ///  Tests whether this and `AOther` font faces are equal.
    /// </summary>
    function Equals(const AOther: TBLFontFace): Boolean; inline;

    procedure Reset; inline;
    procedure Swap(var AOther: TBLFontFace); inline;

    /// <summary>
    ///  Creates a new `TBLFontFace` from a file specified by `AFilename`.
    ///
    ///  This is a utility method that first creates a `TBLFontData` and then
    ///  calls `MakeFromData(FontData, 0)`.
    ///  See `TBLFontData.MakeFromFile` for more details, especially the use of
    ///  `AReadFlags` is important for system fonts.
    /// </summary>
    /// <remarks>
    ///  This method offers a simplified creation of `TBLFontFace` directly from
    ///  a file, but doesn't provide as much flexibility as `MakeFromData` as it
    ///  allows to specify a `AFaceIndex`, which can be used to load multiple
    ///  font faces from a TrueType/OpenType collection. The use of
    ///  `MakeFromData` is recommended for any serious font handling.
    /// </remarks>
    /// <seealso cref="MakeFromData"/>
    /// <seealso cref="TBLFontData"/>
    /// <seealso cref="TBLFontData.MakeFromFile"/>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure MakeFromFile(const AFilename: String;
      const AReadFlags: TBLFileReadFlags = []); inline;

    /// <summary>
    ///  Creates a new `TBLFontFace` from `TBLFontData` at the given `AFaceIndex`.
    ///
    ///  On success the existing `TBLFontFace` is completely replaced by a new
    ///  one, on failure the existing `TBLFontFace` is kept as is.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure MakeFromData(const AFontData: TBLFontData;
      const AFaceIndex: Integer); inline;

    /// <summary>
    ///  Tests whether the font face has a given `AFlag` set.
    /// </summary>
    function HasFaceFlag(const AFlag: TBLFontFaceFlag): Boolean; inline;

    /// <summary>
    ///  Calculates the character coverage of this `TBLFontFace`.
    ///
    ///  Each unicode character is represented by a single bit in the given BitSet.
    /// </summary>
//    procedure GetCharacterCoverage(const AOut: TBLBitSet); inline; // TBLBitSet is going to be deprecated?

    /// <summary>
    ///  Tests whether the font face provides the given OpenType `AScriptTag`.
    /// </summary>
    function HasScriptTag(const AScriptTag: TBLTag): Boolean; inline;

    /// <summary>
    ///  Tests whether the font face provides the given OpenType `AFeatureTag`.
    /// </summary>
    function HasFeatureTag(const AFeatureTag: TBLTag): Boolean; inline;

    /// <summary>
    ///  Tests whether the font face provides the given OpenType `AVariationTag`.
    /// </summary>
    function HasVariationTag(const AVariationTag: TBLTag): Boolean; inline;

    /// <summary>
    ///  Retrieves OpenType script tags provided by this `TBLFontFace`.
    ///
    ///  Each script tag is represented by 4 characters encoded in `TBLTag`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function GetScriptTags: TArray<TBLTag>; overload; inline;

    /// <summary>
    ///  Retrieves OpenType script tags provided by this `TBLFontFace`.
    ///
    ///  Each script tag is represented by 4 characters encoded in `TBLTag`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure GetScriptTags(const AOut: TBLArray<TBLTag>); overload; inline;

    /// <summary>
    ///  Retrieves OpenType feature tags provided by this `TBLFontFace`.
    ///
    ///  Each feature tag is represented by 4 characters encoded in `TBLTag`.
    ///
    ///  Feature tag registry:
    ///   - <see href="https://docs.microsoft.com/en-us/typography/opentype/spec/featurelist">Microsoft</see>.
    /// </summary>
    function GetFeatureTags: TArray<TBLTag>; overload; inline;

    /// <summary>
    ///  Retrieves OpenType feature tags provided by this `TBLFontFace`.
    ///
    ///  Each feature tag is represented by 4 characters encoded in `TBLTag`.
    ///
    ///  Feature tag registry:
    ///   - <see href="https://docs.microsoft.com/en-us/typography/opentype/spec/featurelist">Microsoft</see>.
    /// </summary>
    procedure GetFeatureTags(const AOut: TBLArray<TBLTag>); overload; inline;

    /// <summary>
    ///  Retrieves OpenType variation tags provided by this `TBLFontFace`.
    ///
    ///  Each variation tag is represented by 4 characters encoded in `TBLTag`.
    ///
    ///  Variation tag registry:
    ///   - <see href="https://docs.microsoft.com/en-us/typography/opentype/spec/dvaraxisreg">Microsoft</see>.
    /// </summary>
    function GetVariationTags: TArray<TBLTag>; overload; inline;

    /// <summary>
    ///  Retrieves OpenType variation tags provided by this `TBLFontFace`.
    ///
    ///  Each variation tag is represented by 4 characters encoded in `TBLTag`.
    ///
    ///  Variation tag registry:
    ///   - <see href="https://docs.microsoft.com/en-us/typography/opentype/spec/dvaraxisreg">Microsoft</see>.
    /// </summary>
    procedure GetVariationTags(const AOut: TBLArray<TBLTag>); overload; inline;

    /// <summary>
    ///  Whether the font face is a valid instance.
    /// </summary>
    property IsValid: Boolean read GetIsValid;

    /// <summary>
    ///  Tests whether the font face is empty, which is the same as `not IsValid`.
    /// </summary>
    property IsEmpty: Boolean read GetIsEmpty;

    /// <summary>
    ///  Font weight (returns default weight in case this is a variable font).
    /// </summary>
    property Weight: TBLFontWeight read GetWeight;

    /// <summary>
    ///  Font stretch (returns default stretch in case this is a variable font).
    /// </summary>
    property Stretch: TBLFontStretch read GetStretch;

    /// <summary>
    ///  Returns font style.
    /// </summary>
    property Style: TBLFontStyle read GetStyle;

    /// <summary>
    ///  Font face information.
    /// </summary>
    property FaceInfo: PBLFontFaceInfo read GetFaceInfo;

    /// <summary>
    ///  The font face type.
    /// </summary>
    property FaceType: TBLFontFaceType read GetFaceType;

    /// <summary>
    ///  The outline type.
    /// </summary>
    property OutlineType: TBLFontOutlineType read GetOutlineType;

    /// <summary>
    ///  The number of glyphs this font face provides.
    /// </summary>
    property GlyphCount: Integer read GetGlyphCount;

    /// <summary>
    ///  A zero-based index of this font face.
    /// </summary>
    /// <remarks>
    ///  Face index does only make sense if this face is part of a TrueType or
    ///  OpenType font collection. In that case the returned value would be the
    ///  index of this face in that collection. If the face is not part of a
    ///  collection then the returned value would always be zero.
    /// </remarks>
    property FaceIndex: Integer read GetFaceIndex;

    /// <summary>
    ///  Font face flags.
    /// </summary>
    property FaceFlags: TBLFontFaceFlags read GetFaceFlags;

    /// <summary>
    ///  Whether the font face uses typographic family and subfamily names.
    /// </summary>
    property HasTypographicNames: Boolean read GetHasTypographicNames;

    /// <summary>
    ///  Whether the font face uses typographic metrics.
    /// </summary>
    property HasTypographicMetrics: Boolean read GetHasTypographicMetrics;

    /// <summary>
    ///  Whether the font face provides character to glyph mapping.
    /// </summary>
    property HasCharToGlyphMapping: Boolean read GetHasCharToGlyphMapping;

    /// <summary>
    ///  Whether the font face has horizontal glyph metrics (advances, side bearings).
    /// </summary>
    property HasHorizontalMetrics: Boolean read GetHasHorizontalMetrics;

    /// <summary>
    ///  Whether the font face has vertical glyph metrics (advances, side bearings).
    /// </summary>
    property HasVerticalMetrics: Boolean read GetHasVerticalMetrics;

    /// <summary>
    ///  Whether the font face has a legacy horizontal kerning feature ('kern'
    ///  table with horizontal kerning data).
    /// </summary>
    property HasHorizontalKerning: Boolean read GetHasHorizontalKerning;

    /// <summary>
    ///  Whether the font face has a legacy vertical kerning feature ('kern'
    ///  table with vertical kerning data).
    /// </summary>
    property HasVerticalKerning: Boolean read GetHasVerticalKerning;

    /// <summary>
    ///  Whether the font face has OpenType features (GDEF, GPOS, GSUB).
    /// </summary>
    property HasOpenTypeFeatures: Boolean read GetHasOpenTypeFeatures;

    /// <summary>
    ///  Whether the font face has panose classification.
    /// </summary>
    property HasPanoseData: Boolean read GetHasPanoseData;

    /// <summary>
    ///  Whether the font face has unicode coverage information.
    /// </summary>
    property HasUnicodeCoverage: Boolean read GetHasUnicodeCoverage;

    /// <summary>
    ///  Whether the font face's baseline equals 0.
    /// </summary>
    property HasBaselineYAt0: Boolean read GetHasBaselineYAt0;

    /// <summary>
    ///  Whether the font face's left sidebearing point at `X` equals 0.
    /// </summary>
    property HasLsbPointXAt0: Boolean read GetHasLsbPointXAt0;

    /// <summary>
    ///  Whether the font face has unicode variation sequences feature.
    /// </summary>
    property HasVariationSequences: Boolean read GetHasVariationSequences;

    /// <summary>
    ///  Whether the font face has OpenType Font Variations feature.
    /// </summary>
    property HasOpenTypeVariations: Boolean read GetHasOpenTypeVariations;

    /// <summary>
    ///  Whether this is a symbol font.
    /// </summary>
    property IsSymbolFont: Boolean read GetIsSymbolFont;

    /// <summary>
    ///  Whether this is a last resort font.
    /// </summary>
    property IsLastResortFont: Boolean read GetIsLastResortFont;

    /// <summary>
    ///  Font face diagnostics flags.
    /// </summary>
    property DiagFlags: TBLFontFaceDiagFlags read GetDiagFlags;

    /// <summary>
    ///  A unique identifier describing this `TBLFontFace`.
    /// </summary>
    property UniqueId: TBLUniqueId read GetUniqueId;

    /// <summary>
    ///  `TBLFontData` associated with this font face.
    /// </summary>
    property Data: TBLFontData read GetData;

    /// <summary>
    ///  Full name of the font.
    /// </summary>
    property FullName: TBLString read GetFullName;

    /// <summary>
    ///  Family name of the font.
    /// </summary>
    property FamilyName: TBLString read GetFamilyName;

    /// <summary>
    ///  Subfamily name of the font.
    /// </summary>
    property SubfamilyName: TBLString read GetSubfamilyName;

    /// <summary>
    ///  PostScript name of the font.
    /// </summary>
    property PostScriptName: TBLString read GetPostScriptName;

    /// <summary>
    ///  Design metrics of this `TBLFontFace`.
    /// </summary>
    property DesignMetrics: PBLFontDesignMetrics read GetDesignMetrics;

    /// <summary>
    ///  Units per em, which are part of font's design metrics.
    /// </summary>
    property UnitsPerEm: Integer read GetUnitsPerEm;

    /// <summary>
    ///  Returns PANOSE classification of this `TBLFontFace`.
    /// </summary>
    property Panose: PBLFontPanose read GetPanose;

    /// <summary>
    ///  Returns unicode coverage of this `TBLFontFace`.
    /// </summary>
    /// <remarks>
    ///  The returned unicode-coverage is not calculated by Blend2D so in
    ///  general the value doesn't have to be correct. Consider
    ///  `GetCharacterCoverage` to get a coverage calculated by Blend2D at
    ///  character granularity.
    /// </remarks>
    property UnicodeCoverage: PBLFontUnicodeCoverage read GetUnicodeCoverage;
  end;

type
  /// <summary>
  ///  2x2 transformation matrix used by `TBLFont`. It's similar to
  ///  `TBLMatrix2D`, however, it doesn't provide a translation part as it's
  ///  assumed to be zero.
  /// </summary>
  /// <seealso cref="TBLFont"/>
  /// <seealso cref="TBLMatrix2D"/>
  TBLFontMatrix = record
  public
    M: array [0..3] of Double;
  public
    class function Create: TBLFontMatrix; overload; inline; static;
    constructor Create(const AM00, AM01, AM10, AM11: Double); overload;

    procedure Reset; overload; inline;
    procedure Reset(const AM00, AM01, AM10, AM11: Double); overload; inline;

    property M00: Double read M[0];
    property M01: Double read M[1];
    property M10: Double read M[2];
    property M11: Double read M[3];
  end;
  PBLFontMatrix = ^TBLFontMatrix;

type
  /// <summary>
  ///  Scaled `TBLFontDesignMetrics` based on font size and other properties.
  /// </summary>
  /// <seealso cref="TBLFontDesignMetrics"/>
  TBLFontMetrics = record
  {$REGION 'Internal Declarations'}
  private
    FSize: Single;
    FAscent: Single;
    FVAscent: Single;
    FDescent: Single;
    FVDescent: Single;
    FLineGap: Single;
    FXHeight: Single;
    FCapHeight: Single;
    FXMin: Single;
    FYMin: Single;
    FXMax: Single;
    FYMax: Single;
    FUnderlinePosition: Single;
    FUnderlineThickness: Single;
    FStrikethroughPosition: Single;
    FStrikethroughThickness: Single;
  {$ENDREGION 'Internal Declarations'}
  public
    procedure Reset; inline;

    /// <summary>
    ///  Font size.
    /// </summary>
    property Size: Single read FSize;

    /// <summary>
    ///  Font ascent (horizontal orientation).
    /// </summary>
    property Ascent: Single read FAscent;

    /// <summary>
    ///  Font ascent (vertical orientation).
    /// </summary>
    property VAscent: Single read FVAscent;

    /// <summary>
    ///  Font descent (horizontal orientation).
    /// </summary>
    property Descent: Single read FDescent;

    /// <summary>
    ///  Font descent (vertical orientation).
    /// </summary>
    property VDescent: Single read FVDescent;

    /// <summary>
    ///  Line gap.
    /// </summary>
    property LineGap: Single read FLineGap;

    /// <summary>
    ///  Distance between the baseline and the mean line of lower-case letters.
    /// </summary>
    property XHeight: Single read FXHeight;

    /// <summary>
    ///  Maximum height of a capital letter above the baseline.
    /// </summary>
    property CapHeight: Single read FCapHeight;

    /// <summary>
    ///  Minimum X, reported by the font.
    /// </summary>
    property XMin: Single read FXMin;

    /// <summary>
    ///  Minimum Y, reported by the font.
    /// </summary>
    property YMin: Single read FYMin;

    /// <summary>
    ///  Maximum X, reported by the font.
    /// </summary>
    property XMax: Single read FXMax;

    /// <summary>
    ///  Maximum Y, reported by the font.
    /// </summary>
    property YMax: Single read FYMax;

    /// <summary>
    ///  Text underline position.
    /// </summary>
    property UnderlinePosition: Single read FUnderlinePosition;

    /// <summary>
    ///  Text underline thickness.
    /// </summary>
    property UnderlineThickness: Single read FUnderlineThickness;

    /// <summary>
    ///  Text strikethrough position.
    /// </summary>
    property StrikethroughPosition: Single read FStrikethroughPosition;

    /// <summary>
    ///  Text strikethrough thickness.
    /// </summary>
    property StrikethroughThickness: Single read FStrikethroughThickness;
  end;
  PBLFontMetrics = ^TBLFontMetrics;

type
  /// <summary>
  ///  Associates a font feature tag with a value. Tag describes the feature (as
  ///  provided by the font) and `Value` describes its value. Some features only
  ///  allow boolean values 0 and 1 and some allow values up to 65535.
  ///  Values less than 0 and greater than 65535 are invalid, however, only `-1`
  ///  should be used as invalid value in general.
  ///
  ///  Registered OpenType features:
  ///   - <see href="https://docs.microsoft.com/en-us/typography/opentype/spec/featuretags">Microsoft</see>.
  ///   - <see href="https://helpx.adobe.com/typekit/using/open-type-syntax.html">Adobe</see>.
  /// </summary>
  TBLFontFeatureItem = record
  {$REGION 'Internal Declarations'}
  private
    FTag: TBLTag;
    FValue: Int32;
  {$ENDREGION 'Internal Declarations'}
  public
    procedure Reset; inline;

    /// <summary>
    ///  Feature tag (32-bit).
    /// </summary>
    property Tag: TBLTag read FTag;

    /// <summary>
    ///  Feature value.
    /// </summary>
    /// <remarks>
    ///  Values less than 0 and greater than 65535 are invalid.
    /// </remarks>
    property Value: Integer read FValue;
  end;
  {$POINTERMATH ON}
  PBLFontFeatureItem = ^TBLFontFeatureItem;
  {$POINTERMATH OFF}

type
  /// <summary>
  ///  A view unifying the representation of an internal storage used by
  ///  `TBLFontFeatureSettings`.
  /// </summary>
  TBLFontFeatureSettingsView = record
  {$REGION 'Internal Declarations'}
  private
    FData: PBLFontFeatureItem;
    FCount: Size_T;
    {$HINTS OFF}
    FSsoData: array [0..35] of TBLFontFeatureItem;
    {$HINTS ON}
    function GetIsEmpty: Boolean; inline;
    function GetCount: NativeInt; inline;
    function GetItem(const AIndex: NativeInt): TBLFontFeatureItem;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Whether the view is empty.
    /// </summary>
    property IsEmpty: Boolean read GetIsEmpty;

    /// <summary>
    ///  Pointer to font feature items, where each item describes a tag and its
    ///  value.
    /// </summary>
    property Data: PBLFontFeatureItem read FData;

    /// <summary>
    ///  Count of items in `Data`.
    /// </summary>
    property Count: NativeInt read GetCount;

    /// <summary>
    ///  The font feature items, where each item describes a tag and its value.
    /// </summary>
    property Items[const AIndex: NativeInt]: TBLFontFeatureItem read GetItem; default;
  end;
  PBLFontFeatureSettingsView = ^TBLFontFeatureSettingsView;

type
  /// <summary>
  ///  Font feature settings.
  /// </summary>
  TBLFontFeatureSettings = record
  {$REGION 'Internal Declarations'}
  private
    FBase: TBLObjectCore;
    function GetIsEmpty: Boolean; inline;
    function GetCount: NativeInt; inline;
    function GetCapacity: NativeInt; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Creates default initialized font feature settings.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Initialize(out ADest: TBLFontFeatureSettings);

    /// <summary>
    ///  Destroys the font feature settings.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Finalize(var ADest: TBLFontFeatureSettings);

    /// <summary>
    ///  Copy constructor makes a weak copy of the underlying representation of
    ///  the `ASrc` font feature settings.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Assign(var ADest: TBLFontFeatureSettings; const [ref] ASrc: TBLFontFeatureSettings); inline;

    /// <summary>
    ///  Used to compare against `nil` (empty font feature settings).
    /// </summary>
    class operator Equal(const ALeft: TBLFontFeatureSettings; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two font feature settings instances are equal.
    /// </summary>
    class operator Equal(const ALeft, ARight: TBLFontFeatureSettings): Boolean; inline; static;

    /// <summary>
    ///  Used to compare against `nil` (empty font feature settings).
    /// </summary>
    class operator NotEqual(const ALeft: TBLFontFeatureSettings; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two font feature settings instances are not equal.
    /// </summary>
    class operator NotEqual(const ALeft, ARight: TBLFontFeatureSettings): Boolean; inline; static;

    /// <summary>
    ///  Tests whether this and `AOther` font feature settings are equal.
    /// </summary>
    function Equals(const AOther: TBLFontFeatureSettings): Boolean; inline;

    /// <summary>
    ///  Resets the font feature settings to a default constructed state.
    /// </summary>
    procedure Reset; inline;

    procedure Clear; inline;

    /// <summary>
    ///  Swaps the underlying representation with `AOther`.
    /// </summary>
    procedure Swap(var AOther: TBLFontFeatureSettings); inline;

    /// <summary>
    ///  Returns a normalized view of tag/value pairs.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function View: TBLFontFeatureSettingsView; inline;

    /// <summary>
    ///  Tests whether the settings contains the given `AFeatureTag`.
    /// </summary>
    function HasValue(const AFeatureTag: TBLTag): Boolean; inline;

    /// <summary>
    ///  Returns the value associated with the given `AFeatureTag`.
    ///
    ///  If the `AFeatureTag` doesn't exist or is invalid `-1` is returned.
    /// </summary>
    function GetValue(const AFeatureTag: TBLTag): Integer; inline;

    /// <summary>
    ///  Sets or inserts the given `AFeatureTag` to the settings, associating
    ///  the `AFeatureTag` with `AValue`.
    ///
    ///  The `AFeatureTag` must be valid, which means that it must contain 4
    ///  characters within ' ' to '~' range - [32, 126] in ASCII. If the given
    ///  `AFeatureTag` is not valid or `AValue` is out of range (maximum value
    ///  is `65535`) an error is raised.
    ///
    ///  The following tags only support values that are either 0 (disabled) or
    ///  1 (enabled):
    ///
    ///    - 'case'
    ///    - 'clig'
    ///    - 'cpct'
    ///    - 'cpsp'
    ///    - 'dlig'
    ///    - 'dnom'
    ///    - 'expt'
    ///    - 'falt'
    ///    - 'frac'
    ///    - 'fwid'
    ///    - 'halt'
    ///    - 'hist'
    ///    - 'hwid'
    ///    - 'jalt'
    ///    - 'kern'
    ///    - 'liga'
    ///    - 'lnum'
    ///    - 'onum'
    ///    - 'ordn'
    ///    - 'palt'
    ///    - 'pcap'
    ///    - 'ruby'
    ///    - 'smcp'
    ///    - 'subs'
    ///    - 'sups'
    ///    - 'titl'
    ///    - 'tnam'
    ///    - 'tnum'
    ///    - 'unic'
    ///    - 'valt'
    ///    - 'vkrn'
    ///    - 'zero'
    ///
    ///  Trying to use any other value with these tags would fail.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetValue(const ATag: TBLTag; const AValue: Integer); inline;

    /// <summary>
    ///  Removes the given `AFeatureTag` and its associated value from the
    ///  settings.
    ///
    ///  Nothing happens if the `AFeatureTag` is not in the settings.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure RemoveValue(const AFeatureTag: TBLTag); inline;

    /// <summary>
    ///  Whether the container is empty, which means that no tag/value pairs are
    ///  stored in it.
    /// </summary>
    property IsEmpty: Boolean read GetIsEmpty;

    /// <summary>
    ///  The number of feature tag/value pairs stored in the container.
    /// </summary>
    property Count: NativeInt read GetCount;

    /// <summary>
    ///  The container capacity.
    /// </summary>
    property Capacity: NativeInt read GetCapacity;

    /// <summary>
    ///  The value associated with the given `AFeatureTag`.
    ///
    ///  See `GetValue` and `SetValue` for more information.
    /// </summary>
    /// <seealso cref="GetValue"/>
    /// <seealso cref="SetValue"/>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property Values[const AFeatureTag: TBLTag]: Integer read GetValue write SetValue;
  end;

type
  /// <summary>
  ///  Associates a font variation tag with a value.
  /// </summary>
  TBLFontVariationItem = record
  {$REGION 'Internal Declarations'}
  private
    FTag: TBLTag;
    FValue: Single;
  {$ENDREGION 'Internal Declarations'}
  public
    procedure Reset; inline;

    /// <summary>
    ///  Variation tag (32-bit).
    /// </summary>
    property Tag: TBLTag read FTag;

    /// <summary>
    ///  Variation value.
    /// </summary>
    /// <remarks>
    ///  Values outside of [0, 1] range are invalid.
    /// </remarks>
    property Value: Single read FValue;
  end;
  {$POINTERMATH ON}
  PBLFontVariationItem = ^TBLFontVariationItem;
  {$POINTERMATH OFF}

type
  /// <summary>
  ///  A view unifying the representation of an internal storage used by
  ///  `TBLFontVariationSettings`.
  /// </summary>
  TBLFontVariationSettingsView = record
  {$REGION 'Internal Declarations'}
  private
    FData: PBLFontVariationItem;
    FCount: Size_T;
    {$HINTS OFF}
    FSsoData: array [0..3] of TBLFontVariationItem;
    {$HINTS ON}
    function GetIsEmpty: Boolean; inline;
    function GetCount: NativeInt; inline;
    function GetItem(const AIndex: NativeInt): TBLFontVariationItem;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Whether the view is empty.
    /// </summary>
    property IsEmpty: Boolean read GetIsEmpty;

    /// <summary>
    ///  Pointer to font variation items, where each item describes a tag and
    ///  its value.
    /// </summary>
    property Data: PBLFontVariationItem read FData;

    /// <summary>
    ///  Count of items in `Data`.
    /// </summary>
    property Count: NativeInt read GetCount;

    /// <summary>
    ///  The font variation items, where each item describes a tag and its value.
    /// </summary>
    property Items[const AIndex: NativeInt]: TBLFontVariationItem read GetItem; default;
  end;
  PBLFontVariationSettingsView = ^TBLFontVariationSettingsView;

type
  /// <summary>
  ///  Font variation settings.
  /// </summary>
  TBLFontVariationSettings = record
  {$REGION 'Internal Declarations'}
  private
    FBase: TBLObjectCore;
    function GetIsEmpty: Boolean; inline;
    function GetCount: NativeInt; inline;
    function GetCapacity: NativeInt; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Creates default initialized font variation settings.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Initialize(out ADest: TBLFontVariationSettings);

    /// <summary>
    ///  Destroys the font variation settings.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Finalize(var ADest: TBLFontVariationSettings);

    /// <summary>
    ///  Copy constructor makes a weak copy of the underlying representation of
    ///  the `ASrc` font variation settings.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Assign(var ADest: TBLFontVariationSettings; const [ref] ASrc: TBLFontVariationSettings); inline;

    /// <summary>
    ///  Used to compare against `nil` (empty font variation settings).
    /// </summary>
    class operator Equal(const ALeft: TBLFontVariationSettings; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two font variation settings instances are equal.
    /// </summary>
    class operator Equal(const ALeft, ARight: TBLFontVariationSettings): Boolean; inline; static;

    /// <summary>
    ///  Used to compare against `nil` (empty font variation settings).
    /// </summary>
    class operator NotEqual(const ALeft: TBLFontVariationSettings; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two font variation settings instances are not equal.
    /// </summary>
    class operator NotEqual(const ALeft, ARight: TBLFontVariationSettings): Boolean; inline; static;

    /// <summary>
    ///  Tests whether this and `AOther` font variation settings are equal.
    /// </summary>
    function Equals(const AOther: TBLFontVariationSettings): Boolean; inline;

    /// <summary>
    ///  Resets the font variation settings to a default constructed state.
    /// </summary>
    procedure Reset; inline;

    procedure Clear; inline;

    /// <summary>
    ///  Swaps the underlying representation with `AOther`.
    /// </summary>
    procedure Swap(var AOther: TBLFontVariationSettings); inline;

    /// <summary>
    ///  Returns a normalized view of tag/value pairs.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function View: TBLFontVariationSettingsView; inline;

    /// <summary>
    ///  Tests whether the settings contains the given `AVariationTag`.
    /// </summary>
    function HasValue(const AVariationTag: TBLTag): Boolean; inline;

    /// <summary>
    ///  Returns the value associated with the given `AVariationTag`.
    ///
    ///  If the `AVariationTag` doesn't exist or is invalid `NaN` is returned.
    /// </summary>
    function GetValue(const AVariationTag: TBLTag): Single; inline;

    /// <summary>
    ///  Sets or inserts the given `AVariationTag` to the settings, associating
    ///  the `AVariationTag` with `AValue`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetValue(const ATag: TBLTag; const AValue: Single); inline;

    /// <summary>
    ///  Removes the given `AVariationTag` and its associated value from the
    ///  settings.
    ///
    ///  Nothing happens if the `AVariationTag` is not in the settings.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure RemoveValue(const AVariationTag: TBLTag); inline;

    /// <summary>
    ///  Whether the container is empty, which means that no tag/value pairs are
    ///  stored in it.
    /// </summary>
    property IsEmpty: Boolean read GetIsEmpty;

    /// <summary>
    ///  The number of variation tag/value pairs stored in the container.
    /// </summary>
    property Count: NativeInt read GetCount;

    /// <summary>
    ///  The container capacity.
    /// </summary>
    property Capacity: NativeInt read GetCapacity;

    /// <summary>
    ///  The value associated with the given `AVariationTag`.
    ///
    ///  See `GetValue` and `SetValue` for more information.
    /// </summary>
    /// <seealso cref="GetValue"/>
    /// <seealso cref="SetValue"/>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property Values[const AVariationTag: TBLTag]: Single read GetValue write SetValue;
  end;

type
  /// <summary>
  ///  Font.
  /// </summary>
  TBLFont = record
  {$REGION 'Internal Declarations'}
  private type
    TImpl = record
    public
      Face: TBLObjectCore;
      Weight: UInt16;
      Stretch: UInt8;
      Style: UInt8;
      Reserved: UInt32;
      Metrics: TBLFontMetrics;
      Matrix: TBLFontMatrix;
      FeatureSettings: TBLObjectCore;
      VariationSettings: TBLObjectCore;
    end;
    PImpl = ^TImpl;
  private
    FBase: TBLObjectCore;
    function GetIsValid: Boolean; inline;
    function GetIsEmpty: Boolean; inline;
    function GetFaceType: TBLFontFaceType; inline;
    function GetFaceFlags: TBLFontFaceFlags; inline;
    function GetSize: Single; inline;
    procedure SetSize(const AValue: Single); inline;
    function GetFace: TBLFontFace; inline;
    function GetWeight: TBLFontWeight; inline;
    function GetStretch: TBLFontStretch; inline;
    function GetStyle: TBLFontStyle; inline;
    function GetUnitsPerEm: Integer; inline;
    function GetMatrix: TBLFontMatrix; inline;
    function GetMetrics: PBLFontMetrics; inline;
    function GetDesignMetrics: PBLFontDesignMetrics; inline;
    function GetFeatureSettings: TBLFontFeatureSettings; inline;
    procedure SetFeatureSettings(const AValue: TBLFontFeatureSettings); inline;
    function GetVariationSettings: TBLFontVariationSettings; inline;
    procedure SetVariationSettings(const AValue: TBLFontVariationSettings); inline;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Creates a default initialized font.
    ///
    ///  A default initialized font is not a valid font that could be used for
    ///  rendering. It can be considered an empty or null font, which has no
    ///  family, no glyphs, no tables, it's essentially empty.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Initialize(out ADest: TBLFont);

    /// <summary>
    ///  Destroys the font.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Finalize(var ADest: TBLFont);

    /// <summary>
    ///  Copy constructor makes a weak copy of the underlying representation of
    ///  the `ASrc` font.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Assign(var ADest: TBLFont; const [ref] ASrc: TBLFont); inline;

    /// <summary>
    ///  Used to compare against `nil` (null font).
    /// </summary>
    class operator Equal(const ALeft: TBLFont; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two fonts are equal (have the same contents).
    /// </summary>
    class operator Equal(const ALeft, ARight: TBLFont): Boolean; inline; static;

    /// <summary>
    ///  Used to compare against `nil` (null font).
    /// </summary>
    class operator NotEqual(const ALeft: TBLFont; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two fonts are not equal (do not have the same contents).
    /// </summary>
    class operator NotEqual(const ALeft, ARight: TBLFont): Boolean; inline; static;

    /// <summary>
    ///  Tests whether this and `AOther` fonts are equal.
    /// </summary>
    function Equals(const AOther: TBLFont): Boolean; inline;

    /// <summary>
    ///  Resets the font to a default constructed state.
    /// </summary>
    procedure Reset; inline;

    /// <summary>
    ///  Swaps the underlying representation of this font with the `AOther` font.
    /// </summary>
    procedure Swap(var AOther: TBLFont); inline;

    /// <summary>
    ///  Creates a new font from the existing font `AFace` scaled to the given
    ///  `ASize`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure MakeFromFace(const AFace: TBLFontFace; const ASize: Single); overload; inline;

    /// <summary>
    ///  Creates a new font from the existing font `AFace` scaled to the given
    ///  `ASize`.
    ///
    ///  This is an overloaded function that takes additional argument
    ///  `AFeatureSettings`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure MakeFromFace(const AFace: TBLFontFace; const ASize: Single;
      const AFeatureSettings: TBLFontFeatureSettings); overload; inline;

    /// <summary>
    ///  Creates a new font from the existing font `AFace` scaled to the given
    ///  `ASize`.
    ///
    ///  This is an overloaded function that takes additional arguments, which
    ///  are used to override font `AFeatureSettings` and font `AVariationSettings`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure MakeFromFace(const AFace: TBLFontFace; const ASize: Single;
      const AFeatureSettings: TBLFontFeatureSettings;
      const AVariationSettings: TBLFontVariationSettings); overload; inline;

    /// <summary>
    ///  Resets font feature settings.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ResetFeatureSettings; inline;

    /// <summary>
    ///  Resets font variation settings.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ResetVariationSettings; inline;

    procedure Shape(const AGB: TBLGlyphBuffer); inline;

    procedure MapTextToGlyphs(const AGB: TBLGlyphBuffer); overload; inline;
    procedure MapTextToGlyphs(const AGB: TBLGlyphBuffer;
      out AStateOut: TBLGlyphMappingState); overload; inline;

    procedure PositionGlyphs(const AGB: TBLGlyphBuffer); inline;
    procedure ApplyKerning(const AGB: TBLGlyphBuffer); inline;
    procedure ApplyGSub(const AGB: TBLGlyphBuffer;
      const ALookups: TBLBitArray); inline;
    procedure ApplyGPos(const AGB: TBLGlyphBuffer;
      const ALookups: TBLBitArray); inline;
    procedure GetTextMetrics(const AGB: TBLGlyphBuffer;
      out AMetrics: TBLTextMetrics); inline;

    procedure GetGlyphBounds(const AGlyphData: PUInt32;
      const AGlyphAdvance, ACount: NativeInt; out ABounds: PBLBoxI); overload; inline;
    function GetGlyphBounds(const AGlyphData: PUInt32;
      const AGlyphAdvance, ACount: NativeInt): TArray<TBLBoxI>; overload; inline;

    procedure GetGlyphAdvances(const AGlyphData: PUInt32;
      const AGlyphAdvance, ACount: NativeInt; out APlacements: PBLGlyphPlacement); overload; inline;
    function GetGlyphAdvances(const AGlyphData: PUInt32;
      const AGlyphAdvance, ACount: NativeInt): TArray<TBLGlyphPlacement>; overload; inline;

    /// <summary>
    ///  Retrieves outlines of a single glyph into the `AOut` path.
    ///
    ///  Optionally, a user can provide a `ASink` function with `AUserData`,
    ///  which will be called periodically by the glyph outline decoder. The
    ///  `ASink` can be used to immediately process the outline to prevent
    ///  accumulating a large path in `AOut`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure GetGlyphOutlines(const AGlyphId: TBLGlyphId; const AOut: TBLPath;
      const ASink: TBLPathSinkFunc = nil; const AUserData: Pointer = nil); overload; inline;

    /// <summary>
    ///  Retrieves outlines of a single glyph into the `AOut` path transformed
    ///  by `AUsserTransform`.
    ///
    ///  Optionally, a user can provide a `ASink` function with `AUserData`,
    ///  which will be called periodically by the glyph outline decoder. The
    ///  `ASink` can be used to immediately process the outline to prevent
    ///  accumulating a large path in `AOut`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure GetGlyphOutlines(const AGlyphId: TBLGlyphId;
      const AUserTransform: TBLMatrix2D; const AOut: TBLPath;
      const ASink: TBLPathSinkFunc = nil; const AUserData: Pointer = nil); overload; inline;

    /// <summary>
    ///  Retrieves outlines of a glyph run into the `AOut` path.
    ///
    ///  Optionally, a user can provide a `ASink` function with `AUserData`,
    ///  which will be called periodically by the glyph outline decoder. The
    ///  `ASink` can be used to immediately process the outline to prevent
    ///  accumulating a large path in `AOut`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure GetGlyphRunOutlines(const AGlyphRun: TBLGlyphRun;
      const AOut: TBLPath; const ASink: TBLPathSinkFunc = nil;
      const AUserData: Pointer = nil); overload; inline;

    /// <summary>
    ///  Retrieves outlines of a glyph run into the `AOut` path transformed by
    ///  `AUserTransform`.
    ///
    ///  Optionally, a user can provide a `ASink` function with `AUserData`,
    ///  which will be called periodically by the glyph outline decoder. The
    ///  `ASink` can be used to immediately process the outline to prevent
    ///  accumulating a large path in `AOut`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure GetGlyphRunOutlines(const AGlyphRun: TBLGlyphRun;
      const AUserTransform: TBLMatrix2D; const AOut: TBLPath;
      const ASink: TBLPathSinkFunc = nil; const AUserData: Pointer = nil); overload; inline;

    /// <summary>
    ///  Whether the font is a valid instance.
    /// </summary>
    property IsValid: Boolean read GetIsValid;

    /// <summary>
    ///  Tests whether the font is empty, which is the same as `not IsValid`.
    /// </summary>
    property IsEmpty: Boolean read GetIsEmpty;

    /// <summary>
    ///  The type of the font's associated font face.
    /// </summary>
    property FaceType: TBLFontFaceType read GetFaceType;

    /// <summary>
    ///  The flags of the font.
    /// </summary>
    property FaceFlags: TBLFontFaceFlags read GetFaceFlags;

    /// <summary>
    ///  The size of the font.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property Size: Single read GetSize write SetSize;

    /// <summary>
    ///  The font's associated font face.
    ///
    ///  Returns the same font face, which was passed to `MakeFromFace`.
    /// </summary>
    /// <seealso cref="MakeFromFace"/>
    property Face: TBLFontFace read GetFace;

    /// <summary>
    ///  The weight of the font.
    /// </summary>
    property Weight: TBLFontWeight read GetWeight;

    /// <summary>
    ///  The stretch of the font.
    /// </summary>
    property Stretch: TBLFontStretch read GetStretch;

    /// <summary>
    ///  The style of the font.
    /// </summary>
    property Style: TBLFontStyle read GetStyle;

    /// <summary>
    ///  The "units per em" (UPEM) of the font's associated font face.
    /// </summary>
    property UnitsPerEm: Integer read GetUnitsPerEm;

    /// <summary>
    ///  A 2x2 matrix of the font.
    ///
    ///  The returned `TBLFontMatrix` is used to scale fonts from design units
    ///  into user units. The matrix usually has a negative `M11` member as
    ///  fonts use a different coordinate system than Blend2D.
    /// </summary>
    property Matrix: TBLFontMatrix read GetMatrix;

    /// <summary>
    ///  The scaled metrics of the font.
    ///
    ///  The returned metrics is a scale of design metrics that match the font
    ///  size and its options.
    /// </summary>
    property Metrics: PBLFontMetrics read GetMetrics;

    /// <summary>
    ///  The design metrics of the font.
    ///
    ///  The returned metrics is compatible with the metrics of `TBLFontFace`
    ///  associated with this font.
    /// </summary>
    /// <seealso cref="TBLFontFace"/>
    property DesignMetrics: PBLFontDesignMetrics read GetDesignMetrics;

    /// <summary>
    ///  Font feature settings.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property FeatureSettings: TBLFontFeatureSettings read GetFeatureSettings write SetFeatureSettings;

    /// <summary>
    ///  Font variation settings.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property VariationSettings: TBLFontVariationSettings read GetVariationSettings write SetVariationSettings;
  end;

{ ============================================================================
   [Text - Font Management]
  ============================================================================ }

type
  /// <summary>
  ///  Properties that can be used to query `TBLFont` and `TBLFontFace`.
  /// </summary>
  /// <seealso cref="TBLFont"/>
  /// <seealso cref="TBLFontFace"/>
  /// <seealso cref="TBLFontManager"/>
  TBLFontQueryProperties = record
  public
    /// <summary>
    ///  Font style.
    /// </summary>
    Style: TBLFontStyle;

    /// <summary>
    ///  Font weight.
    /// </summary>
    Weight: TBLFontWeight;

    /// <summary>
    ///  Font stretch.
    /// </summary>
    Stretch: TBLFontStretch;
  public
    procedure Reset; inline;
  end;
  PBLFontQueryProperties = ^TBLFontQueryProperties;

type
  /// <summary>
  ///  Font manager.
  /// </summary>
  TBLFontManager = record
  {$REGION 'Internal Declarations'}
  private
    FBase: TBLObjectCore;
    function GetIsValid: Boolean; inline;
    function GetFaceCount: NativeInt; inline;
    function GetFamilyCount: NativeInt; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Creates a default initialized font manager.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Initialize(out ADest: TBLFontManager);

    /// <summary>
    ///  Destroys the font manager.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Finalize(var ADest: TBLFontManager);

    /// <summary>
    ///  Copy constructor makes a weak copy of the underlying representation of
    ///  the `ASrc` font manager.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Assign(var ADest: TBLFontManager; const [ref] ASrc: TBLFontManager); inline;

    /// <summary>
    ///  Used to compare against `nil` (null font manager).
    /// </summary>
    class operator Equal(const ALeft: TBLFontManager; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two font managers are equal (have the same contents).
    /// </summary>
    class operator Equal(const ALeft, ARight: TBLFontManager): Boolean; inline; static;

    /// <summary>
    ///  Used to compare against `nil` (null font manager).
    /// </summary>
    class operator NotEqual(const ALeft: TBLFontManager; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two font managers are not equal (do not have the same contents).
    /// </summary>
    class operator NotEqual(const ALeft, ARight: TBLFontManager): Boolean; inline; static;

    /// <summary>
    ///  Tests whether this and `AOther` font managers are equal.
    /// </summary>
    function Equals(const AOther: TBLFontManager): Boolean; inline;

    /// <summary>
    ///  Resets the font manager to a default constructed state.
    /// </summary>
    procedure Reset; inline;

    /// <summary>
    ///  Swaps the underlying representation of this font manager with the
    ///  `AOther` font manager.
    /// </summary>
    procedure Swap(var AOther: TBLFontManager); inline;

    /// <summary>
    ///  Makes a valid `TBLFontManager` instance.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Make; inline;

    /// <summary>
    ///  Tests whether the font manager contains the given font `AFace`.
    /// </summary>
    function HasFace(const AFace: TBLFontFace): Boolean; inline;

    /// <summary>
    ///  Adds a font `AFace` to the font manager.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure. For example if the font `AFace` is invalid.</exception>
    procedure AddFace(const AFace: TBLFontFace); inline;

    /// <summary>
    ///  Queries a font face by family `AName` and returns the result.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function QueryFace(const AName: String): TBLFontFace; overload; inline;

    /// <summary>
    ///  Queries a font face by family `AName` and returns the result.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function QueryFace(const AName: TBLStringView): TBLFontFace; overload; inline;

    /// <summary>
    ///  Queries a font face by family `AName` and returns the result.
    ///
    ///  An `AProperties` parameter contains query properties that the query
    ///  engine will consider when doing the match. The best candidate will be
    ///  selected based on the following rules:
    ///
    ///    - Style has the highest priority.
    ///    - Weight has the lowest priority.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function QueryFace(const AName: String;
      const AProperties: TBLFontQueryProperties): TBLFontFace; overload; inline;

    /// <summary>
    ///  Queries a font face by family `AName` and returns the result.
    ///
    ///  An `AProperties` parameter contains query properties that the query
    ///  engine will consider when doing the match. The best candidate will be
    ///  selected based on the following rules:
    ///
    ///    - Style has the highest priority.
    ///    - Weight has the lowest priority.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function QueryFace(const AName: TBLStringView;
      const AProperties: TBLFontQueryProperties): TBLFontFace; overload; inline;

    /// <summary>
    ///  Queries all font faces by family `AName`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function QueryFacesByFamilyName(const AName: String): TArray<TBLFontFace>; overload; inline;

    /// <summary>
    ///  Queries all font faces by family `AName` and stores the result to `AOut`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure QueryFacesByFamilyName(const AName: String;
      const AOut: TBLArray<TBLFontFace>); overload; inline;

    /// <summary>
    ///  Queries all font faces by family `AName`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function QueryFacesByFamilyName(const AName: TBLStringView): TArray<TBLFontFace>; overload; inline;

    /// <summary>
    ///  Queries all font faces by family `AName` and stores the result to `AOut`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure QueryFacesByFamilyName(const AName: TBLStringView;
      const AOut: TBLArray<TBLFontFace>); overload; inline;

    /// <summary>
    ///  Whether the font manager is a valid `TBLFontManager` and not a built-in
    ///  default instance.
    /// </summary>
    property IsValid: Boolean read GetIsValid;

    /// <summary>
    ///  The number of `TBLFontFace` instances the font manager holds.
    /// </summary>
    /// <seealso cref="TBLFontFace"/>
    property FaceCount: NativeInt read GetFaceCount;

    /// <summary>
    ///  The number of unique font families the font manager holds.
    /// </summary>
    property FamilyCount: NativeInt read GetFamilyCount;
  end;

{$ENDREGION 'Text'}

{$REGION 'Variant'}
type
  /// <summary>
  ///  Blend2D variant.
  /// </summary>
  TBLVar = record
  {$REGION 'Internal Declarations'}
  private
    FBase: TBLObjectCore;
    class function GetNull: TBLVar; inline; static;
    function GetObjectType: TBLObjectType; inline;
    function GetIsArray: Boolean; inline;
    function GetIsBitArray: Boolean; inline;
    function GetIsBoolean: Boolean; inline;
    function GetIsContext: Boolean; inline;
    function GetIsDouble: Boolean; inline;
    function GetIsFont: Boolean; inline;
    function GetIsFontData: Boolean; inline;
    function GetIsFontFace: Boolean; inline;
    function GetIsFontManager: Boolean; inline;
    function GetIsGradient: Boolean; inline;
    function GetIsImage: Boolean; inline;
    function GetIsImageCodec: Boolean; inline;
    function GetIsImageDecoder: Boolean; inline;
    function GetIsImageEncoder: Boolean; inline;
    function GetIsInt64: Boolean; inline;
    function GetIsNull: Boolean; inline;
    function GetIsPath: Boolean; inline;
    function GetIsPattern: Boolean; inline;
    function GetIsString: Boolean; inline;
    function GetIsRgba: Boolean; inline;
    function GetIsRgba32: Boolean; inline;
    function GetIsRgba64: Boolean; inline;
    function GetIsUInt64: Boolean; inline;
    function GetIsStyle: Boolean; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Creates a default initialized variant.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Initialize(out ADest: TBLVar);

    /// <summary>
    ///  Destroys the variant.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Finalize(var ADest: TBLVar);

    /// <summary>
    ///  Copy constructor makes a weak copy of the underlying representation of
    ///  the `ASrc` variant.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Assign(var ADest: TBLVar; const [ref] ASrc: TBLVar); inline;

    /// <summary>
    ///  Returns True if two variants are equal (have the same contents).
    /// </summary>
    class operator Equal(const ALeft, ARight: TBLVar): Boolean; inline; static;
    class operator Equal(const ALeft: TBLVar; const ARight: Boolean): Boolean; inline; static;
    class operator Equal(const ALeft: TBLVar; const ARight: Integer): Boolean; inline; static;
    class operator Equal(const ALeft: TBLVar; const ARight: Cardinal): Boolean; inline; static;
    class operator Equal(const ALeft: TBLVar; const ARight: Int64): Boolean; inline; static;
    class operator Equal(const ALeft: TBLVar; const ARight: UInt64): Boolean; inline; static;
    class operator Equal(const ALeft: TBLVar; const ARight: Double): Boolean; inline; static;
    class operator Equal(const ALeft: TBLVar; const ARight: TBLRgba): Boolean; inline; static;
    class operator Equal(const ALeft: TBLVar; const ARight: TBLRgba32): Boolean; inline; static;
    class operator Equal(const ALeft: TBLVar; const ARight: TBLRgba64): Boolean; inline; static;
    class operator Equal(const ALeft: TBLVar; const ARight: TBLBitArray): Boolean; inline; static;
    class operator Equal(const ALeft: TBLVar; const ARight: TBLFont): Boolean; inline; static;
    class operator Equal(const ALeft: TBLVar; const ARight: TBLFontData): Boolean; inline; static;
    class operator Equal(const ALeft: TBLVar; const ARight: TBLFontFace): Boolean; inline; static;
    class operator Equal(const ALeft: TBLVar; const ARight: TBLFontManager): Boolean; inline; static;
    class operator Equal(const ALeft: TBLVar; const ARight: TBLGradient): Boolean; inline; static;
    class operator Equal(const ALeft: TBLVar; const ARight: TBLImage): Boolean; inline; static;
    class operator Equal(const ALeft: TBLVar; const ARight: TBLImageCodec): Boolean; inline; static;
    class operator Equal(const ALeft: TBLVar; const ARight: TBLImageDecoder): Boolean; inline; static;
    class operator Equal(const ALeft: TBLVar; const ARight: TBLImageEncoder): Boolean; inline; static;
    class operator Equal(const ALeft: TBLVar; const ARight: TBLPath): Boolean; inline; static;
    class operator Equal(const ALeft: TBLVar; const ARight: TBLPattern): Boolean; inline; static;
    class operator Equal(const ALeft: TBLVar; const ARight: TBLString): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two variants are not equal (do not have the same contents).
    /// </summary>
    class operator NotEqual(const ALeft, ARight: TBLVar): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLVar; const ARight: Boolean): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLVar; const ARight: Integer): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLVar; const ARight: Cardinal): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLVar; const ARight: Int64): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLVar; const ARight: UInt64): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLVar; const ARight: Double): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLVar; const ARight: TBLRgba): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLVar; const ARight: TBLRgba32): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLVar; const ARight: TBLRgba64): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLVar; const ARight: TBLBitArray): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLVar; const ARight: TBLFont): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLVar; const ARight: TBLFontData): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLVar; const ARight: TBLFontFace): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLVar; const ARight: TBLFontManager): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLVar; const ARight: TBLGradient): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLVar; const ARight: TBLImage): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLVar; const ARight: TBLImageCodec): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLVar; const ARight: TBLImageDecoder): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLVar; const ARight: TBLImageEncoder): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLVar; const ARight: TBLPath): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLVar; const ARight: TBLPattern): Boolean; inline; static;
    class operator NotEqual(const ALeft: TBLVar; const ARight: TBLString): Boolean; inline; static;

    /// <summary>
    ///  Tests whether this and `AOther` variants are equal.
    /// </summary>
    function Equals(const AOther: TBLVar): Boolean; overload; inline;
    function Equals(const AOther: Boolean): Boolean; overload; inline;
    function Equals(const AOther: Integer): Boolean; overload; inline;
    function Equals(const AOther: Cardinal): Boolean; overload; inline;
    function Equals(const AOther: Int64): Boolean; overload; inline;
    function Equals(const AOther: UInt64): Boolean; overload; inline;
    function Equals(const AOther: Double): Boolean; overload; inline;
    function Equals(const AOther: TBLRgba): Boolean; overload; inline;
    function Equals(const AOther: TBLRgba32): Boolean; overload; inline;
    function Equals(const AOther: TBLRgba64): Boolean; overload; inline;
    function Equals(const AOther: TBLBitArray): Boolean; overload; inline;
    function Equals(const AOther: TBLFont): Boolean; overload; inline;
    function Equals(const AOther: TBLFontData): Boolean; overload; inline;
    function Equals(const AOther: TBLFontFace): Boolean; overload; inline;
    function Equals(const AOther: TBLFontManager): Boolean; overload; inline;
    function Equals(const AOther: TBLGradient): Boolean; overload; inline;
    function Equals(const AOther: TBLImage): Boolean; overload; inline;
    function Equals(const AOther: TBLImageCodec): Boolean; overload; inline;
    function Equals(const AOther: TBLImageDecoder): Boolean; overload; inline;
    function Equals(const AOther: TBLImageEncoder): Boolean; overload; inline;
    function Equals(const AOther: TBLPath): Boolean; overload; inline;
    function Equals(const AOther: TBLPattern): Boolean; overload; inline;
    function Equals(const AOther: TBLString): Boolean; overload; inline;

    function StrictEquals(const AOther: TBLVar): Boolean; inline;

    class operator Implicit(const AValue: Boolean): TBLVar; inline; static;
    class operator Implicit(const AValue: Integer): TBLVar; inline; static;
    class operator Implicit(const AValue: Cardinal): TBLVar; inline; static;
    class operator Implicit(const AValue: Int64): TBLVar; inline; static;
    class operator Implicit(const AValue: UInt64): TBLVar; inline; static;
    class operator Implicit(const AValue: Double): TBLVar; inline; static;
    class operator Implicit(const AValue: TBLRgba): TBLVar; inline; static;
    class operator Implicit(const AValue: TBLRgba32): TBLVar; inline; static;
    class operator Implicit(const AValue: TBLRgba64): TBLVar; inline; static;
    class operator Implicit(const AValue: TBLBitArray): TBLVar; inline; static;
    class operator Implicit(const AValue: TBLFont): TBLVar; inline; static;
    class operator Implicit(const AValue: TBLFontData): TBLVar; inline; static;
    class operator Implicit(const AValue: TBLFontFace): TBLVar; inline; static;
    class operator Implicit(const AValue: TBLFontManager): TBLVar; inline; static;
    class operator Implicit(const AValue: TBLGradient): TBLVar; inline; static;
    class operator Implicit(const AValue: TBLImage): TBLVar; inline; static;
    class operator Implicit(const AValue: TBLImageCodec): TBLVar; inline; static;
    class operator Implicit(const AValue: TBLImageDecoder): TBLVar; inline; static;
    class operator Implicit(const AValue: TBLImageEncoder): TBLVar; inline; static;
    class operator Implicit(const AValue: TBLPath): TBLVar; inline; static;
    class operator Implicit(const AValue: TBLPattern): TBLVar; inline; static;
    class operator Implicit(const AValue: TBLString): TBLVar; inline; static;

    /// <summary>
    ///  Converts this value to `Boolean`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function ToBoolean: Boolean; inline;

    /// <summary>
    ///  Converts this value to `Integer`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function ToInteger: Integer; inline;

    /// <summary>
    ///  Converts this value to `Cardinal`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function ToCardinal: Cardinal; inline;

    /// <summary>
    ///  Converts this value to `Int64`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function ToInt64: Int64; inline;

    /// <summary>
    ///  Converts this value to `UInt64`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function ToUInt64: UInt64; inline;

    /// <summary>
    ///  Converts this value to `Double`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function ToDouble: Double; inline;

    /// <summary>
    ///  Converts this value to `TBLRgba`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function ToRgba: TBLRgba; inline;

    /// <summary>
    ///  Converts this value to `TBLRgba32`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function ToRgba32: TBLRgba32; inline;

    /// <summary>
    ///  Converts this value to `TBLRgba64`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    function ToRgba64: TBLRgba64; inline;

    /// <summary>
    ///  Resets the variant to a default constructed state.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Reset; inline;

    /// <summary>
    ///  Swaps the underlying representation of this variant with the
    ///  `AOther` variant.
    /// </summary>
    procedure Swap(var AOther: TBLVar); inline;

    class property Null: TBLVar read GetNull;

    /// <summary>
    ///  The type of the underlying object.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property ObjectType: TBLObjectType read GetObjectType;

    /// <summary>
    ///  Whether this `TBLVar` instance represents a `TBLArray<T>` storing any
    ///  supported type.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property IsArray: Boolean read GetIsArray;

    /// <summary>
    ///  Whether this `TBLVar` instance represents `TBLBitArray`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property IsBitArray: Boolean read GetIsBitArray;

    /// <summary>
    ///  Whether this `TBLVar` instance represents a boxed `Boolean` value.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property IsBoolean: Boolean read GetIsBoolean;

    /// <summary>
    ///  Whether this `TBLVar` instance represents `TBLContext`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property IsContext: Boolean read GetIsContext;

    /// <summary>
    ///  Whether this `TBLVar` instance represents a boxed `Double` value.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property IsDouble: Boolean read GetIsDouble;

    /// <summary>
    ///  Whether this `TBLVar` instance represents `TBLFont`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property IsFont: Boolean read GetIsFont;

    /// <summary>
    ///  Whether this `TBLVar` instance represents `TBLFontData`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property IsFontData: Boolean read GetIsFontData;

    /// <summary>
    ///  Whether this `TBLVar` instance represents `TBLFontFace`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property IsFontFace: Boolean read GetIsFontFace;

    /// <summary>
    ///  Whether this `TBLVar` instance represents `TBLFontManager`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property IsFontManager: Boolean read GetIsFontManager;

    /// <summary>
    ///  Whether this `TBLVar` instance represents `TBLGradient`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property IsGradient: Boolean read GetIsGradient;

    /// <summary>
    ///  Whether this `TBLVar` instance represents `TBLImage`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property IsImage: Boolean read GetIsImage;

    /// <summary>
    ///  Whether this `TBLVar` instance represents `TBLImageCodec`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property IsImageCodec: Boolean read GetIsImageCodec;

    /// <summary>
    ///  Whether this `TBLVar` instance represents `TBLImageDecoder`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property IsImageDecoder: Boolean read GetIsImageDecoder;

    /// <summary>
    ///  Whether this `TBLVar` instance represents `TBLImageEncoder`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property IsImageEncoder: Boolean read GetIsImageEncoder;

    /// <summary>
    ///  Whether this `TBLVar` instance represents a boxed `Int64` value.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property IsInt64: Boolean read GetIsInt64;

    /// <summary>
    ///  Whether this `TBLVar` instance represents a null value.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property IsNull: Boolean read GetIsNull;

    /// <summary>
    ///  Whether this `TBLVar` instance represents `TBLPath`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property IsPath: Boolean read GetIsPath;

    /// <summary>
    ///  Whether this `TBLVar` instance represents `TBLPattern`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property IsPattern: Boolean read GetIsPattern;

    /// <summary>
    ///  Whether this `TBLVar` instance represents `TBLString`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property IsString: Boolean read GetIsString;

    /// <summary>
    ///  Whether this `TBLVar` instance represents boxed `TBLRgba`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property IsRgba: Boolean read GetIsRgba;

    /// <summary>
    ///  Whether this `TBLVar` instance represents boxed `TBLRgba32`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property IsRgba32: Boolean read GetIsRgba32;

    /// <summary>
    ///  Whether this `TBLVar` instance represents boxed `TBLRgba64`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property IsRgba64: Boolean read GetIsRgba64;

    /// <summary>
    ///  Whether this `TBLVar` instance represents a boxed `UIn64` value.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property IsUInt64: Boolean read GetIsUInt64;

    /// <summary>
    ///  Whether this `TBLVar` instance is a style that can be used with the
    ///  rendering context.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property IsStyle: Boolean read GetIsStyle;
  end;
{$ENDREGION 'Variant'}

{$REGION 'Rendering'}
  /// <summary>
  ///  Rendering context type.
  /// </summary>
  TBLContextType = (
    /// <summary>
    ///  No rendering context.
    /// </summary>
    None,

    /// <summary>
    ///  Dummy rendering context.
    /// </summary>
    Dummy,

    /// <summary>
    ///  Software-accelerated rendering context.
    /// </summary>
    Raster = 3);

type
  /// <summary>
  ///  Rendering context hint.
  /// </summary>
  TBLContextHint = (
    /// <summary>
    ///  Rendering quality.
    /// </summary>
    RenderingQuality,

    /// <summary>
    ///  Gradient quality.
    /// </summary>
    GradientQuality,

    /// <summary>
    ///  Pattern quality.
    /// </summary>
    PatternQuality);

type
  /// <summary>
  ///  Describes a rendering context style slot - fill or stroke.
  /// </summary>
  TBLContextStyleSlot = (
    /// <summary>
    ///  Fill operation style slot.
    /// </summary>
    Fill,

    /// <summary>
    ///  Stroke operation style slot.
    /// </summary>
    Stroke);

type
  /// <summary>
  ///  The type of a text rendering operation.
  ///
  ///  This value specifies the type of the parameter passed to the text
  ///  rendering API.
  /// </summary>
  /// <remarks>
  ///  In most cases this should not be required to use by Blend2D users since
  ///  the API provides functions that use `TBLContextRenderTextOp` internally.
  /// </remarks>
  TBLContextRenderTextOp = (
    /// <summary>
    ///  UTF-8 text rendering operation - UTF-8 string passed as
    ///  `TBLStringView`, `TBLArrayView<Byte>` or `TBLArrayView<UTF8Char>`.
    /// </summary>
    Utf8 = Ord(TBLTextEncoding.Utf8),

    /// <summary>
    ///  UTF-16 text rendering operation - UTF-16 string passed as
    ///  `TBLArrayView<UInt16>` or `TBLArrayView<WideChar>`.
    /// </summary>
    Utf16 = Ord(TBLTextEncoding.Utf16),

    /// <summary>
    ///  UTF-32 text rendering operation - UTF-32 string passed as
    ///  `TBLArrayView<UInt32>` or `TBLArrayView<UCS4Char>`.
    /// </summary>
    Utf32 = Ord(TBLTextEncoding.Utf32),

    /// <summary>
    ///  LATIN1 text rendering operation - LATIN1 string is passed as
    ///  `TBLStringView`, `TBLArrayView<Byte>` or `TBLArrayView<AnsiChar>`.
    /// </summary>
    Latin1 = Ord(TBLTextEncoding.Latin1),

    /// <summary>
    ///  Glyph run text rendering operation - the `TBLGlyphRun` parameter is
    ///  passed.
    /// </summary>
    GlyphRun = 4);

type
  /// <summary>
  ///  Rendering context flush flags, used by `TBLContext.Flush`.
  /// </summary>
  /// <seealso cref="TBLContext.Flush"/>
  TBLContextFlushFlag = (
    _Reserved = 0,

    /// <summary>
    ///  Flushes the command queue and waits for its completion (will block
    ///  until done).
    /// </summary>
    Sync = 31);

  /// <summary>
  ///  Rendering context flush flags, used by `TBLContext.Flush`.
  /// </summary>
  /// <seealso cref="TBLContext.Flush"/>
  TBLContextFlushFlags = set of TBLContextFlushFlag;

  /// <summary>
  ///  Adds functionality to `TBLContextFlushFlags`.
  /// </summary>
  _TBLContextFlushFlagsHelper = record helper for TBLContextFlushFlags
  public const
    /// <summary>
    ///  No flags.
    /// </summary>
    None = [];
  end;

type
  /// <summary>
  ///  Rendering context creation flags.
  /// </summary>
  TBLContextCreateFlag = (
    /// <summary>
    ///  Disables JIT pipeline generator.
    /// </summary>
    DisableJit = 0,

    /// <summary>
    ///  Fallbacks to a synchronous rendering in case that the rendering engine
    ///  wasn't able to acquire threads. This flag only makes sense when the
    ///  asynchronous mode was specified by having `ThreadCount` greater than 0.
    ///  If the rendering context fails to acquire at least one thread it would
    ///  fallback to synchronous mode with no worker threads.
    /// </summary>
    /// <remarks>
    ///  If this flag is specified with `ThreadCount = 1` it means to
    ///  immediately fallback to synchronous rendering. It's only practical to
    ///  use this flag with 2 or more requested threads.
    /// </remarks>
    FallbackToSync = 20,

    /// <summary>
    ///  If this flag is specified and asynchronous rendering is enabled then
    ///  the context would create its own isolated  thread-pool, which is useful
    ///  for debugging purposes.
    ///
    ///  Do not use this flag in production as rendering contexts with isolated
    ///  thread-pool have to create and destroy all threads they use. This flag
    ///  is only useful for testing, debugging, and isolated benchmarking.
    /// </summary>
    IsolatedThreadPool = 24,

    /// <summary>
    ///  If this flag is specified and JIT pipeline generation enabled then the
    ///  rendering context would create its own isolated JIT runtime. which is
    ///  useful for debugging purposes. This flag will be ignored if JIT
    ///  pipeline compilation is either not supported or was disabled by other
    ///  flags.
    ///
    ///  Do not use this flag in production as rendering contexts with isolated
    ///  JIT runtime do not use global pipeline cache, that's it, after the
    ///  rendering context is destroyed the JIT runtime is destroyed with it
    ///  with all compiled pipelines. This flag is only useful for testing,
    ///  debugging, and isolated benchmarking.
    /// </summary>
    IsolatedJitRuntime = 25,

    /// <summary>
    ///  Enables logging to stderr of isolated runtime.
    /// </summary>
    /// <remarks>
    ///  Must be used with `IsolatedJitRuntime` otherwise it would have no
    ///  effect.
    /// </remarks>
    IsolatedJitLogging = 26,

    /// <summary>
    ///  Override CPU features when creating isolated context.
    /// </summary>
    OverrideCpuFeatures = 27);

  /// <summary>
  ///  Rendering context creation flags.
  /// </summary>
  TBLContextCreateFlags = set of TBLContextCreateFlag;

  /// <summary>
  ///  Adds functionality to `TBLContextCreateFlags`.
  /// </summary>
  _TBLContextCreateFlagsHelper = record helper for TBLContextCreateFlags
  public const
    /// <summary>
    ///  No flags.
    /// </summary>
    None = [];
  end;

type
  /// <summary>
  ///  Error flags that are accumulated during the rendering context lifetime
  ///  and that can be queried through `TBLContext.AccumulatedErrorFlags`. The
  ///  reason why these flags exist is that errors can happen during
  ///  asynchronous rendering, and there is no way the user can catch these
  ///  errors.
  /// </summary>
  /// <seealso cref="TBLContext.AccumulatedErrorFlags"/>
  TBLContextErrorFlag = (
    /// <summary>
    ///  The rendering context returned or encountered `TBLResult.InvalidValue`,
    ///  which is mostly related to the function argument handling. It's very
    ///  likely some argument was wrong when calling `TBLContext` API.
    /// </summary>
    InvalidValue = 0,

    /// <summary>
    ///  Invalid state describes something wrong, for example a pipeline
    ///  compilation error.
    /// </summary>
    InvalidState = 1,

    /// <summary>
    ///  The rendering context has encountered invalid geometry.
    /// </summary>
    InvalidGeometry = 2,

    /// <summary>
    ///  The rendering context has encountered invalid glyph.
    /// </summary>
    InvalidGlyph = 3,

    /// <summary>
    ///  The rendering context has encountered invalid or uninitialized font.
    /// </summary>
    InvalidFont = 4,

    /// <summary>
    ///  Thread pool was exhausted and couldn't acquire the requested number of
    ///  threads.
    /// </summary>
    ThreadPoolExhausted = 29,

    /// <summary>
    ///  Out of memory condition.
    /// </summary>
    OutOfMemory = 30,

    /// <summary>
    ///  Unknown error, which we don't have flag for.
    /// </summary>
    UnknownError = 31);

  /// <summary>
  ///  Error flags that are accumulated during the rendering context lifetime.
  /// </summary>
  TBLContextErrorFlags = set of TBLContextErrorFlag;

  /// <summary>
  ///  Adds functionality to `TBLContextErrorFlags`.
  /// </summary>
  _TBLContextErrorFlagsHelper = record helper for TBLContextErrorFlags
  public const
    /// <summary>
    ///  No flags.
    /// </summary>
    None = [];
  end;

type
  /// <summary>
  ///  Specifies the behavior of `TBLContext.SwapStyles` operation.
  /// </summary>
  /// <seealso cref="TBLContext.SwapStyles"/>
  TBLContextStyleSwapMode = (
    /// <summary>
    ///  Swap only fill and stroke styles without affecting fill and stroke alpha.
    /// </summary>
    Styles,

    /// <summary>
    ///  Swap both fill and stroke styles and their alpha values.
    /// </summary>
    StyledWithAlpha);

type
  /// <summary>
  ///  Specifies how style transformation matrix is combined with the rendering
  ///  context transformation matrix, used by `TBLContext.SetStyle` function.
  /// </summary>
  /// <seealso cref="TBLContext.SetStyle"/>
  TBLContextStyleTransformMode = (
    /// <summary>
    ///  Style transformation matrix should be transformed with the rendering
    ///  context user and meta matrix (default).
    /// </summary>
    /// <remarks>
    ///  This transformation mode is identical to how user geometry is
    ///  transformed and it's the default transformation and most likely the
    ///  behavior expected in most cases.
    /// </remarks>
    User,

    /// <summary>
    ///  Style transformation matrix should be transformed with the rendering
    ///  context meta matrix.
    /// </summary>
    Meta,

    /// <summary>
    ///  Style transformation matrix is considered absolute, and is not combined
    ///  with a rendering context transform.
    /// </summary>
    None);

type
  /// <summary>
  ///  Composition & blending operator.
  /// </summary>
  TBLCompOp = (
    /// <summary>
    ///  Source-over [default].
    /// </summary>
    SrcOver,

    /// <summary>
    ///  Source-copy.
    /// </summary>
    SrcCopy,

    /// <summary>
    ///  Source-in.
    /// </summary>
    SrcIn,

    /// <summary>
    ///  Source-out.
    /// </summary>
    SrcOut,

    /// <summary>
    ///  Source-atop.
    /// </summary>
    SrcAtop,

    /// <summary>
    ///  Destination-over.
    /// </summary>
    DstOver,

    /// <summary>
    ///  Destination-copy [nop].
    /// </summary>
    DstCopy,

    /// <summary>
    ///  Destination-in.
    /// </summary>
    DstIn,

    /// <summary>
    ///  Destination-out.
    /// </summary>
    DstOut,

    /// <summary>
    ///  Destination-atop.
    /// </summary>
    DstAtop,

    /// <summary>
    ///  Xor.
    /// </summary>
    ExclusiveOr,

    /// <summary>
    ///  Clear.
    /// </summary>
    Clear,

    /// <summary>
    ///  Plus.
    /// </summary>
    Plus,

    /// <summary>
    ///  Minus.
    /// </summary>
    Minus,

    /// <summary>
    ///  Modulate.
    /// </summary>
    Modulate,

    /// <summary>
    ///  Multiply.
    /// </summary>
    Multiply,

    /// <summary>
    ///  Screen.
    /// </summary>
    Screen,

    /// <summary>
    ///  Overlay.
    /// </summary>
    Overlay,

    /// <summary>
    ///  Darken.
    /// </summary>
    Darken,

    /// <summary>
    ///  Lighten.
    /// </summary>
    Lighten,

    /// <summary>
    ///  Color dodge.
    /// </summary>
    ColorDodge,

    /// <summary>
    ///  Color burn.
    /// </summary>
    ColorBurn,

    /// <summary>
    ///  Linear burn.
    /// </summary>
    LinearBurn,

    /// <summary>
    ///  Linear light.
    /// </summary>
    LinearLight,

    /// <summary>
    ///  Pin light.
    /// </summary>
    PinLight,

    /// <summary>
    ///  Hard-light.
    /// </summary>
    HardLight,

    /// <summary>
    ///  Soft-light.
    /// </summary>
    SoftLight,

    /// <summary>
    ///  Difference.
    /// </summary>
    Difference,

    /// <summary>
    ///  Exclusion.
    /// </summary>
    Exclusion);

type
  /// <summary>
  ///  Rendering quality.
  /// </summary>
  TBLRenderingQuality = (
    /// <summary>
    ///  Render using anti-aliasing.
    /// </summary>
    AntiAlias);

type
  /// <summary>
  ///  Information that can be used to customize the rendering context.
  /// </summary>
  TBLContextCreateInfo = record
  public
    /// <summary>
    ///  Create flags.
    /// </summary>
    Flags: TBLContextCreateFlags;

    /// <summary>
    ///  Number of worker threads to use for asynchronous rendering, if non-zero.
    ///
    ///  If `ThreadCount` is zero it means to initialize the context for
    ///  synchronous rendering. This means that every operation will take effect
    ///  immediately. If `ThreadCount` is `1` it means that the rendering will
    ///  be asynchronous, but no thread would be acquired from a thread-pool,
    ///  because the user thread will be used as a worker. And finally, if
    ///  `ThreadCount` is greater than `1` then total of `ThreadCount - 1`
    ///  threads will be acquired from thread-pool and used as additional
    ///  workers.
    /// </summary>
    ThreadCount: Integer;

    /// <summary>
    ///  CPU features to use in isolated JIT runtime (if supported), only used
    ///  when `Flags` contains `TBLContextCreateFlag.OverrideCpuFeatures`.
    /// </summary>
    CpuFeatures: Cardinal;

    /// <summary>
    ///  Maximum number of commands to be queued.
    ///
    ///  If this parameter is zero the queue size will be determined
    ///  automatically.
    /// </summary>
    CommandQueueLimit: Integer;

    /// <summary>
    ///  Maximum number of saved states.
    /// </summary>
    /// <remarks>
    ///  Zero value tells the rendering engine to use the default saved state
    ///  limit, which currently defaults to 4096 states. This option allows to
    ///  even increase or decrease the limit, depending on the use case.
    /// </remarks>
    SavedStateLimit: Integer;

    /// <summary>
    ///  Pixel origin.
    ///
    ///  Pixel origin is an offset in pixel units that can be used as an origin
    ///  for fetchers and effects that use a pixel X/Y coordinate in the
    ///  calculation. One example of using pixel origin is dithering, where it's
    ///  used to shift the dithering matrix.
    /// </summary>
    PixelOrigin: TBLPointI;

    /// <summary>
    ///  Reserved for future use, must be zero.
    /// </summary>
    _Reserved: Cardinal;
  public
    procedure Reset; inline;
  end;
  PBLContextCreateInfo = ^TBLContextCreateInfo;

type
  /// <summary>
  ///  Holds an arbitrary 128-bit value (cookie) that can be used to match other
  ///  cookies. Blend2D uses cookies in places where it allows to "lock" some
  ///  state that can only be unlocked by a matching cookie. Please don't
  ///  confuse cookies with a security of any kind, it's just an arbitrary data
  ///  that must match to proceed with a certain operation.
  ///
  ///  Cookies can be used with `TBLContext.Save` and `TBLContext.Restore`
  ///  operations.
  /// </summary>
  /// <seealso cref="TBLContext.Save"/>
  /// <seealso cref="TBLContext.Restore"/>
  TBLContextCookie = record
  {$REGION 'Internal Declarations'}
  private
    FData: array [0..1] of UInt64;
    function GetIsEmpty: Boolean; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    class operator Equal(const ALeft, ARight: TBLContextCookie): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLContextCookie): Boolean; inline; static;

    procedure Reset; overload; inline;
    procedure Reset(const AOther: TBLContextCookie); overload; inline;
    procedure Reset(const AData0, AData1: UInt64); overload; inline;

    function Equals(const AOther: TBLContextCookie): Boolean; inline;

    property IsEmpty: Boolean read GetIsEmpty;
  end;
  PBLContextCookie = ^TBLContextCookie;

type
  /// <summary>
  ///  Rendering context hints.
  /// </summary>
  TBLContextHints = record
  {$REGION 'Internal Declarations'}
  private
    function GetRenderingQuality: TBLRenderingQuality; inline;
    function GetGradientQuality: TBLGradientQuality; inline;
    function GetPatternQuality: TBLPatternQuality; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    Hints: array [TBLContextHint] of Byte;
  public
    procedure Reset; inline;

    property RenderingQuality: TBLRenderingQuality read GetRenderingQuality;
    property GradientQuality: TBLGradientQuality read GetGradientQuality;
    property PatternQuality: TBLPatternQuality read GetPatternQuality;
  end;
  PBLContextHints = ^TBLContextHints;

type
  /// <summary>
  ///  Rendering context.
  /// </summary>
  TBLContext = record
  {$REGION 'Internal Declarations'}
  private type
    TState = record
    public
      TargetImage: TBLObjectCore;
      Targetize: TBLSize;
      Hints: TBLContextHints;
      CompOp: Byte;
      FillRule: Byte;
      StyleType: array [0..1] of Byte;
      SavedStateCount: Int32;
      GlobalAlpha: Double;
      StyleAlpha: array [0..1] of Double;
      StrokeOptions: TBLStrokeOptions;
      ApproximationOptions: TBLApproximationOptions;
      MetaTransform: TBLMatrix2D;
      UserTransform: TBLMatrix2D;
      FinalTransform: TBLMatrix2D;
    end;
    PState = ^TState;
  private type
    TImpl = record
    public
      Virt: Pointer;
      State: PState;
      ContextType: UInt32;
    end;
    PImpl = ^TImpl;
  private
    FBase: TBLObjectCore;
    function GetTargetSize: TBLSize; inline;
    function GetTargetWidth: Double; inline;
    function GetTargetHeight: Double; inline;
    function GetTargetImage: TBLImage; inline;
    function GetContextType: TBLContextType; inline;
    function GetIsValid: Boolean; inline;
    function GetThreadCount: Integer; inline;
    function GetAccumulatedErrorFlags: TBLContextErrorFlags; inline;
    function GetSavedStateCount: Integer; inline;
    function GetMetaTransform: TBLMatrix2D; inline;
    function GetUserTransform: TBLMatrix2D; inline;
    procedure SetUserTransform(const AValue: TBLMatrix2D); inline;
    function GetFinalTransform: TBLMatrix2D; inline;
    function GetHints: TBLContextHints; inline;
    procedure SetHints(const AValue: TBLContextHints); inline;
    function GetRenderingQuality: TBLRenderingQuality; inline;
    procedure SetRenderingQuality(const AValue: TBLRenderingQuality); inline;
    function GetGradientQuality: TBLGradientQuality; inline;
    procedure SetGradientQuality(const AValue: TBLGradientQuality); inline;
    function GetPatternQuality: TBLPatternQuality; inline;
    procedure SetPatternQuality(const AValue: TBLPatternQuality); inline;
    function GetApproximationOptions: TBLApproximationOptions; inline;
    procedure SetApproximationOptions(const AValue: TBLApproximationOptions); inline;
    function GetFlattenMode: TBLFlattenMode; inline;
    procedure SetFlattenMode(const AValue: TBLFlattenMode); inline;
    function GetFlattenTolerance: Double; inline;
    procedure SetFlattenTolerance(const AValue: Double); inline;
    function GetCompOp: TBLCompOp; inline;
    procedure SetCompOp(const AValue: TBLCompOp); inline;
    function GetGlobalAlpha: Double; inline;
    procedure SetGlobalAlpha(const AValue: Double); inline;
    function GetStyleType(const ASlot: TBLContextStyleSlot): TBLObjectType; inline;
    function GetStyle(const ASlot: TBLContextStyleSlot): TBLVar; inline;
    function GetTransformedStyle(const ASlot: TBLContextStyleSlot): TBLVar; inline;
    function GetStyleAlpha(const ASlot: TBLContextStyleSlot): Double; inline;
    procedure SetStyleAlpha(const ASlot: TBLContextStyleSlot;
      const AValue: Double); inline;
    function GetFillStyleType: TBLObjectType; inline;
    function GetFillStyle: TBLVar; inline;
    function GetTransformedFillStyle: TBLVar; inline;
    function GetFillAlpha: Double; inline;
    procedure SetFillAlpha(const AValue: Double); inline;
    function GetFillRule: TBLFillRule; inline;
    procedure SetFillRule(const AValue: TBLFillRule); inline;
    function GetStrokeStyleType: TBLObjectType; inline;
    function GetStrokeStyle: TBLVar; inline;
    function GetTransformedStrokeStyle: TBLVar; inline;
    function GetStrokeWidth: Double; inline;
    procedure SetStrokeWidth(const AValue: Double); inline;
    function GetStrokeMiterLimit: Double; inline;
    procedure SetStrokeMiterLimit(const AValue: Double); inline;
    function GetStrokeJoin: TBLStrokeJoin; inline;
    procedure SetStrokeJoin(const AValue: TBLStrokeJoin); inline;
    function GetStrokeStartCap: TBLStrokeCap; inline;
    procedure SetStrokeStartCap(const AValue: TBLStrokeCap); inline;
    function GetStrokeEndCap: TBLStrokeCap; inline;
    procedure SetStrokeEndCap(const AValue: TBLStrokeCap); inline;
    function GetStrokeTransformOrder: TBLStrokeTransformOrder; inline;
    procedure SetStrokeTransformOrder(const AValue: TBLStrokeTransformOrder); inline;
    function GetStrokeDashOffset: Double; inline;
    procedure SetStrokeDashOffset(const AValue: Double); inline;
    function GetStrokeDashArray: TBLArray<Double>; inline;
    procedure SetStrokeDashArray(const AValue: TBLArray<Double>); inline;
    function GetStrokeOptions: TBLStrokeOptions; inline;
    procedure SetStrokeOptions(const AValue: TBLStrokeOptions); inline;
    function GetStrokeAlpha: Double; inline;
    procedure SetStrokeAlpha(const AValue: Double); inline;
  private
    function Impl: PImpl; inline;
    function State: PState; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    /// <summary>
    ///  Creates a default constructed rendering context.
    ///
    ///  Default constructed means that the instance is valid, but uninitialized,
    ///  which means the rendering context does not have attached any target. Any
    ///  attempt to use uninitialized context results in a
    ///  `TBLResult.NotInitialized` error.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Initialize(out ADest: TBLContext);

    /// <summary>
    ///  Destroys the rendering context.
    ///
    ///  Waits for all operations, detaches the target from the rendering context
    ///  and then destroys it. Does nothing if the context is not initialized.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <remarks>
    ///  Destroying the rendering context would always internally call `flush(BL_CONTEXT_FLUSH_SYNC)`, which would
    ///  flush the render calls queue in case multi-threaded rendering is used.
    /// </remarks>
    class operator Finalize(var ADest: TBLContext);

    /// <summary>
    ///  Copy constructor.
    ///
    ///  Creates a weak-copy of the `ASrc` rendering context by increasing it's
    ///  internal reference counter. This context and `ASrc` would point to the
    ///  same data and would be otherwise identical. Any change to `ASrc` would
    ///  also affect this context.
    ///
    ///  This operator is mostly provided for users that may keep a global
    ///  reference to the same rendering context, for example, otherwise sharing
    ///  is not that useful as the rendering context has states that are
    ///  manipulated during rendering.
    ///
    ///  Two weak copies of the same rendering context cannot be used by
    ///  different threads simultaneously.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    class operator Assign(var ADest: TBLContext; const [ref] ASrc: TBLContext); inline;

    /// <summary>
    ///  Used to compare against `nil` (null or invalid context).
    /// </summary>
    class operator Equal(const ALeft: TBLContext; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two contexts are equal.
    /// </summary>
    class operator Equal(const ALeft, ARight: TBLContext): Boolean; inline; static;

    /// <summary>
    ///  Used to compare against `nil` (null or invalid context).
    /// </summary>
    class operator NotEqual(const ALeft: TBLContext; const ARight: Pointer): Boolean; inline; static;

    /// <summary>
    ///  Returns True if two font contexts are not equal.
    /// </summary>
    class operator NotEqual(const ALeft, ARight: TBLContext): Boolean; inline; static;

    /// <summary>
    ///  Creates a new rendering context for rendering to the image `ATarget`.
    ///
    ///  This is a simplified constructor that can be used to create a rendering
    ///  context without any additional parameters, which means that the
    ///  rendering context will use a single-threaded synchronous rendering.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    constructor Create(const ATarget: TBLImage); overload;

    /// <summary>
    ///  Creates a new rendering context for rendering to the image `ATarget`.
    ///
    ///  This is an advanced constructor that can be used to create a rendering
    ///  context with additional parameters. These parameters can be used to
    ///  specify the number of threads to be used during rendering and to select
    ///  other features.
    /// </summary>
    constructor Create(const ATarget: TBLImage;
      const ACreateInfo: TBLContextCreateInfo); overload;

    /// <summary>
    ///  Returns whether this and `AOther` point to the same rendering context.
    /// </summary>
    function Equals(const AOther: TBLContext): Boolean;

    /// <summary>
    ///  Resets this rendering context to the default constructed one.
    ///
    ///  Similar behavior to the destructor, but the rendering context will
    ///  still be a valid object after the call to `Reset` and would behave like
    ///  a default constructed context.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Reset; inline;

    /// <summary>
    ///  Begins rendering to the given `AImage`.
    ///
    ///  This is a simplified `Start` method that can be used to create a
    ///  rendering context without any additional parameters, which means that
    ///  the rendering context will use a single-threaded synchronous rendering.
    ///
    ///  If this operation succeeds then the rendering context will have
    ///  exclusive access to the image data. This means that no other renderer
    ///  can use it during rendering.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Start(const AImage: TBLImage); overload; inline;

    /// <summary>
    ///  Begins rendering to the given `AImage`.
    ///
    ///  This is an advanced `Start` method that can be used to create a
    ///  rendering context with additional parameters. These parameters can be
    ///  used to specify the number of threads to be used during rendering and
    ///  to select other features.
    ///
    ///  If this operation succeeds then the rendering context will have
    ///  exclusive access to the image data. This means that no other renderer
    ///  can use it during rendering.
    /// </summary>
    procedure Start(const AImage: TBLImage;
      const ACreateInfo: TBLContextCreateInfo); overload; inline;

    /// <summary>
    ///  Waits for completion of all render commands and detaches the rendering
    ///  context from the rendering target.
    ///  After `Finish` completes the rendering context implementation would be
    ///  released and replaced by a built-in nil instance (no context).
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <remarks>
    ///  Calling `Finish` would implicitly call `Flush(TBLContextFlush.Sync)`,
    ///  which would flush the render calls queue in case multi-threaded
    ///  rendering is used.
    /// </remarks>
    /// <seealso cref="Flush"/>
    procedure Finish; inline;

    /// <summary>
    ///  Flushes the context.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Flush(const AFlags: TBLContextFlushFlags); inline;

    /// <summary>
    ///  Saves the current rendering context state.
    ///
    ///  Blend2D uses optimizations that make `Save` a cheap operation. Only
    ///  core values are actually saved, others will only be saved if they are
    ///  modified. This means that consecutive calls to `Save` and `Restore` do
    ///  almost nothing.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="Restore"/>
    procedure Save; overload; inline;

    /// <summary>
    ///  Saves the current rendering context state and creates a restoration
    ///  `cookie`.
    ///
    ///  If you use a `cookie` to save a state you have to use the same cookie
    ///  to restore it otherwise the `Restore` would fail. Please note that
    ///  cookies are not a means of security, they are provided for making it
    ///  easier to guarantee that a code that you may not control won't break
    ///  your context.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="Restore"/>
    procedure Save(out ACookie: TBLContextCookie); overload; inline;

    /// <summary>
    ///  Restores the top-most saved context-state.
    ///
    ///  Possible error conditions:
    ///
    ///    - TBLResult.Success - State was restored successfully.
    ///    - TBLResult.NoStatesToRestore - There are no saved states to restore.
    ///    - TBLResult.NoMatchingCookie - Previous state was saved with cookie,
    ///      which was not provided. You would need the correct cookie to
    ///      restore such state.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="Save"/>
    procedure Restore; overload; inline;

    /// <summary>
    ///  Restores the top-most saved context-state.
    ///
    ///  Possible error conditions:
    ///
    ///    - TBLResult.Success - State was restored successfully.
    ///    - TBLResult.NoStatesToRestore - There are no saved states to restore.
    ///    - TBLResult.NoMatchingCookie - The cookie did't match any saved state.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="Save"/>
    procedure Restore(const ACookie: TBLContextCookie); overload; inline;

    /// <summary>
    ///  Sets user transformation matrix to `ATransform`.
    /// </summary>
    /// <remarks>
    ///  This only assigns the user transformation matrix, which means that the
    ///  meta transformation matrix is kept as is. This means that the final
    ///  transformation matrix will be recalculated based on the given
    ///  `transform`.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetTransform(const ATransform: TBLMatrix2D); inline;

    /// <summary>
    ///  Resets user transformation matrix to identity.
    /// </summary>
    /// <remarks>
    ///  This only resets the user transformation matrix, which means that the
    ///  meta transformation matrix is kept as is. This means that the final
    ///  transformation matrix after `ResetTransform` would be the same as meta
    ///  transformation matrix.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ResetTransform; inline;

    /// <summary>
    ///  Translates the user transformation matrix by `[AX, AY]`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Translate(const AX, AY: Double); overload; inline;

    /// <summary>
    ///  Translates the user transformation matrix by `[AP]` (floating-point).
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Translate(const AP: TBLPoint); overload; inline;

    /// <summary>
    ///  Translates the user transformation matrix by `[AP]` (integer).
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Translate(const AP: TBLPointI); overload; inline;

    /// <summary>
    ///  Scales the user transformation matrix by `AXY` (both X and Y is scaled
    ///  by `AXY`).
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Scale(const AXY: Double); overload; inline;

    /// <summary>
    ///  Scales the user transformation matrix by `[AX, AY]`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Scale(const AX, AY: Double); overload; inline;

    /// <summary>
    ///  Scales the user transformation matrix by `[AP]` (floating-point).
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Scale(const AP: TBLPoint); overload; inline;

    /// <summary>
    ///  Scales the user transformation matrix by `[AP]` (integer).
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Scale(const AP: TBLPointI); overload; inline;

    /// <summary>
    ///  Skews the user transformation matrix by `[AX, AY]`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Skew(const AX, AY: Double); overload; inline;

    /// <summary>
    ///  Skews the user transformation matrix by `[AP]` (floating-point).
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Skew(const AP: TBLPoint); overload; inline;

    /// <summary>
    ///  Rotates the user transformation matrix by `AAngle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Rotate(const AAngle: Double); overload; inline;

    /// <summary>
    ///  Rotates the user transformation matrix at `[AX, AY]` by `AAngle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Rotate(const AAngle, AX, AY: Double); overload; inline;

    /// <summary>
    ///  Rotates the user transformation matrix at `AOrigin` (floating-point) by
    ///  `AAngle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Rotate(const AAngle: Double; const AOrigin: TBLPoint); overload; inline;

    /// <summary>
    ///  Rotates the user transformation matrix at `AOrigin` (integer) by
    ///  `AAngle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure Rotate(const AAngle: Double; const AOrigin: TBLPointI); overload; inline;

    /// <summary>
    ///  Transforms the user transformation matrix by `ATransform`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure ApplyTransform(const ATransform: TBLMatrix2D); inline;

    /// <summary>
    ///  Post-translates the used transformation matrix by `[AX, AY]`.
    /// </summary>
    /// <remarks>
    ///  Post-translation uses a reversed order of matrix multiplication when
    ///  compared to `Translate`.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="Translate"/>
    procedure PostTranslate(const AX, AY: Double); overload; inline;

    /// <summary>
    ///  Post-Translates the used transformation matrix by `[AP]` (floating-point).
    /// </summary>
    /// <remarks>
    ///  Post-translation uses a reversed order of matrix multiplication when
    ///  compared to `Translate`.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="Translate"/>
    procedure PostTranslate(const AP: TBLPoint); overload; inline;

    /// <summary>
    ///  Post-Translates the used transformation matrix by `[AP]` (integer).
    /// </summary>
    /// <remarks>
    ///  Post-translation uses a reversed order of matrix multiplication when
    ///  compared to `Translate`.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="Translate"/>
    procedure PostTranslate(const AP: TBLPointI); overload; inline;

    /// <summary>
    ///  Post-scales the user transformation matrix by `AXY` (both X and Y is
    ///  scaled by `AXY`).
    /// </summary>
    /// <remarks>
    ///  Post-scale uses a reversed order of matrix multiplication when compared
    ///  `Scale`.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="Scale"/>
    procedure PostScale(const AXY: Double); overload; inline;

    /// <summary>
    ///  Post-scales the user transformation matrix by `[AX, AY]`.
    /// </summary>
    /// <remarks>
    ///  Post-scale uses a reversed order of matrix multiplication when compared
    ///  `Scale`.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="Scale"/>
    procedure PostScale(const AX, AY: Double); overload; inline;

    /// <summary>
    ///  Post-scales the user transformation matrix by `[AP]` (floating-point).
    /// </summary>
    /// <remarks>
    ///  Post-scale uses a reversed order of matrix multiplication when compared
    ///  `Scale`.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="Scale"/>
    procedure PostScale(const AP: TBLPoint); overload; inline;

    /// <summary>
    ///  Post-scales the user transformation matrix by `[AP]` (integer).
    /// </summary>
    /// <remarks>
    ///  Post-scale uses a reversed order of matrix multiplication when compared
    ///  `Scale`.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="Scale"/>
    procedure PostScale(const AP: TBLPointI); overload; inline;

    /// <summary>
    ///  Skews the user transformation matrix by `[AX, AY]`.
    /// </summary>
    /// <remarks>
    ///  Post-skew uses a reversed order of matrix multiplication when compared
    ///  to `Skew`.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="Skew"/>
    procedure PostSkew(const AX, AY: Double); overload; inline;

    /// <summary>
    ///  Skews the user transformation matrix by `[AP]` (floating-point).
    /// </summary>
    /// <remarks>
    ///  Post-skew uses a reversed order of matrix multiplication when compared
    ///  to `Skew`.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="Skew"/>
    procedure PostSkew(const AP: TBLPoint); overload; inline;

    /// <summary>
    ///  Rotates the user transformation matrix by `AAngle`.
    /// </summary>
    /// <remarks>
    ///  Post-rotation uses a reversed order of matrix multiplication when
    ///  compared to `Rotate`.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="Rotate"/>
    procedure PostRotate(const AAngle: Double); overload; inline;

    /// <summary>
    ///  Rotates the user transformation matrix at `[AX, AY]` by `AAngle`.
    /// </summary>
    /// <remarks>
    ///  Post-rotation uses a reversed order of matrix multiplication when
    ///  compared to `Rotate`.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="Rotate"/>
    procedure PostRotate(const AAngle, AX, AY: Double); overload; inline;

    /// <summary>
    ///  Rotates the user transformation matrix at `AOrigin` (floating-point) by
    ///  `AAngle`.
    /// </summary>
    /// <remarks>
    ///  Post-rotation uses a reversed order of matrix multiplication when
    ///  compared to `Rotate`.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="Rotate"/>
    procedure PostRotate(const AAngle: Double; const AOrigin: TBLPoint); overload; inline;

    /// <summary>
    ///  Rotates the user transformation matrix at `AOrigin` (integer) by
    ///  `AAngle`.
    /// </summary>
    /// <remarks>
    ///  Post-rotation uses a reversed order of matrix multiplication when
    ///  compared to `Rotate`.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="Rotate"/>
    procedure PostRotate(const AAngle: Double; const AOrigin: TBLPointI); overload; inline;

    /// <summary>
    ///  Transforms the user transformation matrix by `ATransform`.
    /// </summary>
    /// <remarks>
    ///  Post-transform uses a reversed order of matrix multiplication when
    ///  compared to `ApplyTransform`.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="ApplyTransform"/>
    procedure PostTransform(const ATransform: TBLMatrix2D); inline;

    /// <summary>
    ///  Stores the result of combining the current `MetaTransform` and
    ///  `UserTransform` to `MetaTransform` and resets `UserTransform` to
    ///  identity as shown below:
    ///
    ///  ```
    ///  MetaTransform := MetaTransform * UserTransform;
    ///  UserTransform := Identity
    ///  ```
    ///
    ///  Please note that this operation is irreversible. The only way to
    ///  restore a meta-matrix is to `Save` the rendering context state, then to
    ///  use `UserToMeta`, and then restored by `Restore` when needed.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="Save"/>
    /// <seealso cref="Restore"/>
    procedure UserToMeta; inline;

    /// <summary>
    ///  Sets the given rendering hint `AHintType` to `AValue`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetHint(const AHintType: TBLContextHint;
      const AValue: Integer); inline;

    /// <summary>
    ///  Sets `AStyle` to be used with the given style `ASlot` operation.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetStyle(const ASlot: TBLContextStyleSlot;
      const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Sets `AStyle` to be used with the given style `ASlot` operation.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetStyle(const ASlot: TBLContextStyleSlot;
      const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Sets `AStyle` to be used with the given style `ASlot` operation.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetStyle(const ASlot: TBLContextStyleSlot;
      const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Sets `AStyle` to be used with the given style `ASlot` operation.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetStyle(const ASlot: TBLContextStyleSlot;
      const AColor: TAlphaColor); overload; inline;

    /// <summary>
    ///  Sets `AStyle` to be used with the given style `ASlot` operation.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetStyle(const ASlot: TBLContextStyleSlot;
      const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Sets `AStyle` to be used with the given style `ASlot` operation.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetStyle(const ASlot: TBLContextStyleSlot;
      const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Sets `AStyle` to be used with the given style `ASlot` operation.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetStyle(const ASlot: TBLContextStyleSlot;
      const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Sets `AStyle` to be used with the given style `ASlot` operation and
    ///  applied `ATransformMode`.
    ///
    ///  This is a convenience method that allows to control how the given
    ///  `AStyle` is transformed. By default, if `ATransformMode` is not
    ///  provided, the rendering context combines the style transformation
    ///  matrix with user transformation matrix, which is compatible with
    ///  how it transforms geometry. However, if that is undesired, a
    ///  `ATransformMode` can override the default operation.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetStyle(const ASlot: TBLContextStyleSlot; const AStyle: TBLGradient;
      const ATransformMode: TBLContextStyleTransformMode); overload; inline;

    /// <summary>
    ///  Sets `AStyle` to be used with the given style `ASlot` operation and
    ///  applied `ATransformMode`.
    ///
    ///  This is a convenience method that allows to control how the given
    ///  `AStyle` is transformed. By default, if `ATransformMode` is not
    ///  provided, the rendering context combines the style transformation
    ///  matrix with user transformation matrix, which is compatible with
    ///  how it transforms geometry. However, if that is undesired, a
    ///  `ATransformMode` can override the default operation.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetStyle(const ASlot: TBLContextStyleSlot; const AStyle: TBLPattern;
      const ATransformMode: TBLContextStyleTransformMode); overload; inline;

    /// <summary>
    ///  Sets `AStyle` to be used with the given style `ASlot` operation and
    ///  applied `ATransformMode`.
    ///
    ///  This is a convenience method that allows to control how the given
    ///  `AStyle` is transformed. By default, if `ATransformMode` is not
    ///  provided, the rendering context combines the style transformation
    ///  matrix with user transformation matrix, which is compatible with
    ///  how it transforms geometry. However, if that is undesired, a
    ///  `ATransformMode` can override the default operation.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetStyle(const ASlot: TBLContextStyleSlot; const AStyle: TBLVar;
      const ATransformMode: TBLContextStyleTransformMode); overload; inline;

    /// <summary>
    ///  Sets the given style `ASlot` to Null, which disables it.
    ///
    ///  Styles set to Null would reject all rendering operations that would
    ///  otherwise use that style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure DisableStyle(const ASlot: TBLContextStyleSlot); inline;

    /// <summary>
    ///  Swaps fill and stroke styles.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SwapStyles(const AMode: TBLContextStyleSwapMode); inline;

    /// <summary>
    ///  Sets fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetFillStyle(const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Sets fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetFillStyle(const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Sets fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetFillStyle(const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Sets fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetFillStyle(const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Sets fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetFillStyle(const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Sets fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetFillStyle(const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Sets fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetFillStyle(const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Sets fill style.
    ///
    ///  This is a convenience method that allows to control how the given
    ///  `AStyle` is transformed. By default, if `ATransformMode` is not
    ///  provided, the rendering context combines the style transformation
    ///  matrix with user transformation matrix, which is compatible with
    ///  how it transforms geometry. However, if that is undesired, a
    ///  `ATransformMode` can override the default operation.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetFillStyle(const AStyle: TBLGradient;
      const ATransformMode: TBLContextStyleTransformMode); overload; inline;

    /// <summary>
    ///  Sets fill style.
    ///
    ///  This is a convenience method that allows to control how the given
    ///  `AStyle` is transformed. By default, if `ATransformMode` is not
    ///  provided, the rendering context combines the style transformation
    ///  matrix with user transformation matrix, which is compatible with
    ///  how it transforms geometry. However, if that is undesired, a
    ///  `ATransformMode` can override the default operation.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetFillStyle(const AStyle: TBLPattern;
      const ATransformMode: TBLContextStyleTransformMode); overload; inline;

    /// <summary>
    ///  Sets fill style.
    ///
    ///  This is a convenience method that allows to control how the given
    ///  `AStyle` is transformed. By default, if `ATransformMode` is not
    ///  provided, the rendering context combines the style transformation
    ///  matrix with user transformation matrix, which is compatible with
    ///  how it transforms geometry. However, if that is undesired, a
    ///  `ATransformMode` can override the default operation.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetFillStyle(const AStyle: TBLVar;
      const ATransformMode: TBLContextStyleTransformMode); overload; inline;

    /// <summary>
    ///  Sets fill style to Null, which disables it.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure DisableFillStyle; inline;

    /// <summary>
    ///  Sets stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetStrokeStyle(const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Sets stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetStrokeStyle(const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Sets stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetStrokeStyle(const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Sets stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetStrokeStyle(const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Sets stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetStrokeStyle(const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Sets stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetStrokeStyle(const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Sets stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetStrokeStyle(const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Sets stroke style.
    ///
    ///  This is a convenience method that allows to control how the given
    ///  `AStyle` is transformed. By default, if `ATransformMode` is not
    ///  provided, the rendering context combines the style transformation
    ///  matrix with user transformation matrix, which is compatible with
    ///  how it transforms geometry. However, if that is undesired, a
    ///  `ATransformMode` can override the default operation.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetStrokeStyle(const AStyle: TBLGradient;
      const ATransformMode: TBLContextStyleTransformMode); overload; inline;

    /// <summary>
    ///  Sets stroke style.
    ///
    ///  This is a convenience method that allows to control how the given
    ///  `AStyle` is transformed. By default, if `ATransformMode` is not
    ///  provided, the rendering context combines the style transformation
    ///  matrix with user transformation matrix, which is compatible with
    ///  how it transforms geometry. However, if that is undesired, a
    ///  `ATransformMode` can override the default operation.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetStrokeStyle(const AStyle: TBLPattern;
      const ATransformMode: TBLContextStyleTransformMode); overload; inline;

    /// <summary>
    ///  Sets stroke style.
    ///
    ///  This is a convenience method that allows to control how the given
    ///  `AStyle` is transformed. By default, if `ATransformMode` is not
    ///  provided, the rendering context combines the style transformation
    ///  matrix with user transformation matrix, which is compatible with
    ///  how it transforms geometry. However, if that is undesired, a
    ///  `ATransformMode` can override the default operation.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetStrokeStyle(const AStyle: TBLVar;
      const ATransformMode: TBLContextStyleTransformMode); overload; inline;

    /// <summary>
    ///  Sets stroke style to Null, which disables it.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure DisableStrokeStyle; inline;

    /// <summary>
    ///  Sets stroke cap of the specified `APosition` to `AStrokeCap`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetStrokeCap(const APosition: TBLStrokeCapPosition;
      const AStrokeCap: TBLStrokeCap); inline;

    /// <summary>
    ///  Sets all stroke caps to `AStrokeCap`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure SetStrokeCaps(const AStrokeCap: TBLStrokeCap); inline;

    /// <summary>
    ///  Restores clipping to the last saved state or to the context default
    ///  clipping if there is no saved state.
    ///
    ///  If there are no saved states then it resets clipping completely to the
    ///  initial state that was used when the rendering context was created.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure RestoreClipping; inline;

    procedure ClipToRect(const ARect: TBLRectI); overload; inline;
    procedure ClipToRect(const ARect: TBLRect); overload; inline;
    procedure ClipToRect(const AX, AY, AW, AH: Double); overload; inline;

    /// <summary>
    ///  Clear everything to a transparent black, which is the same operation as
    ///  temporarily setting the composition operator to TBLCompOp.Clear and
    ///  then filling everything by `FillAll`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <remarks>
    ///  If the target surface doesn't have alpha, but has X component, like
    ///  `TBLFormat.Xrgb32`, the `X` component would be set to `1.0`, which
    ///  would translate to `$FF` in case of \ref `TBLFormat.Xrgb32`.
    /// </remarks>
    /// <seealso cref="TBLCompOp"/>
    /// <seealso cref="FillAll"/>
    /// <seealso cref="TBLFormat"/>
    procedure ClearAll; inline;

    /// <summary>
    ///  Clears a rectangle `ARect` (integer coordinates) to a transparent
    ///  black, which is the same operation as temporarily setting the
    ///  composition operator to `TBLCompOp.Clear` and then calling
    ///  `FillRect(ARect)`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <remarks>
    ///  If the target surface doesn't have alpha, but has X component, like
    ///  `TBLFormat.Xrgb32`, the `X` component would be set to `1.0`, which
    ///  would translate to `$FF` in case of \ref `TBLFormat.Xrgb32`.
    /// </remarks>
    /// <seealso cref="TBLCompOp"/>
    /// <seealso cref="FillRect"/>
    /// <seealso cref="TBLFormat"/>
    procedure ClearRect(const ARect: TBLRectI); overload; inline;

    /// <summary>
    ///  Clears a rectangle `ARect` (floating-point coordinates) to a
    ///  transparent black, which is the same operation as temporarily setting
    ///  the composition operator to `TBLCompOp.Clear` and then calling
    ///  `FillRect(ARect)`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <remarks>
    ///  If the target surface doesn't have alpha, but has X component, like
    ///  `TBLFormat.Xrgb32`, the `X` component would be set to `1.0`, which
    ///  would translate to `$FF` in case of \ref `TBLFormat.Xrgb32`.
    /// </remarks>
    /// <seealso cref="TBLCompOp"/>
    /// <seealso cref="FillRect"/>
    /// <seealso cref="TBLFormat"/>
    procedure ClearRect(const ARect: TBLRect); overload; inline;

    /// <summary>
    ///  Clears a rectangle `[AX, AY, AW, AH]` (floating-point coordinates) to a
    ///  transparent black, which is the same operation as temporarily setting
    ///  the composition operator to 'TBLCompOp.Clear` and then calling
    ///  `FillRect(AX, AY, AW, AH)`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <remarks>
    ///  If the target surface doesn't have alpha, but has X component, like
    ///  `TBLFormat.Xrgb32`, the `X` component would be set to `1.0`, which
    ///  would translate to `$FF` in case of \ref `TBLFormat.Xrgb32`.
    /// </remarks>
    /// <seealso cref="TBLCompOp"/>
    /// <seealso cref="FillRect"/>
    /// <seealso cref="TBLFormat"/>
    procedure ClearRect(const AX, AY, AW, AH: Double); overload; inline;

    /// <summary>
    ///  Fills everything non-clipped with the current fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillAll; overload; inline;

    /// <summary>
    ///  Fills everything non-clipped with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillAll(const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills everything non-clipped with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillAll(const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills everything non-clipped with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillAll(const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills everything non-clipped with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillAll(const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills everything non-clipped with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillAll(const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills everything non-clipped with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillAll(const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills everything non-clipped with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillAll(const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a `ABox` (floating point coordinates) with the current fill style.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `FillRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="FillRect"/>
    procedure FillBox(const ABox: TBLBox); overload; inline;

    /// <summary>
    ///  Fills a `ABox` (floating point coordinates)  with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `FillRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="FillRect"/>
    procedure FillBox(const ABox: TBLBox; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a `ABox` (floating point coordinates)  with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `FillRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="FillRect"/>
    procedure FillBox(const ABox: TBLBox; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a `ABox` (floating point coordinates)  with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `FillRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="FillRect"/>
    procedure FillBox(const ABox: TBLBox; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a `ABox` (floating point coordinates)  with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `FillRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="FillRect"/>
    procedure FillBox(const ABox: TBLBox; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a `ABox` (floating point coordinates)  with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `FillRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="FillRect"/>
    procedure FillBox(const ABox: TBLBox; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a `ABox` (floating point coordinates)  with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `FillRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="FillRect"/>
    procedure FillBox(const ABox: TBLBox; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a `ABox` (floating point coordinates)  with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `FillRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="FillRect"/>
    procedure FillBox(const ABox: TBLBox; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a `ABox` (integer coordinates) with the current fill style.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `FillRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="FillRect"/>
    procedure FillBox(const ABox: TBLBoxI); overload; inline;

    /// <summary>
    ///  Fills a `ABox` (integer coordinates)  with an explicit fill `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `FillRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="FillRect"/>
    procedure FillBox(const ABox: TBLBoxI; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a `ABox` (integer coordinates)  with an explicit fill `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `FillRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="FillRect"/>
    procedure FillBox(const ABox: TBLBoxI; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a `ABox` (integer coordinates)  with an explicit fill `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `FillRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="FillRect"/>
    procedure FillBox(const ABox: TBLBoxI; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a `ABox` (integer coordinates)  with an explicit fill `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `FillRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="FillRect"/>
    procedure FillBox(const ABox: TBLBoxI; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a `ABox` (integer coordinates)  with an explicit fill `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `FillRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="FillRect"/>
    procedure FillBox(const ABox: TBLBoxI; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a `ABox` (integer coordinates)  with an explicit fill `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `FillRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="FillRect"/>
    procedure FillBox(const ABox: TBLBoxI; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a `ABox` (integer coordinates)  with an explicit fill `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `FillRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="FillRect"/>
    procedure FillBox(const ABox: TBLBoxI; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a box [AX0, AY0, AX1, AY1] (floating point coordinates) with the
    ///  current fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBox(const AX0, AY0, AX1, AY1: Double); overload; inline;

    /// <summary>
    ///  Fills a box [AX0, AY0, AX1, AY1] (floating point coordinates) with an
    ///  explicit fill `AStyle`
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBox(const AX0, AY0, AX1, AY1: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a box [AX0, AY0, AX1, AY1] (floating point coordinates) with an
    ///  explicit fill `AStyle`
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBox(const AX0, AY0, AX1, AY1: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a box [AX0, AY0, AX1, AY1] (floating point coordinates) with an
    ///  explicit fill `AStyle`
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBox(const AX0, AY0, AX1, AY1: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a box [AX0, AY0, AX1, AY1] (floating point coordinates) with an
    ///  explicit fill `AStyle`
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBox(const AX0, AY0, AX1, AY1: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a box [AX0, AY0, AX1, AY1] (floating point coordinates) with an
    ///  explicit fill `AStyle`
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBox(const AX0, AY0, AX1, AY1: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a box [AX0, AY0, AX1, AY1] (floating point coordinates) with an
    ///  explicit fill `AStyle`
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBox(const AX0, AY0, AX1, AY1: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a box [AX0, AY0, AX1, AY1] (floating point coordinates) with an
    ///  explicit fill `AStyle`
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBox(const AX0, AY0, AX1, AY1: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a rectangle `ARect` (integer coordinates) with the current fill
    ///  style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRect(const ARect: TBLRectI); overload; inline;

    /// <summary>
    ///  Fills a rectangle `ARect` (integer coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRect(const ARect: TBLRectI; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a rectangle `ARect` (integer coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRect(const ARect: TBLRectI; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a rectangle `ARect` (integer coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRect(const ARect: TBLRectI; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a rectangle `ARect` (integer coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRect(const ARect: TBLRectI; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a rectangle `ARect` (integer coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRect(const ARect: TBLRectI; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a rectangle `ARect` (integer coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRect(const ARect: TBLRectI; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a rectangle `ARect` (integer coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRect(const ARect: TBLRectI; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a rectangle `ARect` (floating point coordinates) with the current
    ///  fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRect(const ARect: TBLRect); overload; inline;

    /// <summary>
    ///  Fills a rectangle `ARect` (floating point coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRect(const ARect: TBLRect; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a rectangle `ARect` (floating point coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRect(const ARect: TBLRect; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a rectangle `ARect` (floating point coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRect(const ARect: TBLRect; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a rectangle `ARect` (floating point coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRect(const ARect: TBLRect; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a rectangle `ARect` (floating point coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRect(const ARect: TBLRect; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a rectangle `ARect` (floating point coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRect(const ARect: TBLRect; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a rectangle `ARect` (floating point coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRect(const ARect: TBLRect; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a rectangle `[AX, AY, AW, AH]` (floating point coordinates) with
    ///  the current fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRect(const AX, AY, AW, AH: Double); overload; inline;

    /// <summary>
    ///  Fills a rectangle `[AX, AY, AW, AH]` (floating point coordinates) with
    ///  an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRect(const AX, AY, AW, AH: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a rectangle `[AX, AY, AW, AH]` (floating point coordinates) with
    ///  an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRect(const AX, AY, AW, AH: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a rectangle `[AX, AY, AW, AH]` (floating point coordinates) with
    ///  an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRect(const AX, AY, AW, AH: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a rectangle `[AX, AY, AW, AH]` (floating point coordinates) with
    ///  an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRect(const AX, AY, AW, AH: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a rectangle `[AX, AY, AW, AH]` (floating point coordinates) with
    ///  an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRect(const AX, AY, AW, AH: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a rectangle `[AX, AY, AW, AH]` (floating point coordinates) with
    ///  an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRect(const AX, AY, AW, AH: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a rectangle `[AX, AY, AW, AH]` (floating point coordinates) with
    ///  an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRect(const AX, AY, AW, AH: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills an `ACircle` (floating point coordinates) with the current fill
    ///  style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillCircle(const ACircle: TBLCircle); overload; inline;

    /// <summary>
    ///  Fills an `ACircle` (floating point coordinates)  with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillCircle(const ACircle: TBLCircle; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills an `ACircle` (floating point coordinates)  with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillCircle(const ACircle: TBLCircle; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills an `ACircle` (floating point coordinates)  with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillCircle(const ACircle: TBLCircle; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills an `ACircle` (floating point coordinates)  with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillCircle(const ACircle: TBLCircle; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills an `ACircle` (floating point coordinates)  with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillCircle(const ACircle: TBLCircle; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills an `ACircle` (floating point coordinates)  with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillCircle(const ACircle: TBLCircle; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills an `ACircle` (floating point coordinates)  with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillCircle(const ACircle: TBLCircle; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a circle at `[ACX, ACY]` and radius `AR` (floating point
    ///  coordinates) with the current fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillCircle(const ACX, ACY, AR: Double); overload; inline;

    /// <summary>
    ///  Fills a circle at `[ACX, ACY]` and radius `AR` (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillCircle(const ACX, ACY, AR: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a circle at `[ACX, ACY]` and radius `AR` (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillCircle(const ACX, ACY, AR: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a circle at `[ACX, ACY]` and radius `AR` (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillCircle(const ACX, ACY, AR: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a circle at `[ACX, ACY]` and radius `AR` (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillCircle(const ACX, ACY, AR: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a circle at `[ACX, ACY]` and radius `AR` (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillCircle(const ACX, ACY, AR: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a circle at `[ACX, ACY]` and radius `AR` (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillCircle(const ACX, ACY, AR: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a circle at `[ACX, ACY]` and radius `AR` (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillCircle(const ACX, ACY, AR: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills an `AEllipse` (floating point coordinates) with the current fill
    ///  style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillEllipse(const AEllipse: TBLEllipse); overload; inline;

    /// <summary>
    ///  Fills an `AEllipse` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillEllipse(const AEllipse: TBLEllipse; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills an `AEllipse` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillEllipse(const AEllipse: TBLEllipse; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills an `AEllipse` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillEllipse(const AEllipse: TBLEllipse; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills an `AEllipse` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillEllipse(const AEllipse: TBLEllipse; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills an `AEllipse` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillEllipse(const AEllipse: TBLEllipse; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills an `AEllipse` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillEllipse(const AEllipse: TBLEllipse; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills an `AEllipse` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillEllipse(const AEllipse: TBLEllipse; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills an ellipse at `[ACX, ACY]` with radius `[ARX, ARY]` (floating
    ///  point coordinates) with the current fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillEllipse(const ACX, ACY, ARX, ARY: Double); overload; inline;

    /// <summary>
    ///  Fills an ellipse at `[ACX, ACY]` with radius `[ARX, ARY]` (floating
    ///  point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillEllipse(const ACX, ACY, ARX, ARY: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills an ellipse at `[ACX, ACY]` with radius `[ARX, ARY]` (floating
    ///  point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillEllipse(const ACX, ACY, ARX, ARY: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills an ellipse at `[ACX, ACY]` with radius `[ARX, ARY]` (floating
    ///  point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillEllipse(const ACX, ACY, ARX, ARY: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills an ellipse at `[ACX, ACY]` with radius `[ARX, ARY]` (floating
    ///  point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillEllipse(const ACX, ACY, ARX, ARY: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills an ellipse at `[ACX, ACY]` with radius `[ARX, ARY]` (floating
    ///  point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillEllipse(const ACX, ACY, ARX, ARY: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills an ellipse at `[ACX, ACY]` with radius `[ARX, ARY]` (floating
    ///  point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillEllipse(const ACX, ACY, ARX, ARY: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills an ellipse at `[ACX, ACY]` with radius `[ARX, ARY]` (floating
    ///  point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillEllipse(const ACX, ACY, ARX, ARY: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle `ARR` (floating point coordinates) with the
    ///  current fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const ARR: TBLRoundRect); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle `ARR` (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const ARR: TBLRoundRect; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle `ARR` (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const ARR: TBLRoundRect; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle `ARR` (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const ARR: TBLRoundRect; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle `ARR` (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const ARR: TBLRoundRect; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle `ARR` (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const ARR: TBLRoundRect; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle `ARR` (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const ARR: TBLRoundRect; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle `ARR` (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const ARR: TBLRoundRect; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `ARect` with radius `AR` with the
    ///  current fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const ARect: TBLRect; const AR: Double); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `ARect` with radius `AR` with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const ARect: TBLRect; const AR: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `ARect` with radius `AR` with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const ARect: TBLRect; const AR: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `ARect` with radius `AR` with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const ARect: TBLRect; const AR: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `ARect` with radius `AR` with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const ARect: TBLRect; const AR: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `ARect` with radius `AR` with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const ARect: TBLRect; const AR: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `ARect` with radius `AR` with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const ARect: TBLRect; const AR: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `ARect` with radius `AR` with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const ARect: TBLRect; const AR: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `ARect` with radius `[ARX, ARY]`
    ///  with the current fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const ARect: TBLRect; const ARX, ARY: Double); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `ARect` with radius `[ARX, ARY]`
    ///  with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const ARect: TBLRect; const ARX, ARY: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `ARect` with radius `[ARX, ARY]`
    ///  with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const ARect: TBLRect; const ARX, ARY: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `ARect` with radius `[ARX, ARY]`
    ///  with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const ARect: TBLRect; const ARX, ARY: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `ARect` with radius `[ARX, ARY]`
    ///  with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const ARect: TBLRect; const ARX, ARY: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `ARect` with radius `[ARX, ARY]`
    ///  with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const ARect: TBLRect; const ARX, ARY: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `ARect` with radius `[ARX, ARY]`
    ///  with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const ARect: TBLRect; const ARX, ARY: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `ARect` with radius `[ARX, ARY]`
    ///  with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const ARect: TBLRect; const ARX, ARY: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `AR` with the current fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const AX, AY, AW, AH, AR: Double); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `AR` with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const AX, AY, AW, AH, AR: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `AR` with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const AX, AY, AW, AH, AR: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `AR` with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const AX, AY, AW, AH, AR: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `AR` with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const AX, AY, AW, AH, AR: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `AR` with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const AX, AY, AW, AH, AR: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `AR` with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const AX, AY, AW, AH, AR: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `AR` with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const AX, AY, AW, AH, AR: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `[ARX, ARY]` with the current fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const AX, AY, AW, AH, ARX, ARY: Double); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `[ARX, ARY]` with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const AX, AY, AW, AH, ARX, ARY: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `[ARX, ARY]` with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const AX, AY, AW, AH, ARX, ARY: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `[ARX, ARY]` with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const AX, AY, AW, AH, ARX, ARY: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `[ARX, ARY]` with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const AX, AY, AW, AH, ARX, ARY: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `[ARX, ARY]` with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const AX, AY, AW, AH, ARX, ARY: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `[ARX, ARY]` with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const AX, AY, AW, AH, ARX, ARY: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `[ARX, ARY]` with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRoundRect(const AX, AY, AW, AH, ARX, ARY: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills an `AChord` (floating point coordinates) with the current fill
    ///  style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillChord(const AChord: TBLArc); overload; inline;

    /// <summary>
    ///  Fills an `AChord` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillChord(const AChord: TBLArc; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills an `AChord` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillChord(const AChord: TBLArc; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills an `AChord` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillChord(const AChord: TBLArc; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills an `AChord` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillChord(const AChord: TBLArc; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills an `AChord` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillChord(const AChord: TBLArc; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills an `AChord` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillChord(const AChord: TBLArc; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills an `AChord` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillChord(const AChord: TBLArc; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with the current fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillChord(const ACX, ACY, AR, AStart, ASweep: Double); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillChord(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillChord(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillChord(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillChord(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillChord(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillChord(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillChord(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with the current fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills an `APie` (floating point coordinates) with the current fill
    ///  style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPie(const APie: TBLArc); overload; inline;

    /// <summary>
    ///  Fills an `APie` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPie(const APie: TBLArc; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills an `APie` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPie(const APie: TBLArc; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills an `APie` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPie(const APie: TBLArc; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills an `APie` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPie(const APie: TBLArc; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills an `APie` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPie(const APie: TBLArc; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills an `APie` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPie(const APie: TBLArc; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills an `APie` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPie(const APie: TBLArc; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with the current fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPie(const ACX, ACY, AR, AStart, ASweep: Double); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPie(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPie(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPie(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPie(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPie(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPie(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPie(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with the current fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills an `ATriangle` (floating point coordinates) with the current fill
    ///  style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillTriangle(const ATriangle: TBLTriangle); overload; inline;

    /// <summary>
    ///  Fills an `ATriangle` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillTriangle(const ATriangle: TBLTriangle; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills an `ATriangle` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillTriangle(const ATriangle: TBLTriangle; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills an `ATriangle` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillTriangle(const ATriangle: TBLTriangle; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills an `ATriangle` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillTriangle(const ATriangle: TBLTriangle; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills an `ATriangle` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillTriangle(const ATriangle: TBLTriangle; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills an `ATriangle` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillTriangle(const ATriangle: TBLTriangle; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills an `ATriangle` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillTriangle(const ATriangle: TBLTriangle; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a triangle defined by `[AX0, AY0]`, `[AX1, AY1]`, `[AX2, AY2]`
    ///  (floating point coordinates) with the current fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double); overload; inline;

    /// <summary>
    ///  Fills a triangle defined by `[AX0, AY0]`, `[AX1, AY1]`, `[AX2, AY2]`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a triangle defined by `[AX0, AY0]`, `[AX1, AY1]`, `[AX2, AY2]`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a triangle defined by `[AX0, AY0]`, `[AX1, AY1]`, `[AX2, AY2]`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a triangle defined by `[AX0, AY0]`, `[AX1, AY1]`, `[AX2, AY2]`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a triangle defined by `[AX0, AY0]`, `[AX1, AY1]`, `[AX2, AY2]`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a triangle defined by `[AX0, AY0]`, `[AX1, AY1]`, `[AX2, AY2]`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a triangle defined by `[AX0, AY0]`, `[AX1, AY1]`, `[AX2, AY2]`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (floating point coordinates) with the current
    ///  fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TArray<TBLPoint>); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (floating point coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TArray<TBLPoint>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (floating point coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TArray<TBLPoint>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (floating point coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TArray<TBLPoint>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (floating point coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TArray<TBLPoint>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (floating point coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TArray<TBLPoint>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (floating point coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TArray<TBLPoint>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (floating point coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TArray<TBLPoint>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (floating point coordinates) with the current
    ///  fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TBLArrayView<TBLPoint>); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (floating point coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TBLArrayView<TBLPoint>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (floating point coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TBLArrayView<TBLPoint>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (floating point coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TBLArrayView<TBLPoint>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (floating point coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TBLArrayView<TBLPoint>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (floating point coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TBLArrayView<TBLPoint>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (floating point coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TBLArrayView<TBLPoint>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (floating point coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TBLArrayView<TBLPoint>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` having 'ACount' vertices (floating point
    ///  coordinates) with the current fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: PBLPoint; const ACount: NativeInt); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` having 'ACount' vertices (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: PBLPoint; const ACount: NativeInt; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` having 'ACount' vertices (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: PBLPoint; const ACount: NativeInt; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` having 'ACount' vertices (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: PBLPoint; const ACount: NativeInt; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` having 'ACount' vertices (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: PBLPoint; const ACount: NativeInt; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` having 'ACount' vertices (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: PBLPoint; const ACount: NativeInt; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` having 'ACount' vertices (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: PBLPoint; const ACount: NativeInt; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` having 'ACount' vertices (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: PBLPoint; const ACount: NativeInt; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (integer coordinates) with the current
    ///  fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TArray<TBLPointI>); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (integer coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TArray<TBLPointI>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (integer coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TArray<TBLPointI>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (integer coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TArray<TBLPointI>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (integer coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TArray<TBLPointI>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (integer coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TArray<TBLPointI>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (integer coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TArray<TBLPointI>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (integer coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TArray<TBLPointI>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (integer coordinates) with the current
    ///  fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TBLArrayView<TBLPointI>); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (integer coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TBLArrayView<TBLPointI>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (integer coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TBLArrayView<TBLPointI>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (integer coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TBLArrayView<TBLPointI>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (integer coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TBLArrayView<TBLPointI>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (integer coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TBLArrayView<TBLPointI>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (integer coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TBLArrayView<TBLPointI>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` (integer coordinates) with an explicit
    ///  fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: TBLArrayView<TBLPointI>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` having 'ACount' vertices (integer
    ///  coordinates) with the current fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: PBLPointI; const ACount: NativeInt); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` having 'ACount' vertices (integer
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: PBLPointI; const ACount: NativeInt; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` having 'ACount' vertices (integer
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: PBLPointI; const ACount: NativeInt; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` having 'ACount' vertices (integer
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: PBLPointI; const ACount: NativeInt; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` having 'ACount' vertices (integer
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: PBLPointI; const ACount: NativeInt; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` having 'ACount' vertices (integer
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: PBLPointI; const ACount: NativeInt; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` having 'ACount' vertices (integer
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: PBLPointI; const ACount: NativeInt; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a polygon `APoly` having 'ACount' vertices (integer
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPolygon(const APoly: PBLPointI; const ACount: NativeInt; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (floating point coordinates) with the
    ///  default fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TArray<TBLBox>); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TArray<TBLBox>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TArray<TBLBox>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TArray<TBLBox>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TArray<TBLBox>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TArray<TBLBox>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TArray<TBLBox>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TArray<TBLBox>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (floating point coordinates) with the
    ///  default fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TBLArrayView<TBLBox>); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TBLArrayView<TBLBox>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TBLArrayView<TBLBox>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TBLArrayView<TBLBox>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TBLArrayView<TBLBox>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TBLArrayView<TBLBox>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TBLArrayView<TBLBox>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TBLArrayView<TBLBox>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes or size 'ACount' (floating point
    ///  coordinates) with the default fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: PBLBox; const ACount: NativeInt); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes or size 'ACount' (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: PBLBox; const ACount: NativeInt; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes or size 'ACount' (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: PBLBox; const ACount: NativeInt; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes or size 'ACount' (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: PBLBox; const ACount: NativeInt; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes or size 'ACount' (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: PBLBox; const ACount: NativeInt; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes or size 'ACount' (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: PBLBox; const ACount: NativeInt; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes or size 'ACount' (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: PBLBox; const ACount: NativeInt; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes or size 'ACount' (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: PBLBox; const ACount: NativeInt; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (integer coordinates) with the
    ///  default fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TArray<TBLBoxI>); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TArray<TBLBoxI>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TArray<TBLBoxI>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TArray<TBLBoxI>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TArray<TBLBoxI>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TArray<TBLBoxI>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TArray<TBLBoxI>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TArray<TBLBoxI>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (integer coordinates) with the
    ///  default fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TBLArrayView<TBLBoxI>); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TBLArrayView<TBLBoxI>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TBLArrayView<TBLBoxI>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TBLArrayView<TBLBoxI>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TBLArrayView<TBLBoxI>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TBLArrayView<TBLBoxI>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TBLArrayView<TBLBoxI>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: TBLArrayView<TBLBoxI>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes or size 'ACount' (integer
    ///  coordinates) with the default fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: PBLBoxI; const ACount: NativeInt); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes or size 'ACount' (integer
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: PBLBoxI; const ACount: NativeInt; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes or size 'ACount' (integer
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: PBLBoxI; const ACount: NativeInt; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes or size 'ACount' (integer
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: PBLBoxI; const ACount: NativeInt; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes or size 'ACount' (integer
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: PBLBoxI; const ACount: NativeInt; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes or size 'ACount' (integer
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: PBLBoxI; const ACount: NativeInt; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes or size 'ACount' (integer
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: PBLBoxI; const ACount: NativeInt; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of boxes or size 'ACount' (integer
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillBoxArray(const AArray: PBLBoxI; const ACount: NativeInt; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (floating point coordinates) with the
    ///  default fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TArray<TBLRect>); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TArray<TBLRect>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TArray<TBLRect>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TArray<TBLRect>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TArray<TBLRect>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TArray<TBLRect>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TArray<TBLRect>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TArray<TBLRect>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (floating point coordinates) with the
    ///  default fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TBLArrayView<TBLRect>); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TBLArrayView<TBLRect>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TBLArrayView<TBLRect>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TBLArrayView<TBLRect>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TBLArrayView<TBLRect>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TBLArrayView<TBLRect>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TBLArrayView<TBLRect>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TBLArrayView<TBLRect>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles or size 'ACount' (floating point
    ///  coordinates) with the default fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: PBLRect; const ACount: NativeInt); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles or size 'ACount' (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: PBLRect; const ACount: NativeInt; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles or size 'ACount' (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: PBLRect; const ACount: NativeInt; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles or size 'ACount' (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: PBLRect; const ACount: NativeInt; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles or size 'ACount' (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: PBLRect; const ACount: NativeInt; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles or size 'ACount' (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: PBLRect; const ACount: NativeInt; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles or size 'ACount' (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: PBLRect; const ACount: NativeInt; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles or size 'ACount' (floating point
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: PBLRect; const ACount: NativeInt; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (integer coordinates) with the
    ///  default fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TArray<TBLRectI>); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TArray<TBLRectI>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TArray<TBLRectI>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TArray<TBLRectI>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TArray<TBLRectI>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TArray<TBLRectI>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TArray<TBLRectI>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TArray<TBLRectI>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (integer coordinates) with the
    ///  default fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TBLArrayView<TBLRectI>); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TBLArrayView<TBLRectI>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TBLArrayView<TBLRectI>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TBLArrayView<TBLRectI>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TBLArrayView<TBLRectI>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TBLArrayView<TBLRectI>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TBLArrayView<TBLRectI>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles (integer coordinates) with an
    ///  explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: TBLArrayView<TBLRectI>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles or size 'ACount' (integer
    ///  coordinates) with the default fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: PBLRectI; const ACount: NativeInt); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles or size 'ACount' (integer
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: PBLRectI; const ACount: NativeInt; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles or size 'ACount' (integer
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: PBLRectI; const ACount: NativeInt; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles or size 'ACount' (integer
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: PBLRectI; const ACount: NativeInt; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles or size 'ACount' (integer
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: PBLRectI; const ACount: NativeInt; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles or size 'ACount' (integer
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: PBLRectI; const ACount: NativeInt; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles or size 'ACount' (integer
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: PBLRectI; const ACount: NativeInt; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills an `AArray` of rectangles or size 'ACount' (integer
    ///  coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillRectArray(const AArray: PBLRectI; const ACount: NativeInt; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills the given `APath` with the default fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPath(const APath: TBLPath); overload; inline;

    /// <summary>
    ///  Fills the given `APath` with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPath(const APath: TBLPath; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills the given `APath` with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPath(const APath: TBLPath; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills the given `APath` with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPath(const APath: TBLPath; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills the given `APath` with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPath(const APath: TBLPath; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills the given `APath` with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPath(const APath: TBLPath; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills the given `APath` with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPath(const APath: TBLPath; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills the given `APath` with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPath(const APath: TBLPath; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills the given `APath` translated by `AOrigin` with the default fill
    ///  style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPath(const AOrigin: TBLPoint; const APath: TBLPath); overload; inline;

    /// <summary>
    ///  Fills the given `APath` translated by `AOrigin` with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPath(const AOrigin: TBLPoint; const APath: TBLPath; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills the given `APath` translated by `AOrigin` with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPath(const AOrigin: TBLPoint; const APath: TBLPath; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills the given `APath` translated by `AOrigin` with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPath(const AOrigin: TBLPoint; const APath: TBLPath; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills the given `APath` translated by `AOrigin` with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPath(const AOrigin: TBLPoint; const APath: TBLPath; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills the given `APath` translated by `AOrigin` with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPath(const AOrigin: TBLPoint; const APath: TBLPath; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills the given `APath` translated by `AOrigin` with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPath(const AOrigin: TBLPoint; const APath: TBLPath; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills the given `APath` translated by `AOrigin` with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillPath(const AOrigin: TBLPoint; const APath: TBLPath; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills the passed geometry specified by geometry `AType` and `AData`
    ///  with the default fill style.
    /// </summary>
    /// <remarks>
    ///  This method provides a low-level interface that can be used in cases in
    ///  which geometry `AType` and `AData` parameters are passed to a wrapper
    ///  function that just passes them to the rendering context. It's a good
    ///  way of creating wrappers, but generally low-level for a general purpose
    ///  use, so please use this with caution.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillGeometry(const AType: TBLGeometryType; const AData: Pointer); overload; inline;

    /// <summary>
    ///  Fills the passed geometry specified by geometry `AType` and `AData`
    ///  with an explicit fill `AStyle`.
    /// </summary>
    /// <remarks>
    ///  This method provides a low-level interface that can be used in cases in
    ///  which geometry `AType` and `AData` parameters are passed to a wrapper
    ///  function that just passes them to the rendering context. It's a good
    ///  way of creating wrappers, but generally low-level for a general purpose
    ///  use, so please use this with caution.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillGeometry(const AType: TBLGeometryType; const AData: Pointer; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills the passed geometry specified by geometry `AType` and `AData`
    ///  with an explicit fill `AStyle`.
    /// </summary>
    /// <remarks>
    ///  This method provides a low-level interface that can be used in cases in
    ///  which geometry `AType` and `AData` parameters are passed to a wrapper
    ///  function that just passes them to the rendering context. It's a good
    ///  way of creating wrappers, but generally low-level for a general purpose
    ///  use, so please use this with caution.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillGeometry(const AType: TBLGeometryType; const AData: Pointer; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills the passed geometry specified by geometry `AType` and `AData`
    ///  with an explicit fill `AStyle`.
    /// </summary>
    /// <remarks>
    ///  This method provides a low-level interface that can be used in cases in
    ///  which geometry `AType` and `AData` parameters are passed to a wrapper
    ///  function that just passes them to the rendering context. It's a good
    ///  way of creating wrappers, but generally low-level for a general purpose
    ///  use, so please use this with caution.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillGeometry(const AType: TBLGeometryType; const AData: Pointer; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills the passed geometry specified by geometry `AType` and `AData`
    ///  with an explicit fill `AStyle`.
    /// </summary>
    /// <remarks>
    ///  This method provides a low-level interface that can be used in cases in
    ///  which geometry `AType` and `AData` parameters are passed to a wrapper
    ///  function that just passes them to the rendering context. It's a good
    ///  way of creating wrappers, but generally low-level for a general purpose
    ///  use, so please use this with caution.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillGeometry(const AType: TBLGeometryType; const AData: Pointer; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills the passed geometry specified by geometry `AType` and `AData`
    ///  with an explicit fill `AStyle`.
    /// </summary>
    /// <remarks>
    ///  This method provides a low-level interface that can be used in cases in
    ///  which geometry `AType` and `AData` parameters are passed to a wrapper
    ///  function that just passes them to the rendering context. It's a good
    ///  way of creating wrappers, but generally low-level for a general purpose
    ///  use, so please use this with caution.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillGeometry(const AType: TBLGeometryType; const AData: Pointer; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills the passed geometry specified by geometry `AType` and `AData`
    ///  with an explicit fill `AStyle`.
    /// </summary>
    /// <remarks>
    ///  This method provides a low-level interface that can be used in cases in
    ///  which geometry `AType` and `AData` parameters are passed to a wrapper
    ///  function that just passes them to the rendering context. It's a good
    ///  way of creating wrappers, but generally low-level for a general purpose
    ///  use, so please use this with caution.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillGeometry(const AType: TBLGeometryType; const AData: Pointer; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills the passed geometry specified by geometry `AType` and `AData`
    ///  with an explicit fill `AStyle`.
    /// </summary>
    /// <remarks>
    ///  This method provides a low-level interface that can be used in cases in
    ///  which geometry `AType` and `AData` parameters are passed to a wrapper
    ///  function that just passes them to the rendering context. It's a good
    ///  way of creating wrappers, but generally low-level for a general purpose
    ///  use, so please use this with caution.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillGeometry(const AType: TBLGeometryType; const AData: Pointer; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with the default fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillText(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: String); overload; inline;

    /// <summary>
    ///  Fills string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillText(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: String; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillText(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: String; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillText(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: String; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillText(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: String; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillText(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: String; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillText(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: String; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillText(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: String; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with the default fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillText(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: String); overload; inline;

    /// <summary>
    ///  Fills string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillText(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: String; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillText(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: String; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillText(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: String; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillText(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: String; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillText(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: String; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillText(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: String; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillText(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: String; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (integer coordinates) with the default fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: UTF8String); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (integer coordinates) with the default fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AView: TBLStringView); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (integer coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (integer coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (integer coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (integer coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (integer coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (integer coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (integer coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (floating point coordinates) with the default fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: UTF8String); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (floating point coordinates) with the default fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AView: TBLStringView); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with the current fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillGlyphRun(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun); overload; inline;

    /// <summary>
    ///  Fills an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillGlyphRun(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillGlyphRun(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillGlyphRun(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillGlyphRun(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillGlyphRun(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillGlyphRun(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillGlyphRun(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with the current fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillGlyphRun(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun); overload; inline;

    /// <summary>
    ///  Fills an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillGlyphRun(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillGlyphRun(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillGlyphRun(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillGlyphRun(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillGlyphRun(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillGlyphRun(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillGlyphRun(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image at coordinates specified by `AOrigin`
    ///  (integer coordinates) with the current fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPointI; const AMask: TBLImage); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image at coordinates specified by `AOrigin`
    ///  (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPointI; const AMask: TBLImage;
      const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image at coordinates specified by `AOrigin`
    ///  (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPointI; const AMask: TBLImage;
      const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image at coordinates specified by `AOrigin`
    ///  (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPointI; const AMask: TBLImage;
      const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image at coordinates specified by `AOrigin`
    ///  (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPointI; const AMask: TBLImage;
      const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image at coordinates specified by `AOrigin`
    ///  (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPointI; const AMask: TBLImage;
      const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image at coordinates specified by `AOrigin`
    ///  (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPointI; const AMask: TBLImage;
      const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image at coordinates specified by `AOrigin`
    ///  (integer coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPointI; const AMask: TBLImage;
      const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image specified by `AMaskArea` at coordinates
    ///  specified by `AOrigin` (integer coordinates) with the current fill
    ///  style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPointI; const AMask, AMaskArea: TBLImage); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image specified by `AMaskArea` at coordinates
    ///  specified by `AOrigin` (integer coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPointI; const AMask, AMaskArea: TBLImage;
      const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image specified by `AMaskArea` at coordinates
    ///  specified by `AOrigin` (integer coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPointI; const AMask, AMaskArea: TBLImage;
      const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image specified by `AMaskArea` at coordinates
    ///  specified by `AOrigin` (integer coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPointI; const AMask, AMaskArea: TBLImage;
      const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image specified by `AMaskArea` at coordinates
    ///  specified by `AOrigin` (integer coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPointI; const AMask, AMaskArea: TBLImage;
      const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image specified by `AMaskArea` at coordinates
    ///  specified by `AOrigin` (integer coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPointI; const AMask, AMaskArea: TBLImage;
      const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image specified by `AMaskArea` at coordinates
    ///  specified by `AOrigin` (integer coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPointI; const AMask, AMaskArea: TBLImage;
      const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image specified by `AMaskArea` at coordinates
    ///  specified by `AOrigin` (integer coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPointI; const AMask, AMaskArea: TBLImage;
      const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image at coordinates specified by `AOrigin`
    ///  (floating point coordinates) with the current fill style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPoint; const AMask: TBLImage); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image at coordinates specified by `AOrigin`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPoint; const AMask: TBLImage;
      const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image at coordinates specified by `AOrigin`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPoint; const AMask: TBLImage;
      const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image at coordinates specified by `AOrigin`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPoint; const AMask: TBLImage;
      const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image at coordinates specified by `AOrigin`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPoint; const AMask: TBLImage;
      const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image at coordinates specified by `AOrigin`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPoint; const AMask: TBLImage;
      const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image at coordinates specified by `AOrigin`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPoint; const AMask: TBLImage;
      const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image at coordinates specified by `AOrigin`
    ///  (floating point coordinates) with an explicit fill `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPoint; const AMask: TBLImage;
      const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image specified by `AMaskArea` at coordinates
    ///  specified by `AOrigin` (floating point coordinates) with the current fill
    ///  style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPoint; const AMask, AMaskArea: TBLImage); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image specified by `AMaskArea` at coordinates
    ///  specified by `AOrigin` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPoint; const AMask, AMaskArea: TBLImage;
      const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image specified by `AMaskArea` at coordinates
    ///  specified by `AOrigin` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPoint; const AMask, AMaskArea: TBLImage;
      const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image specified by `AMaskArea` at coordinates
    ///  specified by `AOrigin` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPoint; const AMask, AMaskArea: TBLImage;
      const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image specified by `AMaskArea` at coordinates
    ///  specified by `AOrigin` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPoint; const AMask, AMaskArea: TBLImage;
      const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image specified by `AMaskArea` at coordinates
    ///  specified by `AOrigin` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPoint; const AMask, AMaskArea: TBLImage;
      const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image specified by `AMaskArea` at coordinates
    ///  specified by `AOrigin` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPoint; const AMask, AMaskArea: TBLImage;
      const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Fills a source `AMask` image specified by `AMaskArea` at coordinates
    ///  specified by `AOrigin` (floating point coordinates) with an explicit fill
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure FillMask(const AOrigin: TBLPoint; const AMask, AMaskArea: TBLImage;
      const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a `ABox` (floating point coordinates) with the current stroke style.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `StrokeRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="StrokeRect"/>
    procedure StrokeBox(const ABox: TBLBox); overload; inline;

    /// <summary>
    ///  Strokes a `ABox` (floating point coordinates)  with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `StrokeRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="StrokeRect"/>
    procedure StrokeBox(const ABox: TBLBox; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a `ABox` (floating point coordinates)  with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `StrokeRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="StrokeRect"/>
    procedure StrokeBox(const ABox: TBLBox; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a `ABox` (floating point coordinates)  with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `StrokeRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="StrokeRect"/>
    procedure StrokeBox(const ABox: TBLBox; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a `ABox` (floating point coordinates)  with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `StrokeRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="StrokeRect"/>
    procedure StrokeBox(const ABox: TBLBox; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a `ABox` (floating point coordinates)  with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `StrokeRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="StrokeRect"/>
    procedure StrokeBox(const ABox: TBLBox; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a `ABox` (floating point coordinates)  with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `StrokeRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="StrokeRect"/>
    procedure StrokeBox(const ABox: TBLBox; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a `ABox` (floating point coordinates)  with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `StrokeRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="StrokeRect"/>
    procedure StrokeBox(const ABox: TBLBox; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a `ABox` (integer coordinates) with the current stroke style.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `StrokeRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="StrokeRect"/>
    procedure StrokeBox(const ABox: TBLBoxI); overload; inline;

    /// <summary>
    ///  Strokes a `ABox` (integer coordinates)  with an explicit stroke `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `StrokeRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="StrokeRect"/>
    procedure StrokeBox(const ABox: TBLBoxI; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a `ABox` (integer coordinates)  with an explicit stroke `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `StrokeRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="StrokeRect"/>
    procedure StrokeBox(const ABox: TBLBoxI; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a `ABox` (integer coordinates)  with an explicit stroke `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `StrokeRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="StrokeRect"/>
    procedure StrokeBox(const ABox: TBLBoxI; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a `ABox` (integer coordinates)  with an explicit stroke `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `StrokeRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="StrokeRect"/>
    procedure StrokeBox(const ABox: TBLBoxI; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a `ABox` (integer coordinates)  with an explicit stroke `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `StrokeRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="StrokeRect"/>
    procedure StrokeBox(const ABox: TBLBoxI; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a `ABox` (integer coordinates)  with an explicit stroke `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `StrokeRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="StrokeRect"/>
    procedure StrokeBox(const ABox: TBLBoxI; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a `ABox` (integer coordinates)  with an explicit stroke `AStyle`.
    /// </summary>
    /// <remarks>
    ///  Box is defined as `[X0, Y0, X1, Y1]`, if you need `[X, Y, W, H]`, use
    ///  `StrokeRect` instead.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="StrokeRect"/>
    procedure StrokeBox(const ABox: TBLBoxI; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a box [AX0, AY0, AX1, AY1] (floating point coordinates) with the
    ///  current stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBox(const AX0, AY0, AX1, AY1: Double); overload; inline;

    /// <summary>
    ///  Strokes a box [AX0, AY0, AX1, AY1] (floating point coordinates) with an
    ///  explicit stroke `AStyle`
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBox(const AX0, AY0, AX1, AY1: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a box [AX0, AY0, AX1, AY1] (floating point coordinates) with an
    ///  explicit stroke `AStyle`
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBox(const AX0, AY0, AX1, AY1: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a box [AX0, AY0, AX1, AY1] (floating point coordinates) with an
    ///  explicit stroke `AStyle`
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBox(const AX0, AY0, AX1, AY1: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a box [AX0, AY0, AX1, AY1] (floating point coordinates) with an
    ///  explicit stroke `AStyle`
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBox(const AX0, AY0, AX1, AY1: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a box [AX0, AY0, AX1, AY1] (floating point coordinates) with an
    ///  explicit stroke `AStyle`
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBox(const AX0, AY0, AX1, AY1: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a box [AX0, AY0, AX1, AY1] (floating point coordinates) with an
    ///  explicit stroke `AStyle`
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBox(const AX0, AY0, AX1, AY1: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a box [AX0, AY0, AX1, AY1] (floating point coordinates) with an
    ///  explicit stroke `AStyle`
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBox(const AX0, AY0, AX1, AY1: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a rectangle `ARect` (integer coordinates) with the current stroke
    ///  style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRect(const ARect: TBLRectI); overload; inline;

    /// <summary>
    ///  Strokes a rectangle `ARect` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRect(const ARect: TBLRectI; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a rectangle `ARect` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRect(const ARect: TBLRectI; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a rectangle `ARect` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRect(const ARect: TBLRectI; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a rectangle `ARect` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRect(const ARect: TBLRectI; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a rectangle `ARect` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRect(const ARect: TBLRectI; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a rectangle `ARect` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRect(const ARect: TBLRectI; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a rectangle `ARect` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRect(const ARect: TBLRectI; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a rectangle `ARect` (floating point coordinates) with the current
    ///  stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRect(const ARect: TBLRect); overload; inline;

    /// <summary>
    ///  Strokes a rectangle `ARect` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRect(const ARect: TBLRect; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a rectangle `ARect` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRect(const ARect: TBLRect; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a rectangle `ARect` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRect(const ARect: TBLRect; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a rectangle `ARect` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRect(const ARect: TBLRect; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a rectangle `ARect` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRect(const ARect: TBLRect; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a rectangle `ARect` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRect(const ARect: TBLRect; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a rectangle `ARect` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRect(const ARect: TBLRect; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a rectangle `[AX, AY, AW, AH]` (floating point coordinates) with
    ///  the current stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRect(const AX, AY, AW, AH: Double); overload; inline;

    /// <summary>
    ///  Strokes a rectangle `[AX, AY, AW, AH]` (floating point coordinates) with
    ///  an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRect(const AX, AY, AW, AH: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a rectangle `[AX, AY, AW, AH]` (floating point coordinates) with
    ///  an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRect(const AX, AY, AW, AH: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a rectangle `[AX, AY, AW, AH]` (floating point coordinates) with
    ///  an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRect(const AX, AY, AW, AH: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a rectangle `[AX, AY, AW, AH]` (floating point coordinates) with
    ///  an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRect(const AX, AY, AW, AH: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a rectangle `[AX, AY, AW, AH]` (floating point coordinates) with
    ///  an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRect(const AX, AY, AW, AH: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a rectangle `[AX, AY, AW, AH]` (floating point coordinates) with
    ///  an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRect(const AX, AY, AW, AH: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a rectangle `[AX, AY, AW, AH]` (floating point coordinates) with
    ///  an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRect(const AX, AY, AW, AH: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a line specified as `ALine` (floating point coordinates) with
    ///  the default stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeLine(const ALine: TBLLine); overload; inline;

    /// <summary>
    ///  Strokes a line specified as `ALine` (floating point coordinates) with
    ///  an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeLine(const ALine: TBLLine; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a line specified as `ALine` (floating point coordinates) with
    ///  an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeLine(const ALine: TBLLine; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a line specified as `ALine` (floating point coordinates) with
    ///  an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeLine(const ALine: TBLLine; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a line specified as `ALine` (floating point coordinates) with
    ///  an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeLine(const ALine: TBLLine; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a line specified as `ALine` (floating point coordinates) with
    ///  an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeLine(const ALine: TBLLine; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a line specified as `ALine` (floating point coordinates) with
    ///  an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeLine(const ALine: TBLLine; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a line specified as `ALine` (floating point coordinates) with
    ///  an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeLine(const ALine: TBLLine; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a line starting at `AP0` and ending at `AP1` (floating point
    ///  coordinates) with the default stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeLine(const AP0, AP1: TBLPoint); overload; inline;

    /// <summary>
    ///  Strokes a line starting at `AP0` and ending at `AP1` (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeLine(const AP0, AP1: TBLPoint; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a line starting at `AP0` and ending at `AP1` (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeLine(const AP0, AP1: TBLPoint; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a line starting at `AP0` and ending at `AP1` (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeLine(const AP0, AP1: TBLPoint; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a line starting at `AP0` and ending at `AP1` (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeLine(const AP0, AP1: TBLPoint; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a line starting at `AP0` and ending at `AP1` (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeLine(const AP0, AP1: TBLPoint; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a line starting at `AP0` and ending at `AP1` (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeLine(const AP0, AP1: TBLPoint; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a line starting at `AP0` and ending at `AP1` (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeLine(const AP0, AP1: TBLPoint; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a line starting at `[AX0, AY0]` and ending at `[AX1, AY1]`
    ///  (floating point coordinates) with the default stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeLine(const AX0, AY0, AX1, AY1: Double); overload; inline;

    /// <summary>
    ///  Strokes a line starting at `[AX0, AY0]` and ending at `[AX1, AY1]`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeLine(const AX0, AY0, AX1, AY1: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a line starting at `[AX0, AY0]` and ending at `[AX1, AY1]`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeLine(const AX0, AY0, AX1, AY1: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a line starting at `[AX0, AY0]` and ending at `[AX1, AY1]`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeLine(const AX0, AY0, AX1, AY1: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a line starting at `[AX0, AY0]` and ending at `[AX1, AY1]`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeLine(const AX0, AY0, AX1, AY1: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a line starting at `[AX0, AY0]` and ending at `[AX1, AY1]`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeLine(const AX0, AY0, AX1, AY1: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a line starting at `[AX0, AY0]` and ending at `[AX1, AY1]`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeLine(const AX0, AY0, AX1, AY1: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a line starting at `[AX0, AY0]` and ending at `[AX1, AY1]`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeLine(const AX0, AY0, AX1, AY1: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes an `ACircle` (floating point coordinates) with the current stroke
    ///  style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeCircle(const ACircle: TBLCircle); overload; inline;

    /// <summary>
    ///  Strokes an `ACircle` (floating point coordinates)  with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeCircle(const ACircle: TBLCircle; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes an `ACircle` (floating point coordinates)  with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeCircle(const ACircle: TBLCircle; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes an `ACircle` (floating point coordinates)  with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeCircle(const ACircle: TBLCircle; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes an `ACircle` (floating point coordinates)  with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeCircle(const ACircle: TBLCircle; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes an `ACircle` (floating point coordinates)  with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeCircle(const ACircle: TBLCircle; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes an `ACircle` (floating point coordinates)  with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeCircle(const ACircle: TBLCircle; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes an `ACircle` (floating point coordinates)  with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeCircle(const ACircle: TBLCircle; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a circle at `[ACX, ACY]` and radius `AR` (floating point
    ///  coordinates) with the current stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeCircle(const ACX, ACY, AR: Double); overload; inline;

    /// <summary>
    ///  Strokes a circle at `[ACX, ACY]` and radius `AR` (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeCircle(const ACX, ACY, AR: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a circle at `[ACX, ACY]` and radius `AR` (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeCircle(const ACX, ACY, AR: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a circle at `[ACX, ACY]` and radius `AR` (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeCircle(const ACX, ACY, AR: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a circle at `[ACX, ACY]` and radius `AR` (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeCircle(const ACX, ACY, AR: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a circle at `[ACX, ACY]` and radius `AR` (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeCircle(const ACX, ACY, AR: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a circle at `[ACX, ACY]` and radius `AR` (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeCircle(const ACX, ACY, AR: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a circle at `[ACX, ACY]` and radius `AR` (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeCircle(const ACX, ACY, AR: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes an `AEllipse` (floating point coordinates) with the current stroke
    ///  style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeEllipse(const AEllipse: TBLEllipse); overload; inline;

    /// <summary>
    ///  Strokes an `AEllipse` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeEllipse(const AEllipse: TBLEllipse; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes an `AEllipse` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeEllipse(const AEllipse: TBLEllipse; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes an `AEllipse` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeEllipse(const AEllipse: TBLEllipse; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes an `AEllipse` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeEllipse(const AEllipse: TBLEllipse; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes an `AEllipse` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeEllipse(const AEllipse: TBLEllipse; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes an `AEllipse` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeEllipse(const AEllipse: TBLEllipse; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes an `AEllipse` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeEllipse(const AEllipse: TBLEllipse; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes an ellipse at `[ACX, ACY]` with radius `[ARX, ARY]` (floating
    ///  point coordinates) with the current stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeEllipse(const ACX, ACY, ARX, ARY: Double); overload; inline;

    /// <summary>
    ///  Strokes an ellipse at `[ACX, ACY]` with radius `[ARX, ARY]` (floating
    ///  point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeEllipse(const ACX, ACY, ARX, ARY: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes an ellipse at `[ACX, ACY]` with radius `[ARX, ARY]` (floating
    ///  point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeEllipse(const ACX, ACY, ARX, ARY: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes an ellipse at `[ACX, ACY]` with radius `[ARX, ARY]` (floating
    ///  point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeEllipse(const ACX, ACY, ARX, ARY: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes an ellipse at `[ACX, ACY]` with radius `[ARX, ARY]` (floating
    ///  point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeEllipse(const ACX, ACY, ARX, ARY: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes an ellipse at `[ACX, ACY]` with radius `[ARX, ARY]` (floating
    ///  point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeEllipse(const ACX, ACY, ARX, ARY: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes an ellipse at `[ACX, ACY]` with radius `[ARX, ARY]` (floating
    ///  point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeEllipse(const ACX, ACY, ARX, ARY: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes an ellipse at `[ACX, ACY]` with radius `[ARX, ARY]` (floating
    ///  point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeEllipse(const ACX, ACY, ARX, ARY: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle `ARR` (floating point coordinates) with the
    ///  current stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const ARR: TBLRoundRect); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle `ARR` (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const ARR: TBLRoundRect; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle `ARR` (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const ARR: TBLRoundRect; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle `ARR` (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const ARR: TBLRoundRect; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle `ARR` (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const ARR: TBLRoundRect; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle `ARR` (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const ARR: TBLRoundRect; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle `ARR` (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const ARR: TBLRoundRect; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle `ARR` (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const ARR: TBLRoundRect; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `ARect` with radius `AR` with the
    ///  current stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const ARect: TBLRect; const AR: Double); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `ARect` with radius `AR` with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const ARect: TBLRect; const AR: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `ARect` with radius `AR` with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const ARect: TBLRect; const AR: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `ARect` with radius `AR` with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const ARect: TBLRect; const AR: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `ARect` with radius `AR` with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const ARect: TBLRect; const AR: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `ARect` with radius `AR` with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const ARect: TBLRect; const AR: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `ARect` with radius `AR` with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const ARect: TBLRect; const AR: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `ARect` with radius `AR` with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const ARect: TBLRect; const AR: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `ARect` with radius `[ARX, ARY]`
    ///  with the current stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const ARect: TBLRect; const ARX, ARY: Double); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `ARect` with radius `[ARX, ARY]`
    ///  with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const ARect: TBLRect; const ARX, ARY: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `ARect` with radius `[ARX, ARY]`
    ///  with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const ARect: TBLRect; const ARX, ARY: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `ARect` with radius `[ARX, ARY]`
    ///  with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const ARect: TBLRect; const ARX, ARY: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `ARect` with radius `[ARX, ARY]`
    ///  with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const ARect: TBLRect; const ARX, ARY: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `ARect` with radius `[ARX, ARY]`
    ///  with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const ARect: TBLRect; const ARX, ARY: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `ARect` with radius `[ARX, ARY]`
    ///  with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const ARect: TBLRect; const ARX, ARY: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `ARect` with radius `[ARX, ARY]`
    ///  with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const ARect: TBLRect; const ARX, ARY: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `AR` with the current stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const AX, AY, AW, AH, AR: Double); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `AR` with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const AX, AY, AW, AH, AR: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `AR` with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const AX, AY, AW, AH, AR: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `AR` with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const AX, AY, AW, AH, AR: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `AR` with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const AX, AY, AW, AH, AR: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `AR` with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const AX, AY, AW, AH, AR: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `AR` with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const AX, AY, AW, AH, AR: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `AR` with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const AX, AY, AW, AH, AR: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `[ARX, ARY]` with the current stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const AX, AY, AW, AH, ARX, ARY: Double); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `[ARX, ARY]` with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const AX, AY, AW, AH, ARX, ARY: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `[ARX, ARY]` with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const AX, AY, AW, AH, ARX, ARY: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `[ARX, ARY]` with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const AX, AY, AW, AH, ARX, ARY: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `[ARX, ARY]` with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const AX, AY, AW, AH, ARX, ARY: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `[ARX, ARY]` with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const AX, AY, AW, AH, ARX, ARY: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `[ARX, ARY]` with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const AX, AY, AW, AH, ARX, ARY: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a rounded rectangle bounded by `[AX, AY, AW, AH]` with radius
    ///  `[ARX, ARY]` with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRoundRect(const AX, AY, AW, AH, ARX, ARY: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes an `AArc` (floating point coordinates) with the current stroke
    ///  style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeArc(const AArc: TBLArc); overload; inline;

    /// <summary>
    ///  Strokes an `AArc` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeArc(const AArc: TBLArc; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes an `AArc` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeArc(const AArc: TBLArc; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes an `AArc` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeArc(const AArc: TBLArc; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes an `AArc` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeArc(const AArc: TBLArc; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes an `AArc` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeArc(const AArc: TBLArc; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes an `AArc` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeArc(const AArc: TBLArc; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes an `AArc` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeArc(const AArc: TBLArc; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with the current stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeArc(const ACX, ACY, AR, AStart, ASweep: Double); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeArc(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeArc(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeArc(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeArc(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeArc(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeArc(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeArc(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with the current stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeArc(const ACX, ACY, ARX, ARY, AStart, ASweep: Double); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeArc(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeArc(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeArc(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeArc(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeArc(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeArc(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeArc(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes an `AChord` (floating point coordinates) with the current stroke
    ///  style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeChord(const AChord: TBLArc); overload; inline;

    /// <summary>
    ///  Strokes an `AChord` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeChord(const AChord: TBLArc; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes an `AChord` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeChord(const AChord: TBLArc; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes an `AChord` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeChord(const AChord: TBLArc; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes an `AChord` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeChord(const AChord: TBLArc; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes an `AChord` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeChord(const AChord: TBLArc; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes an `AChord` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeChord(const AChord: TBLArc; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes an `AChord` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeChord(const AChord: TBLArc; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with the current stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeChord(const ACX, ACY, AR, AStart, ASweep: Double); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeChord(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeChord(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeChord(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeChord(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeChord(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeChord(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeChord(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with the current stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes an `APie` (floating point coordinates) with the current stroke
    ///  style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePie(const APie: TBLArc); overload; inline;

    /// <summary>
    ///  Strokes an `APie` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePie(const APie: TBLArc; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes an `APie` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePie(const APie: TBLArc; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes an `APie` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePie(const APie: TBLArc; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes an `APie` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePie(const APie: TBLArc; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes an `APie` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePie(const APie: TBLArc; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes an `APie` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePie(const APie: TBLArc; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes an `APie` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePie(const APie: TBLArc; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with the current stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePie(const ACX, ACY, AR, AStart, ASweep: Double); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePie(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePie(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePie(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePie(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePie(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePie(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `AR` at `AStart` of `ASweep`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePie(const ACX, ACY, AR, AStart, ASweep: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with the current stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a chord at `[ACX, ACY]` with radius `[ARX, ARY]` at `AStart` of
    ///  `ASweep` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes an `ATriangle` (floating point coordinates) with the current stroke
    ///  style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeTriangle(const ATriangle: TBLTriangle); overload; inline;

    /// <summary>
    ///  Strokes an `ATriangle` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeTriangle(const ATriangle: TBLTriangle; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes an `ATriangle` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeTriangle(const ATriangle: TBLTriangle; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes an `ATriangle` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeTriangle(const ATriangle: TBLTriangle; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes an `ATriangle` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeTriangle(const ATriangle: TBLTriangle; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes an `ATriangle` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeTriangle(const ATriangle: TBLTriangle; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes an `ATriangle` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeTriangle(const ATriangle: TBLTriangle; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes an `ATriangle` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeTriangle(const ATriangle: TBLTriangle; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a triangle defined by `[AX0, AY0]`, `[AX1, AY1]`, `[AX2, AY2]`
    ///  (floating point coordinates) with the current stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double); overload; inline;

    /// <summary>
    ///  Strokes a triangle defined by `[AX0, AY0]`, `[AX1, AY1]`, `[AX2, AY2]`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a triangle defined by `[AX0, AY0]`, `[AX1, AY1]`, `[AX2, AY2]`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a triangle defined by `[AX0, AY0]`, `[AX1, AY1]`, `[AX2, AY2]`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a triangle defined by `[AX0, AY0]`, `[AX1, AY1]`, `[AX2, AY2]`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a triangle defined by `[AX0, AY0]`, `[AX1, AY1]`, `[AX2, AY2]`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a triangle defined by `[AX0, AY0]`, `[AX1, AY1]`, `[AX2, AY2]`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a triangle defined by `[AX0, AY0]`, `[AX1, AY1]`, `[AX2, AY2]`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (floating point coordinates) with the current
    ///  stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TArray<TBLPoint>); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TArray<TBLPoint>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TArray<TBLPoint>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TArray<TBLPoint>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TArray<TBLPoint>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TArray<TBLPoint>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TArray<TBLPoint>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TArray<TBLPoint>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (floating point coordinates) with the current
    ///  stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TBLArrayView<TBLPoint>); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TBLArrayView<TBLPoint>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TBLArrayView<TBLPoint>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TBLArrayView<TBLPoint>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TBLArrayView<TBLPoint>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TBLArrayView<TBLPoint>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TBLArrayView<TBLPoint>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TBLArrayView<TBLPoint>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` having 'ACount' vertices (floating point
    ///  coordinates) with the current stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: PBLPoint; const ACount: NativeInt); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` having 'ACount' vertices (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: PBLPoint; const ACount: NativeInt; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` having 'ACount' vertices (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: PBLPoint; const ACount: NativeInt; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` having 'ACount' vertices (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: PBLPoint; const ACount: NativeInt; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` having 'ACount' vertices (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: PBLPoint; const ACount: NativeInt; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` having 'ACount' vertices (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: PBLPoint; const ACount: NativeInt; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` having 'ACount' vertices (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: PBLPoint; const ACount: NativeInt; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` having 'ACount' vertices (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: PBLPoint; const ACount: NativeInt; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (integer coordinates) with the current
    ///  stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TArray<TBLPointI>); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TArray<TBLPointI>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TArray<TBLPointI>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TArray<TBLPointI>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TArray<TBLPointI>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TArray<TBLPointI>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TArray<TBLPointI>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TArray<TBLPointI>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (integer coordinates) with the current
    ///  stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TBLArrayView<TBLPointI>); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TBLArrayView<TBLPointI>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TBLArrayView<TBLPointI>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TBLArrayView<TBLPointI>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TBLArrayView<TBLPointI>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TBLArrayView<TBLPointI>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TBLArrayView<TBLPointI>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: TBLArrayView<TBLPointI>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` having 'ACount' vertices (integer
    ///  coordinates) with the current stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: PBLPointI; const ACount: NativeInt); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` having 'ACount' vertices (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: PBLPointI; const ACount: NativeInt; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` having 'ACount' vertices (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: PBLPointI; const ACount: NativeInt; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` having 'ACount' vertices (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: PBLPointI; const ACount: NativeInt; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` having 'ACount' vertices (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: PBLPointI; const ACount: NativeInt; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` having 'ACount' vertices (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: PBLPointI; const ACount: NativeInt; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` having 'ACount' vertices (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: PBLPointI; const ACount: NativeInt; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a polyline `APoly` having 'ACount' vertices (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolyline(const APoly: PBLPointI; const ACount: NativeInt; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (floating point coordinates) with the current
    ///  stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TArray<TBLPoint>); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TArray<TBLPoint>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TArray<TBLPoint>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TArray<TBLPoint>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TArray<TBLPoint>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TArray<TBLPoint>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TArray<TBLPoint>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TArray<TBLPoint>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (floating point coordinates) with the current
    ///  stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TBLArrayView<TBLPoint>); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TBLArrayView<TBLPoint>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TBLArrayView<TBLPoint>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TBLArrayView<TBLPoint>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TBLArrayView<TBLPoint>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TBLArrayView<TBLPoint>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TBLArrayView<TBLPoint>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (floating point coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TBLArrayView<TBLPoint>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` having 'ACount' vertices (floating point
    ///  coordinates) with the current stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: PBLPoint; const ACount: NativeInt); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` having 'ACount' vertices (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: PBLPoint; const ACount: NativeInt; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` having 'ACount' vertices (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: PBLPoint; const ACount: NativeInt; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` having 'ACount' vertices (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: PBLPoint; const ACount: NativeInt; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` having 'ACount' vertices (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: PBLPoint; const ACount: NativeInt; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` having 'ACount' vertices (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: PBLPoint; const ACount: NativeInt; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` having 'ACount' vertices (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: PBLPoint; const ACount: NativeInt; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` having 'ACount' vertices (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: PBLPoint; const ACount: NativeInt; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (integer coordinates) with the current
    ///  stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TArray<TBLPointI>); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TArray<TBLPointI>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TArray<TBLPointI>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TArray<TBLPointI>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TArray<TBLPointI>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TArray<TBLPointI>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TArray<TBLPointI>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TArray<TBLPointI>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (integer coordinates) with the current
    ///  stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TBLArrayView<TBLPointI>); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TBLArrayView<TBLPointI>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TBLArrayView<TBLPointI>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TBLArrayView<TBLPointI>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TBLArrayView<TBLPointI>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TBLArrayView<TBLPointI>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TBLArrayView<TBLPointI>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` (integer coordinates) with an explicit
    ///  stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: TBLArrayView<TBLPointI>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` having 'ACount' vertices (integer
    ///  coordinates) with the current stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: PBLPointI; const ACount: NativeInt); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` having 'ACount' vertices (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: PBLPointI; const ACount: NativeInt; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` having 'ACount' vertices (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: PBLPointI; const ACount: NativeInt; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` having 'ACount' vertices (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: PBLPointI; const ACount: NativeInt; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` having 'ACount' vertices (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: PBLPointI; const ACount: NativeInt; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` having 'ACount' vertices (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: PBLPointI; const ACount: NativeInt; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` having 'ACount' vertices (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: PBLPointI; const ACount: NativeInt; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes a polygon `APoly` having 'ACount' vertices (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePolygon(const APoly: PBLPointI; const ACount: NativeInt; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (floating point coordinates) with the
    ///  default stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TArray<TBLBox>); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TArray<TBLBox>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TArray<TBLBox>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TArray<TBLBox>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TArray<TBLBox>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TArray<TBLBox>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TArray<TBLBox>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TArray<TBLBox>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (floating point coordinates) with the
    ///  default stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TBLArrayView<TBLBox>); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TBLArrayView<TBLBox>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TBLArrayView<TBLBox>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TBLArrayView<TBLBox>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TBLArrayView<TBLBox>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TBLArrayView<TBLBox>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TBLArrayView<TBLBox>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TBLArrayView<TBLBox>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes or size 'ACount' (floating point
    ///  coordinates) with the default stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: PBLBox; const ACount: NativeInt); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes or size 'ACount' (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: PBLBox; const ACount: NativeInt; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes or size 'ACount' (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: PBLBox; const ACount: NativeInt; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes or size 'ACount' (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: PBLBox; const ACount: NativeInt; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes or size 'ACount' (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: PBLBox; const ACount: NativeInt; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes or size 'ACount' (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: PBLBox; const ACount: NativeInt; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes or size 'ACount' (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: PBLBox; const ACount: NativeInt; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes or size 'ACount' (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: PBLBox; const ACount: NativeInt; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (integer coordinates) with the
    ///  default stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TArray<TBLBoxI>); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TArray<TBLBoxI>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TArray<TBLBoxI>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TArray<TBLBoxI>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TArray<TBLBoxI>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TArray<TBLBoxI>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TArray<TBLBoxI>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TArray<TBLBoxI>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (integer coordinates) with the
    ///  default stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TBLArrayView<TBLBoxI>); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TBLArrayView<TBLBoxI>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TBLArrayView<TBLBoxI>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TBLArrayView<TBLBoxI>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TBLArrayView<TBLBoxI>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TBLArrayView<TBLBoxI>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TBLArrayView<TBLBoxI>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: TBLArrayView<TBLBoxI>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes or size 'ACount' (integer
    ///  coordinates) with the default stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: PBLBoxI; const ACount: NativeInt); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes or size 'ACount' (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: PBLBoxI; const ACount: NativeInt; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes or size 'ACount' (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: PBLBoxI; const ACount: NativeInt; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes or size 'ACount' (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: PBLBoxI; const ACount: NativeInt; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes or size 'ACount' (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: PBLBoxI; const ACount: NativeInt; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes or size 'ACount' (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: PBLBoxI; const ACount: NativeInt; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes or size 'ACount' (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: PBLBoxI; const ACount: NativeInt; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of boxes or size 'ACount' (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeBoxArray(const AArray: PBLBoxI; const ACount: NativeInt; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (floating point coordinates) with the
    ///  default stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TArray<TBLRect>); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TArray<TBLRect>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TArray<TBLRect>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TArray<TBLRect>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TArray<TBLRect>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TArray<TBLRect>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TArray<TBLRect>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TArray<TBLRect>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (floating point coordinates) with the
    ///  default stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TBLArrayView<TBLRect>); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TBLArrayView<TBLRect>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TBLArrayView<TBLRect>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TBLArrayView<TBLRect>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TBLArrayView<TBLRect>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TBLArrayView<TBLRect>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TBLArrayView<TBLRect>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (floating point coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TBLArrayView<TBLRect>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles or size 'ACount' (floating point
    ///  coordinates) with the default stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: PBLRect; const ACount: NativeInt); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles or size 'ACount' (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: PBLRect; const ACount: NativeInt; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles or size 'ACount' (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: PBLRect; const ACount: NativeInt; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles or size 'ACount' (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: PBLRect; const ACount: NativeInt; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles or size 'ACount' (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: PBLRect; const ACount: NativeInt; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles or size 'ACount' (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: PBLRect; const ACount: NativeInt; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles or size 'ACount' (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: PBLRect; const ACount: NativeInt; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles or size 'ACount' (floating point
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: PBLRect; const ACount: NativeInt; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (integer coordinates) with the
    ///  default stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TArray<TBLRectI>); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TArray<TBLRectI>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TArray<TBLRectI>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TArray<TBLRectI>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TArray<TBLRectI>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TArray<TBLRectI>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TArray<TBLRectI>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TArray<TBLRectI>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (integer coordinates) with the
    ///  default stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TBLArrayView<TBLRectI>); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TBLArrayView<TBLRectI>; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TBLArrayView<TBLRectI>; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TBLArrayView<TBLRectI>; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TBLArrayView<TBLRectI>; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TBLArrayView<TBLRectI>; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TBLArrayView<TBLRectI>; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles (integer coordinates) with an
    ///  explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: TBLArrayView<TBLRectI>; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles or size 'ACount' (integer
    ///  coordinates) with the default stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: PBLRectI; const ACount: NativeInt); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles or size 'ACount' (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: PBLRectI; const ACount: NativeInt; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles or size 'ACount' (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: PBLRectI; const ACount: NativeInt; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles or size 'ACount' (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: PBLRectI; const ACount: NativeInt; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles or size 'ACount' (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: PBLRectI; const ACount: NativeInt; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles or size 'ACount' (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: PBLRectI; const ACount: NativeInt; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles or size 'ACount' (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: PBLRectI; const ACount: NativeInt; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes an `AArray` of rectangles or size 'ACount' (integer
    ///  coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeRectArray(const AArray: PBLRectI; const ACount: NativeInt; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes the given `APath` with the default stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePath(const APath: TBLPath); overload; inline;

    /// <summary>
    ///  Strokes the given `APath` with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePath(const APath: TBLPath; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes the given `APath` with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePath(const APath: TBLPath; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes the given `APath` with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePath(const APath: TBLPath; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes the given `APath` with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePath(const APath: TBLPath; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes the given `APath` with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePath(const APath: TBLPath; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes the given `APath` with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePath(const APath: TBLPath; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes the given `APath` with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePath(const APath: TBLPath; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes the given `APath` translated by `AOrigin` with the default stroke
    ///  style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePath(const AOrigin: TBLPoint; const APath: TBLPath); overload; inline;

    /// <summary>
    ///  Strokes the given `APath` translated by `AOrigin` with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePath(const AOrigin: TBLPoint; const APath: TBLPath; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes the given `APath` translated by `AOrigin` with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePath(const AOrigin: TBLPoint; const APath: TBLPath; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes the given `APath` translated by `AOrigin` with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePath(const AOrigin: TBLPoint; const APath: TBLPath; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes the given `APath` translated by `AOrigin` with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePath(const AOrigin: TBLPoint; const APath: TBLPath; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes the given `APath` translated by `AOrigin` with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePath(const AOrigin: TBLPoint; const APath: TBLPath; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes the given `APath` translated by `AOrigin` with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePath(const AOrigin: TBLPoint; const APath: TBLPath; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes the given `APath` translated by `AOrigin` with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokePath(const AOrigin: TBLPoint; const APath: TBLPath; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes the passed geometry specified by geometry `AType` and `AData`
    ///  with the default stroke style.
    /// </summary>
    /// <remarks>
    ///  This method provides a low-level interface that can be used in cases in
    ///  which geometry `AType` and `AData` parameters are passed to a wrapper
    ///  function that just passes them to the rendering context. It's a good
    ///  way of creating wrappers, but generally low-level for a general purpose
    ///  use, so please use this with caution.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeGeometry(const AType: TBLGeometryType; const AData: Pointer); overload; inline;

    /// <summary>
    ///  Strokes the passed geometry specified by geometry `AType` and `AData`
    ///  with an explicit stroke `AStyle`.
    /// </summary>
    /// <remarks>
    ///  This method provides a low-level interface that can be used in cases in
    ///  which geometry `AType` and `AData` parameters are passed to a wrapper
    ///  function that just passes them to the rendering context. It's a good
    ///  way of creating wrappers, but generally low-level for a general purpose
    ///  use, so please use this with caution.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeGeometry(const AType: TBLGeometryType; const AData: Pointer; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes the passed geometry specified by geometry `AType` and `AData`
    ///  with an explicit stroke `AStyle`.
    /// </summary>
    /// <remarks>
    ///  This method provides a low-level interface that can be used in cases in
    ///  which geometry `AType` and `AData` parameters are passed to a wrapper
    ///  function that just passes them to the rendering context. It's a good
    ///  way of creating wrappers, but generally low-level for a general purpose
    ///  use, so please use this with caution.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeGeometry(const AType: TBLGeometryType; const AData: Pointer; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes the passed geometry specified by geometry `AType` and `AData`
    ///  with an explicit stroke `AStyle`.
    /// </summary>
    /// <remarks>
    ///  This method provides a low-level interface that can be used in cases in
    ///  which geometry `AType` and `AData` parameters are passed to a wrapper
    ///  function that just passes them to the rendering context. It's a good
    ///  way of creating wrappers, but generally low-level for a general purpose
    ///  use, so please use this with caution.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeGeometry(const AType: TBLGeometryType; const AData: Pointer; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes the passed geometry specified by geometry `AType` and `AData`
    ///  with an explicit stroke `AStyle`.
    /// </summary>
    /// <remarks>
    ///  This method provides a low-level interface that can be used in cases in
    ///  which geometry `AType` and `AData` parameters are passed to a wrapper
    ///  function that just passes them to the rendering context. It's a good
    ///  way of creating wrappers, but generally low-level for a general purpose
    ///  use, so please use this with caution.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeGeometry(const AType: TBLGeometryType; const AData: Pointer; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes the passed geometry specified by geometry `AType` and `AData`
    ///  with an explicit stroke `AStyle`.
    /// </summary>
    /// <remarks>
    ///  This method provides a low-level interface that can be used in cases in
    ///  which geometry `AType` and `AData` parameters are passed to a wrapper
    ///  function that just passes them to the rendering context. It's a good
    ///  way of creating wrappers, but generally low-level for a general purpose
    ///  use, so please use this with caution.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeGeometry(const AType: TBLGeometryType; const AData: Pointer; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes the passed geometry specified by geometry `AType` and `AData`
    ///  with an explicit stroke `AStyle`.
    /// </summary>
    /// <remarks>
    ///  This method provides a low-level interface that can be used in cases in
    ///  which geometry `AType` and `AData` parameters are passed to a wrapper
    ///  function that just passes them to the rendering context. It's a good
    ///  way of creating wrappers, but generally low-level for a general purpose
    ///  use, so please use this with caution.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeGeometry(const AType: TBLGeometryType; const AData: Pointer; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes the passed geometry specified by geometry `AType` and `AData`
    ///  with an explicit stroke `AStyle`.
    /// </summary>
    /// <remarks>
    ///  This method provides a low-level interface that can be used in cases in
    ///  which geometry `AType` and `AData` parameters are passed to a wrapper
    ///  function that just passes them to the rendering context. It's a good
    ///  way of creating wrappers, but generally low-level for a general purpose
    ///  use, so please use this with caution.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeGeometry(const AType: TBLGeometryType; const AData: Pointer; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with the default stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeText(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: String); overload; inline;

    /// <summary>
    ///  Strokes string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeText(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: String; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeText(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: String; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeText(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: String; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeText(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: String; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeText(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: String; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeText(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: String; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeText(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: String; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with the default stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeText(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: String); overload; inline;

    /// <summary>
    ///  Strokes string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeText(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: String; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeText(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: String; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeText(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: String; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeText(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: String; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeText(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: String; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeText(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: String; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes string passed as `AText` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeText(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: String; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (integer coordinates) with the default stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: UTF8String); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (integer coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (integer coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (integer coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (integer coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (integer coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (integer coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (integer coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (integer coordinates) with the default stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AView: TBLStringView); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (integer coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (integer coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (integer coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (integer coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (integer coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (integer coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (integer coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (floating point coordinates) with the default stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: UTF8String); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as `AText` by using the given `AFont`
    ///  at `AOrigin` (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AText: UTF8String; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (floating point coordinates) with the default stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AView: TBLStringView); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes UTF-8 encoded string passed as string `AView` by using the given
    ///  `AFont` at `AOrigin` (floating point coordinates) with an explicit stroke
    ///  `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeUtf8Text(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AView: TBLStringView; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with the current stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeGlyphRun(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun); overload; inline;

    /// <summary>
    ///  Strokes an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeGlyphRun(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeGlyphRun(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeGlyphRun(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeGlyphRun(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeGlyphRun(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeGlyphRun(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (integer coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeGlyphRun(const AOrigin: TBLPointI; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Strokes an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with the current stroke style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeGlyphRun(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun); overload; inline;

    /// <summary>
    ///  Strokes an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeGlyphRun(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TBLRgba); overload; inline;

    /// <summary>
    ///  Strokes an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeGlyphRun(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TBLRgba32); overload; inline;

    /// <summary>
    ///  Strokes an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeGlyphRun(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TBLRgba64); overload; inline;

    /// <summary>
    ///  Strokes an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeGlyphRun(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TAlphaColor); overload; inline;

    /// <summary>
    ///  Strokes an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeGlyphRun(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TBLPattern); overload; inline;

    /// <summary>
    ///  Strokes an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeGlyphRun(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TBLGradient); overload; inline;

    /// <summary>
    ///  Strokes an `AGlyphRun` by using the given `AFont` at `AOrigin`
    ///  (floating point coordinates) with an explicit stroke `AStyle`.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure StrokeGlyphRun(const AOrigin: TBLPoint; const AFont: TBLFont;
      const AGlyphRun: TBLGlyphRun; const AStyle: TBLVar); overload; inline;

    /// <summary>
    ///  Blits source image `ASrc` at coordinates specified by `AOrigin`
    ///  (integer coordinates).
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure BlitImage(const AOrigin: TBLPointI; const ASrc: TBLImage); overload; inline;

    /// <summary>
    ///  Blits an area in source image `ASrc` specified by `ASrcArea` at
    ///  coordinates specified by `AOrigin` (integer coordinates).
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure BlitImage(const AOrigin: TBLPointI; const ASrc: TBLImage;
      const ASrcArea: TBLRectI); overload; inline;

    /// <summary>
    ///  Blits source image `ASrc` at coordinates specified by `AOrigin`
    ///  (floating point coordinates).
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure BlitImage(const AOrigin: TBLPoint; const ASrc: TBLImage); overload; inline;

    /// <summary>
    ///  Blits an area in source image `ASrc` specified by `ASrcArea` at
    ///  coordinates specified by `AOrigin` (floating point coordinates).
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure BlitImage(const AOrigin: TBLPoint; const ASrc: TBLImage;
      const ASrcArea: TBLRect); overload; inline;

    /// <summary>
    ///  Blits a source image `ASrc` scaled to fit into `ARect` rectangle
    ///  (integer coordinates).
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure BlitImage(const ARect: TBLRectI; const ASrc: TBLImage); overload; inline;

    /// <summary>
    ///  Blits an area of source image `ASrc` specified by `ASrcArea` scaled to
    ///  fit into `ARect` rectangle (integer coordinates).
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure BlitImage(const ARect: TBLRectI; const ASrc: TBLImage;
      const ASrcArea: TBLRectI); overload; inline;

    /// <summary>
    ///  Blits a source image `ASrc` scaled to fit into `ARect` rectangle
    ///  (floating point coordinates).
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure BlitImage(const ARect: TBLRect; const ASrc: TBLImage); overload; inline;

    /// <summary>
    ///  Blits an area of source image `ASrc` specified by `ASrcArea` scaled to
    ///  fit into `ARect` rectangle (floating point coordinates).
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    procedure BlitImage(const ARect: TBLRect; const ASrc: TBLImage;
      const ASrcArea: TBLRect); overload; inline;

    /// <summary>
    ///  The target size in abstract units (pixels in case of `TBLImage`).
    /// </summary>
    property TargetSize: TBLSize read GetTargetSize;

    /// <summary>
    ///  The target width in abstract units (pixels in case of `TBLImage`).
    /// </summary>
    property TargetWidth: Double read GetTargetWidth;

    /// <summary>
    ///  The target height in abstract units (pixels in case of `TBLImage`).
    /// </summary>
    property TargetHeight: Double read GetTargetHeight;

    /// <summary>
    ///  Returns the target image or nil if there is no target image.
    /// </summary>
    /// <remarks>
    ///  The rendering context doesn't own the image, but it increases its
    ///  writer count, which means that the image will not be destroyed even
    ///  when user destroys it during the rendering (in such case it will be
    ///  destroyed after the rendering ends when the writer count goes to zero).
    ///  This means that the rendering context must hold the image and not the
    ///  `TBLImage` passed to either the constructor or `Start` method. So the
    ///  returned image is not the same as the image passed to `Start`, but it
    ///  points to the same underlying data.
    /// </remarks>
    property TargetImage: TBLImage read GetTargetImage;

    /// <summary>
    ///  Returns the type of this context, see \ref BLContextType.
    /// </summary>
    property ContextType: TBLContextType read GetContextType;

    /// <summary>
    ///  Tests whether the context is a valid rendering context that has
    ///  attached target to it.
    /// </summary>
    property IsValid: Boolean read GetIsValid;

    /// <summary>
    ///  The number of threads that the rendering context uses.
    ///
    ///  If the returned value is zero it means that the rendering is
    ///  synchronous, otherwise it describes the number of  threads used for
    ///  asynchronous rendering which include the user thread. For example if
    ///  the returned value is `2` it means that the rendering context uses the
    ///  user thread and one more worker.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property ThreadCount: Integer read GetThreadCount;

    /// <summary>
    ///  Accumulated errors as flags.
    ///
    ///  Errors may accumulate during the lifetime of the rendering context.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property AccumulatedErrorFlags: TBLContextErrorFlags read GetAccumulatedErrorFlags;

    /// <summary>
    ///  The number of saved states in the context (0 means no saved states).
    /// </summary>
    /// <remarks>
    ///  Each successful call to `Save` increments the saved-state counter and
    ///  each successful call to `Restore` decrements it. However, the calls
    ///  must be successful as the rendering context allows to restrict the
    ///  number of save states, for example, or to use a `TBLContextCookie` to
    ///  guard state save and restoration.
    /// </remarks>
    /// <seealso cref="Save"/>
    /// <seealso cref="Restore"/>
    /// <seealso cref="TBLContextCookie"/>
    property SavedStateCount: Integer read GetSavedStateCount;

    /// <summary>
    ///  Meta transformation matrix.
    ///
    ///  Meta matrix is a core transformation matrix that is normally not
    ///  changed by transformations applied to the context. Instead it acts as a
    ///  secondary matrix used to create the final transformation matrix from
    ///  meta and user matrices.
    ///
    ///  Meta matrix can be used to scale the whole context for HI-DPI rendering
    ///  or to change the orientation of the image being rendered, however, the
    ///  number of use-cases is unlimited.
    ///
    ///  To change the meta-matrix you must first change user-matrix and then
    ///  call `UserToMeta`, which would update meta-matrix and clear
    ///  user-matrix.
    /// </summary>
    /// <seealso cref="UserTransform"/>
    /// <seealso cref="UserToMeta"/>
    property MetaTransform: TBLMatrix2D read GetMetaTransform;

    /// <summary>
    ///  User transformation matrix.
    ///
    ///  User matrix contains all transformations that happened to the rendering
    ///  context unless the context was restored or `UserToMeta` was called.
    /// </summary>
    /// <remarks>
    ///  Setting this property only assigns the user transformation matrix,
    ///  which means that the meta transformation matrix is kept as is. This
    ///  means that the final transformation matrix will be recalculated based
    ///  on the given `transform`.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="UserToMeta"/>
    property UserTransform: TBLMatrix2D read GetUserTransform write SetUserTransform;

    /// <summary>
    ///  Final transformation matrix.
    ///
    ///  Final transformation matrix is a combination of meta and user
    ///  transformation matrices. It's the final transformation that the
    ///  rendering context applies to all input coordinates.
    /// </summary>
    property FinalTransform: TBLMatrix2D read GetFinalTransform;

    /// <summary>
    ///  Rendering context hints.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property Hints: TBLContextHints read GetHints write SetHints;

    /// <summary>
    ///  The rendering quality hint.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property RenderingQuality: TBLRenderingQuality read GetRenderingQuality write SetRenderingQuality;

    /// <summary>
    ///  The gradient quality hint.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property GradientQuality: TBLGradientQuality read GetGradientQuality write SetGradientQuality;

    /// <summary>
    ///  The pattern quality hint.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property PatternQuality: TBLPatternQuality read GetPatternQuality write SetPatternQuality;

    /// <summary>
    ///  Approximation options.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property ApproximationOptions: TBLApproximationOptions read GetApproximationOptions write SetApproximationOptions;

    /// <summary>
    ///  Flatten mode (how curves are flattened).
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property FlattenMode: TBLFlattenMode read GetFlattenMode write SetFlattenMode;

    /// <summary>
    ///  Tolerance used for curve flattening.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property FlattenTolerance: Double read GetFlattenTolerance write SetFlattenTolerance;

    /// <summary>
    ///  Composition operator.
    ///
    ///  The composition operator is part of the rendering context state and is
    ///  subject to `Save` and `Restore`. The default composition operator is
    ///  `TBLCompOp.SrcOver`, which would be returned immediately after the
    ///  rendering context is created.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="Save"/>
    /// <seealso cref="Restore"/>
    property CompOp: TBLCompOp read GetCompOp write SetCompOp;

    /// <summary>
    ///  The global alpha value.
    ///
    ///  The global alpha value is part of the rendering context state and is
    ///  subject to `Save` and `Restore`. The default value is `1.0`, which
    ///  would be returned immediately after the rendering context is created.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="Save"/>
    /// <seealso cref="Restore"/>
    property GlobalAlpha: Double read GetGlobalAlpha write SetGlobalAlpha;

    /// <summary>
    ///  The current style type associated with the given style `ASlot`.
    /// </summary>
    property StyleType[const ASlot: TBLContextStyleSlot]: TBLObjectType read GetStyleType;

    /// <summary>
    ///  The styles associated with the given style `ASlot`.
    /// </summary>
    /// <remarks>
    ///  When reading this property, the original style passed to the rendering
    ///  context is returned, with its original transformation matrix if it's
    ///  not a solid color. Consider using `TransformedStyle` if you want to get
    ///  a style with the transformation matrix that the rendering context
    ///  actually uses to render it.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    /// <seealso cref="TransformedStyle"/>
    property Style[const ASlot: TBLContextStyleSlot]: TBLVar read GetStyle write SetStyle;

    /// <summary>
    ///  The styles associated with the given style `ASlot`.
    ///
    ///  The retrieved style uses a transformation matrix that is a combination
    ///  of style transformation matrix and the rendering context matrix at a
    ///  time the style was set.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property TransformedStyle[const ASlot: TBLContextStyleSlot]: TBLVar read GetTransformedStyle;

    /// <summary>
    ///  Fill or stroke alpha value associated with the given style `ASlot`.
    ///
    ///  Behaves like `FillAlpha` or `StrokeAlpha` depending on style.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property StyleAlpha[const ASlot: TBLContextStyleSlot]: Double read GetStyleAlpha write SetStyleAlpha;

    /// <summary>
    ///  The current fill style type.
    /// </summary>
    property FillStyleType: TBLObjectType read GetFillStyleType;

    /// <summary>
    ///  Fill style.
    /// </summary>
    /// <remarks>
    ///  When reading this property, the original style passed to the rendering
    ///  context is returned, with its original transformation matrix if it's
    ///  not a solid color. Consider using `TransformedFillStyle` if you want to
    ///  get a style with the transformation matrix that the rendering context
    ///  actually uses to render it.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property FillStyle: TBLVar read GetFillStyle write SetFillStyle;

    /// <summary>
    ///  Transformed fill style.
    ///
    ///  The retrieved style uses a transformation matrix that is a combination
    ///  of style transformation matrix and the rendering context matrix at a
    ///  time the style was set.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property TransformedFillStyle: TBLVar read GetTransformedFillStyle;

    /// <summary>
    ///  Fill alpha value.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property FillAlpha: Double read GetFillAlpha write SetFillAlpha;

    /// <summary>
    ///  Returns fill rule.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property FillRule: TBLFillRule read GetFillRule write SetFillRule;

    /// <summary>
    ///  Returns the current stroke style type.
    /// </summary>
    property StrokeStyleType: TBLObjectType read GetStrokeStyleType;

    /// <summary>
    ///  Stroke style.
    /// </summary>
    /// <remarks>
    ///  When reading this property, the original style passed to the rendering
    ///  context is returned, with its original transformation matrix if it's
    ///  not a solid color. Consider using `TransformedStrokeStyle` if you want
    ///  to get a style with the transformation matrix that the rendering
    ///  context actually uses to render it.
    /// </remarks>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property StrokeStyle: TBLVar read GetStrokeStyle write SetStrokeStyle;

    /// <summary>
    ///  Transformed stroke style.
    ///
    ///  The retrieved style uses a transformation matrix that is a combination
    ///  of style transformation matrix and the rendering context matrix at a
    ///  time the style was set.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property TransformedStrokeStyle: TBLVar read GetTransformedStrokeStyle;

    /// <summary>
    ///  Stroke width.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property StrokeWidth: Double read GetStrokeWidth write SetStrokeWidth;

    /// <summary>
    ///  Stroke miter-limit.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property StrokeMiterLimit: Double read GetStrokeMiterLimit write SetStrokeMiterLimit;

    /// <summary>
    ///  Stroke join.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property StrokeJoin: TBLStrokeJoin read GetStrokeJoin write SetStrokeJoin;

    /// <summary>
    ///  Stroke start-cap.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property StrokeStartCap: TBLStrokeCap read GetStrokeStartCap write SetStrokeStartCap;

    /// <summary>
    ///  Stroke end-cap.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property StrokeEndCap: TBLStrokeCap read GetStrokeEndCap write SetStrokeEndCap;

    /// <summary>
    ///  Stroke transform order.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property StrokeTransformOrder: TBLStrokeTransformOrder read GetStrokeTransformOrder write SetStrokeTransformOrder;

    /// <summary>
    ///  Returns stroke dash-offset.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property StrokeDashOffset: Double read GetStrokeDashOffset write SetStrokeDashOffset;

    /// <summary>
    ///  Stroke dash-array.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property StrokeDashArray: TBLArray<Double> read GetStrokeDashArray write SetStrokeDashArray;

    /// <summary>
    ///  Stroke options.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property StrokeOptions: TBLStrokeOptions read GetStrokeOptions write SetStrokeOptions;

    /// <summary>
    ///  Stroke alpha value.
    /// </summary>
    /// <exception name="EBlend2DError">Raised on failure.</exception>
    property StrokeAlpha: Double read GetStrokeAlpha write SetStrokeAlpha;
  end;
{$ENDREGION 'Rendering'}

{$REGION 'Runtime'}
type
  /// <summary>
  ///  Blend2D runtime limits.
  /// </summary>
  /// <remarks>
  ///  These constants are used across Blend2D, but they are not designed to be
  ///  ABI stable. New versions of Blend2D can increase certain limits without
  ///  notice. Use `TBLRuntimeBuildInfo` to query the limits dynamically.
  /// </remarks>
  /// <seealso cref="TBLRuntimeBuildInfo"/>
  TBLRuntimeLimits = record // static
  public const
    /// <summary>
    ///  Maximum width and height of an image.
    /// </summary>
    MaxImageSize = 65535;

    /// <summary>
    ///  Maximum number of threads for asynchronous operations (including rendering).
    /// </summary>
    MaxThreadCount = 32;
  end;

type
  /// <summary>
  ///  Blend2D runtime build type.
  /// </summary>
  TBLRuntimeBuildType = (
    /// <summary>
    ///  Describes a Blend2D debug build.
    /// </summary>
    Debug,

    /// <summary>
    ///  Describes a Blend2D release build.
    /// </summary>
    Release);

type
  /// <summary>
  ///  CPU architecture that can be queried by `TBLRuntime.QuerySystemInfo`.
  /// </summary>
  /// <seealso cref="TBLRuntime.QuerySystemInfo"/>
  TBLRuntimeCpuArch = (
    /// <summary>
    ///  Unknown architecture.
    /// </summary>
    Unknown,

    /// <summary>
    ///  32-bit or 64-bit X86 architecture.
    /// </summary>
    X86,

    /// <summary>
    ///  32-bit or 64-bit ARM architecture.
    /// </summary>
    Arm,

    /// <summary>
    ///  32-bit or 64-bit MIPS architecture.
    /// </summary>
    Mips);

type
  /// <summary>
  ///  CPU features Blend2D supports.
  /// </summary>
  TBLRuntimeCpuFeature = (
    X86Sse2 = 0,
    X86Sse3 = 1,
    X86Ssse3 = 2,
    X86Sse4_1 = 3,
    X86Sse4_2 = 4,
    X86Avx = 5,
    X86Avx2 = 6,
    X86Avx512 = 7,

    ArmAsimd = 0,
    ArmCrc32 = 1,
    ArmPmull = 2,

    _Reserved = 31);

  /// <summary>
  ///  CPU features Blend2D supports.
  /// </summary>
  TBLRuntimeCpuFeatures = set of TBLRuntimeCpuFeature;

type
  /// <summary>
  ///  Runtime cleanup flags that can be used through `TBLRuntime.Cleanup`.
  /// </summary>
  /// <seealso cref="TBLRuntime.Cleanup"/>
  TBLRuntimeCleanupFlag = (
    /// <summary>
    ///  Cleanup object memory pool.
    /// </summary>
    ObjectPool = 0,

    /// <summary>
    ///  Cleanup zeroed memory pool.
    /// </summary>
    ZeroedPool = 1,

    /// <summary>
    ///  Cleanup thread pool (would join unused threads).
    /// </summary>
    ThreadPool = 4);

  /// <summary>
  ///  Runtime cleanup flags that can be used through `TBLRuntime.Cleanup`.
  /// </summary>
  /// <seealso cref="TBLRuntime.Cleanup"/>
  TBLRuntimeCleanupFlags = set of TBLRuntimeCleanupFlag;

  /// <summary>
  ///  Adds functionality to `TBLFileOpenFlags`.
  /// </summary>
  PTBLRuntimeCleanupFlagsHelper = record helper for TBLRuntimeCleanupFlags
  public const
    /// <summary>
    ///  No flags.
    /// </summary>
    None = [];

    /// <summary>
    ///  Cleanup everything.
    /// </summary>
    Everything = [TBLRuntimeCleanupFlag.ObjectPool,
                  TBLRuntimeCleanupFlag.ZeroedPool,
                  TBLRuntimeCleanupFlag.ThreadPool];
  end;

type
  /// <summary>
  ///  Blend2D build information.
  /// </summary>
  TBLRuntimeBuildInfo = record
  {$REGION 'Internal Declarations'}
  private
    FMajorVersion: Int32;
    FMinorVersion: Int32;
    FPatchVersion: Int32;
    FBuildType: TBLRuntimeBuildType;
    FBaselineCpuFeatures: TBLRuntimeCpuFeatures;
    FSupportedCpuFeatures: TBLRuntimeCpuFeatures;
    FMaxImageSize: Int32;
    FMaxThreadCount: Int32;
    {$HINTS OFF}
    FReserved: array [0..1] of UInt32;
    {$HINTS ON}
    FCompilerInfo: array [0..31] of UTF8Char;
    function GetCompilerInfo: String; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    procedure Reset; inline;

    /// <summary>
    ///  Major version number.
    /// </summary>
    property MajorVersion: Integer read FMajorVersion;

    /// <summary>
    ///  Minor version number.
    /// </summary>
    property MinorVersion: Integer read FMinorVersion;

    /// <summary>
    ///  Patch version number.
    /// </summary>
    property PatchVersion: Integer read FPatchVersion;

    /// <summary>
    ///  Blend2D build type.
    /// </summary>
    property BuildType: TBLRuntimeBuildType read FBuildType;

    /// <summary>
    ///  Baseline CPU features.
    ///
    ///  These features describe CPU features that were detected at compile-time.
    ///  Baseline features are used to compile all source files so they
    ///  represent the minimum feature-set the target CPU must support to run
    ///  Blend2D.
    ///
    ///  Official Blend2D builds set baseline at SSE2 on X86 target and NEON on
    ///  ARM target. Custom builds can set use a different baseline, which can
    ///  be read through `TBLRuntimeBuildInfo`.
    /// </summary>
    property BaselineCpuFeatures: TBLRuntimeCpuFeatures read FBaselineCpuFeatures;

    /// <summary>
    ///  Supported CPU features.
    ///
    ///  These features do not represent the features that the host CPU must
    ///  support, instead, they represent all features that Blend2D can take
    ///  advantage of in C++ code that uses instruction intrinsics. For example
    ///  if AVX2 is part of `SupportedCpuFeatures` it means that Blend2D can
    ///  take advantage of it if there is a specialized code-path.
    /// </summary>
    property SupportedCpuFeatures: TBLRuntimeCpuFeatures read FSupportedCpuFeatures;

    /// <summary>
    ///  Maximum size of an image (both width and height).
    /// </summary>
    property MaxImageSize: Integer read FMaxImageSize;

    /// <summary>
    ///  Maximum number of threads for asynchronous operations, including rendering.
    /// </summary>
    property MaxThreadCount: Integer read FMaxThreadCount;

    /// <summary>
    ///  Identification of the C++ compiler used to build Blend2D.
    /// </summary>
    property CompilerInfo: String read GetCompilerInfo;
  end;
  PBLRuntimeBuildInfo = ^TBLRuntimeBuildInfo;

type
  /// <summary>
  ///  System information queried by the runtime.
  /// </summary>
  TBLRuntimeSystemInfo = record
  {$REGION 'Internal Declarations'}
  private
    FCpuArch: TBLRuntimeCpuArch;
    FCpuFeatures: TBLRuntimeCpuFeatures;
    FCoreCount: Int32;
    FThreadCount: Int32;
    FThreadStackSize: Int32;
    {$HINTS OFF}
    FRemoved: Int32;
    {$HINTS ON}
    FAllocationGranularity: Int32;
    {$HINTS OFF}
    FReserved: array [0..4] of UInt32;
    {$HINTS ON}
    FCpuVendor: array [0..15] of UTF8Char;
    FCpuBrand: array [0..63] of UTF8Char;
    function GetCpuVendor: String; inline;
    function GetCpuBrand: String; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    procedure Reset; inline;

    /// <summary>
    ///  Host CPU architecture.
    /// </summary>
    property CpuArch: TBLRuntimeCpuArch read FCpuArch;

    /// <summary>
    ///  Host CPU features.
    /// </summary>
    property CpuFeatures: TBLRuntimeCpuFeatures read FCpuFeatures;

    /// <summary>
    ///  Number of cores of the host CPU/CPUs.
    /// </summary>
    property CoreCount: Integer read FCoreCount;

    /// <summary>
    ///  Number of threads of the host CPU/CPUs.
    /// </summary>
    property ThreadCount: Integer read FThreadCount;

    /// <summary>
    ///  Minimum stack size of a worker thread used by Blend2D.
    /// </summary>
    property ThreadStackSize: Integer read FThreadStackSize;

    /// <summary>
    ///  Allocation granularity of virtual memory (includes thread's stack).
    /// </summary>
    property AllocationGranularity: Integer read FAllocationGranularity;

    /// <summary>
    ///  Host CPU vendor string such 'AMD', 'APPLE', 'INTEL', 'SAMSUNG', etc...
    /// </summary>
    property CpuVendor: String read GetCpuVendor;

    /// <summary>
    ///  Host CPU brand string or empty string if not detected properly.
    /// </summary>
    property CpuBrand: String read GetCpuBrand;
  end;
  PBLRuntimeSystemInfo = ^TBLRuntimeSystemInfo;

type
  /// <summary>
  ///  Provides information about resources allocated by Blend2D.
  /// </summary>
  TBLRuntimeResourceInfo = record
  {$REGION 'Internal Declarations'}
  private
    FVMUsed: Size_T;
    FVMReserved: Size_T;
    FVMOverhead: Size_T;
    FVMBlockCount: Size_T;
    FZMUsed: Size_T;
    FZMReserved: Size_T;
    FZMOverhead: Size_T;
    FZMBlockCount: Size_T;
    FDynamicPipelineCount: Size_T;
    {$HINTS OFF}
    FReserved: array [0..6] of Size_T;
    {$HINTS ON}
    function GetVMUsed: NativeInt; inline;
    function GetVMReserved: NativeInt; inline;
    function GetVMOverhead: NativeInt; inline;
    function GetVMBlockCount: NativeInt; inline;
    function GetZMUsed: NativeInt; inline;
    function GetZMReserved: NativeInt; inline;
    function GetZMOverhead: NativeInt; inline;
    function GetZMBlockCount: NativeInt; inline;
    function GetDynamicPipelineCount: NativeInt; inline;
  {$ENDREGION 'Internal Declarations'}
  public
    procedure Reset; inline;

    /// <summary>
    ///  Virtual memory used at this time.
    /// </summary>
    property VMUsed: NativeInt read GetVMUsed;

    /// <summary>
    ///  Virtual memory reserved (allocated internally).
    /// </summary>
    property VMReserved: NativeInt read GetVMReserved;

    /// <summary>
    ///  Overhead required to manage virtual memory allocations.
    /// </summary>
    property VMOverhead: NativeInt read GetVMOverhead;

    /// <summary>
    ///  Number of blocks of virtual memory allocated.
    /// </summary>
    property VMBlockCount: NativeInt read GetVMBlockCount;

    /// <summary>
    ///  Zeroed memory used at this time.
    /// </summary>
    property ZMUsed: NativeInt read GetZMUsed;

    /// <summary>
    ///  Zeroed memory reserved (allocated internally).
    /// </summary>
    property ZMReserved: NativeInt read GetZMReserved;

    /// <summary>
    ///  Overhead required to manage zeroed memory allocations.
    /// </summary>
    property ZMOverhead: NativeInt read GetZMOverhead;

    /// <summary>
    ///  Number of blocks of zeroed memory allocated.
    /// </summary>
    property ZMBlockCount: NativeInt read GetZMBlockCount;

    /// <summary>
    ///  Count of dynamic pipelines created and cached.
    /// </summary>
    property DynamicPipelineCount: NativeInt read GetDynamicPipelineCount;
  end;
  PBLRuntimeResourceInfo = ^TBLRuntimeResourceInfo;

type
  /// <summary>
  ///  Interface to access Blend2D runtime.
  /// </summary>
  TBLRuntime = record // static
  public
    class procedure Cleanup(const ACleanupFlags: TBLRuntimeCleanupFlags); inline; static;
    class function QueryBuildInfo: TBLRuntimeBuildInfo; inline; static;
    class function QuerySystemInfo: TBLRuntimeSystemInfo; inline; static;
    class function QueryResourceInfo: TBLRuntimeResourceInfo; inline; static;
    class procedure Message(const AMsg: String); overload; inline; static;
    class procedure Message(const AMsg: String; const AArgs: array of const); overload; static;
  end;

{$ENDREGION 'Runtime'}

{$REGION 'Miscellaneous'}
type
  /// <summary>
  ///  Simple pseudo random number generator based on `XORSHIFT+`, which has
  ///  64-bit seed, 128 bits of state, and full period `2^128 - 1`.
  ///
  ///  Based on a paper by Sebastiano Vigna:
  ///  <see href="http://vigna.di.unimi.it/ftp/papers/xorshiftplus.pdf">XORSHIFT+</see>.
  /// </summary>
  TBLRandom = record
  {$REGION 'Internal Declarations'}
  private
    FData: array [0..1] of UInt64;
  {$ENDREGION 'Internal Declarations'}
  public
    class function Create: TBLRandom; overload; inline; static;
    constructor Create(const ASeed: UInt64); overload;

    class operator Equal(const ALeft, ARight: TBLRandom): Boolean; inline; static;
    class operator NotEqual(const ALeft, ARight: TBLRandom): Boolean; inline; static;

    /// <summary>
    ///  Tests whether the random number generator is equivalent to `Ather`.
    /// </summary>
    /// <remarks>
    ///  It would return True only when its internal state matches `AOther`'s
    ///  internal state.
    /// </remarks>
    function Equals(const AOther: TBLRandom): Boolean; inline;

    /// <summary>
    ///  Resets the random number generator to the given `ASeed`.
    /// </summary>
    procedure Reset(const ASeed: UInt64 = 0);

    /// <summary>
    ///  Returns the next pseudo-random `UInt64` value and advances PRNG state.
    /// </summary>
    function NextUInt64: UInt64; inline;

    /// <summary>
    ///  Returns the next pseudo-random `UInt32` value and advances PRNG state.
    /// </summary>
    function NextUInt32: UInt32; inline;

    /// <summary>
    ///  Returns the next pseudo-random `Double` precision floating point in
    ///  [0..1) range and advances PRNG state.
    /// </summary>
    function NextDouble: Double; inline;
  end;
{$ENDREGION 'Miscellaneous'}

{$REGION 'Internal'}
type
  _TBLGenericUtils<T> = record // static
  public type
    {$POINTERMATH ON}
    /// <summary>
    ///  A pointer to type `T`.
    /// </summary>
    P = ^T;
    {$POINTERMATH OFF}
  public
    class procedure CopyToUnitialized(ADst: P; const ASrc: array of T;
      const AArrayType: TBLObjectType); static;
    class function AreEqual(const ALeft, ARight: T): Boolean; static;
  end;

var
  _GErrorHandler: TBLErrorHandler = nil;
  _GErrorUserData: Pointer = nil;

{$INCLUDE 'Blend2D.Api.inc'}
{$ENDREGION 'Internal'}

implementation

{$OVERFLOWCHECKS OFF}
{$RANGECHECKS OFF}

uses
  System.TypInfo,
  System.DateUtils;

{$REGION 'Error Handling'}

{ _TBLResultHelper }

function _TBLResultHelper.ToString: String;
const
  ERROR_STRINGS: array [Ord(TBLResult.OutOfMemory)..Ord(High(TBLResult))] of String = (
    'Out of memory.',
    'Invalid value/argument.',
    'Invalid state.',
    'Invalid handle or file.',
    'Invalid conversion.',
    'Value too large.',
    'Object not initialized.',
    'Not implemented.',
    'Operation not permitted.',
    'IO error.',
    'Device or resource busy.',
    'Operation interrupted.',
    'Try again.',
    'Timed out.',
    'Broken pipe.',
    'File is not seekable.',
    'Too many levels of symlinks.',
    'File is too large.',
    'File/directory already exists.',
    'Access denied.',
    'Media changed.',
    'The file/FS is read-only.',
    'Device doesn''t exist.',
    'Not found, no entry (fs).',
    'No media in drive/device.',
    'No more data / end of file.',
    'No more files.',
    'No space left on device.',
    'Directory is not empty.',
    'Not a file.',
    'Not a directory.',
    'Not same device.',
    'Not a block device.',
    'File/path name is invalid.',
    'File/path name is too long.',
    'Too many open files.',
    'Too many open files by OS.',
    'Too many symbolic links on FS.',
    'Too many threads.',
    'Thread pool is exhausted and couldn''t acquire the requested thread count.',
    'File is empty (not specific to any OS error).',
    'File open failed.',
    'Not a root device/directory.',
    'Unknown system error that failed to translate to Blend2D result code.',
    'Invalid data alignment.',
    'Invalid data signature or header.',
    'Invalid or corrupted data.',
    'Invalid string (invalid data of either UTF8, UTF16, or UTF32).',
    'Invalid key or property.',
    'Truncated data (more data required than memory/stream provides).',
    'Input data too large to be processed.',
    'Decompression failed due to invalid data (RLE, Huffman, etc).',
    'Invalid geometry (invalid path data or shape).',
    'Returned when there is no matching vertex in path data.',
    'Invalid create flags.',
    'No matching cookie.',
    'No states to restore.',
    'Cannot save state as the number of saved states reached the limit.',
    'The size of the image is too large.',
    'Image codec for a required format doesn''t exist.',
    'Unknown or invalid file format that cannot be read.',
    'Image codec doesn''t support reading the file format.',
    'Image codec doesn''t support writing the file format.',
    'Multiple IHDR chunks are not allowed (PNG).',
    'Invalid IDAT chunk (PNG).',
    'Invalid IEND chunk (PNG).',
    'Invalid PLTE chunk (PNG).',
    'Invalid tRNS chunk (PNG).',
    'Invalid filter type (PNG).',
    'Unsupported feature (JPEG).',
    'Invalid SOS marker or header (JPEG).',
    'Invalid SOF marker (JPEG).',
    'Multiple SOF markers (JPEG).',
    'Unsupported SOF marker (JPEG).',
    'Font doesn''t have any data as it''s not initialized.',
    'Font or font-face was not matched (TBLFontManager).',
    'Font has no character to glyph mapping data.',
    'Font has missing an important table.',
    'Font feature is not available.',
    'Font has an invalid CFF data.',
    'Font program terminated because the execution reached the limit.',
    'Glyph substitution requires too much space and was terminated.',
    'Invalid glyph identifier.');
begin
  if (Self = TBLResult.Success) then
    Result := 'Success'
  else if (Ord(Self) >= Low(ERROR_STRINGS)) and (Ord(Self) <= High(ERROR_STRINGS)) then
    Result := ERROR_STRINGS[Ord(Self)]
  else
    Result := Format('Unknown error (%d)', [Ord(Self)]);
end;

{ EBlend2DError }

constructor EBlend2DError.Create(const AResult: TBLResult);
begin
  inherited Create(AResult.ToString);
  FResult := AResult;
end;

var
  GLastError: TBLResult = TBLResult.Success;

procedure BLSetErrorHandler(const AHandler: TBLErrorHandler;
  const AUserData: Pointer);
begin
  _GErrorHandler := AHandler;
  _GErrorUserData := AUserData;
end;

procedure ExceptionErrorHandler(const AResult: TBLResult;
  const AUserData: Pointer);
begin
  raise EBlend2DError.Create(AResult);
end;

procedure BLSetExceptionErrorHandler;
begin
  _GErrorHandler := ExceptionErrorHandler;
  _GErrorUserData := nil;
end;

procedure GetLastErrorHandler(const AResult: TBLResult;
  const AUserData: Pointer);
begin
  GLastError := AResult;
end;

function BLGetLastError: TBLResult;
begin
  Result := GLastError;
  GLastError := TBLResult.Success;
end;

procedure BLSetGetLastErrorHandler;
begin
  _GErrorHandler := GetLastErrorHandler;
  _GErrorUserData := nil;
end;

procedure _BLCheck(const AResult: Integer);
begin
  if (AResult <> 0) and Assigned(_GErrorHandler) then
    _GErrorHandler(TBLResult(AResult), _GErrorUserData);
end;

procedure _BLCheck(const AResult: TBLResult);
begin
  if (AResult <> TBLResult.Success) and Assigned(_GErrorHandler) then
    _GErrorHandler(AResult, _GErrorUserData);
end;

{$ENDREGION 'Error Handling'}

{$REGION 'Globals'}

{ _TBLTagHelper }

constructor _TBLTagHelper.Create(const AA, AB, AC, AD: Byte);
begin
  Self := (UInt32(AA) shl 24) or (AB shl 16) or (AC shl 8) or AD;
end;

constructor _TBLTagHelper.Create(const AA, AB, AC, AD: AnsiChar);
begin
  Self := (UInt32(AA) shl 24) or (Ord(AB) shl 16) or (Ord(AC) shl 8) or Ord(AD);
end;

constructor _TBLTagHelper.Create(const AFourCC: AnsiString);
begin
  Assert(Length(AFourCC) >= 4);
  Self := (UInt32(AFourCC[Low(AnsiString)]) shl 24)
       or (Ord(AFourCC[Low(AnsiString) + 1]) shl 16)
       or (Ord(AFourCC[Low(AnsiString) + 2]) shl 16)
       or  Ord(AFourCC[Low(AnsiString) + 3]);
end;

class operator _TBLTagHelper.Implicit(const AFourCC: AnsiString): TBLTag;
begin
  Assert(Length(AFourCC) >= 4);
  Result := (UInt32(AFourCC[Low(AnsiString)]) shl 24)
         or (Ord(AFourCC[Low(AnsiString) + 1]) shl 16)
         or (Ord(AFourCC[Low(AnsiString) + 2]) shl 16)
         or  Ord(AFourCC[Low(AnsiString) + 3]);
end;

{$ENDREGION 'Globals'}

{$REGION 'Internal'}

{ TBLObjectCore }

function TBLObjectCore.AField: UInt32;
begin
  Result := (FInfo shr A_SHIFT) and (A_MASK shr A_SHIFT);
end;

{function TBLObjectCore.BField: UInt32;
begin
  Result := (FInfo shr B_SHIFT) and (B_MASK shr B_SHIFT);
end;

function TBLObjectCore.CField: UInt32;
begin
  Result := (FInfo shr C_SHIFT) and (C_MASK shr C_SHIFT);
end;}

function TBLObjectCore.NeedsCleanup: Boolean;
begin
  Result := (FInfo >= MDR_FLAGS);
end;

{function TBLObjectCore.PField: UInt32;
begin
  Result := (FInfo shr P_SHIFT) and (P_MASK shr P_SHIFT);
end;

function TBLObjectCore.QField: UInt32;
begin
  Result := (FInfo shr Q_SHIFT) and (Q_MASK shr Q_SHIFT);
end;}

procedure TBLObjectCore.Swap(var AOther: TBLObjectCore);
begin
  var Temp := AOther;
  AOther := Self;
  Self := Temp;
end;
{$ENDREGION 'Internal'}

{$REGION 'File System'}

{ TBLFileInfo }

function TBLFileInfo.GetHasGroupR: Boolean;
begin
  Result := (TBLFileInfoFlag.GroupR in FFlags);
end;

function TBLFileInfo.GetHasGroupW: Boolean;
begin
  Result := (TBLFileInfoFlag.GroupW in FFlags);
end;

function TBLFileInfo.GetHasGroupX: Boolean;
begin
  Result := (TBLFileInfoFlag.GroupX in FFlags);
end;

function TBLFileInfo.GetHasOtherR: Boolean;
begin
  Result := (TBLFileInfoFlag.OtherR in FFlags);
end;

function TBLFileInfo.GetHasOtherW: Boolean;
begin
  Result := (TBLFileInfoFlag.OtherW in FFlags);
end;

function TBLFileInfo.GetHasOtherX: Boolean;
begin
  Result := (TBLFileInfoFlag.OtherX in FFlags);
end;

function TBLFileInfo.GetHasOwnerR: Boolean;
begin
  Result := (TBLFileInfoFlag.OwnerR in FFlags);
end;

function TBLFileInfo.GetHasOwnerW: Boolean;
begin
  Result := (TBLFileInfoFlag.OwnerW in FFlags);
end;

function TBLFileInfo.GetHasOwnerX: Boolean;
begin
  Result := (TBLFileInfoFlag.OwnerX in FFlags);
end;

function TBLFileInfo.GetHasSetGid: Boolean;
begin
  Result := (TBLFileInfoFlag.SetGid in FFlags);
end;

function TBLFileInfo.GetHasSetUid: Boolean;
begin
  Result := (TBLFileInfoFlag.SetUid in FFlags);
end;

function TBLFileInfo.GetIsArchive: Boolean;
begin
  Result := (TBLFileInfoFlag.Archive in FFlags);
end;

function TBLFileInfo.GetIsBlockDevice: Boolean;
begin
  Result := (TBLFileInfoFlag.BlockDevice in FFlags);
end;

function TBLFileInfo.GetIsCharDevice: Boolean;
begin
  Result := (TBLFileInfoFlag.CharDevice in FFlags);
end;

function TBLFileInfo.GetIsDirectory: Boolean;
begin
  Result := (TBLFileInfoFlag.Directory in FFlags);
end;

function TBLFileInfo.GetIsExecutable: Boolean;
begin
  Result := (TBLFileInfoFlag.Executable in FFlags);
end;

function TBLFileInfo.GetIsFifo: Boolean;
begin
  Result := (TBLFileInfoFlag.Fifo in FFlags);
end;

function TBLFileInfo.GetIsHidden: Boolean;
begin
  Result := (TBLFileInfoFlag.Hidden in FFlags);
end;

function TBLFileInfo.GetIsRegular: Boolean;
begin
  Result := (TBLFileInfoFlag.Regular in FFlags);
end;

function TBLFileInfo.GetIsSocket: Boolean;
begin
  Result := (TBLFileInfoFlag.Socket in FFlags);
end;

function TBLFileInfo.GetIsSymLink: Boolean;
begin
  Result := (TBLFileInfoFlag.SymLink in FFlags);
end;

function TBLFileInfo.GetIsSystem: Boolean;
begin
  Result := (TBLFileInfoFlag.System in FFlags);
end;

function TBLFileInfo.GetIsValid: Boolean;
begin
  Result := (TBLFileInfoFlag.Valid in FFlags);
end;

function TBLFileInfo.GetModifiedTime: TDateTime;
begin
  Result := UnixToDateTime(FModifiedTime);
end;

function TBLFileInfo.HasFlag(const AFlag: TBLFileInfoFlag): Boolean;
begin
  Result := (AFlag in FFlags);
end;

{ TBLFile }

class operator TBLFile.Assign(var ADest: TBLFile; const [ref] ASrc: TBLFile);
begin
  raise EBlend2DError.Create(TBLResult.NotPermitted);
end;

procedure TBLFile.Close;
begin
  _BLCheck(_blFileClose(@Self));
end;

constructor TBLFile.Create(const AHandle: THandle);
begin
  FHandle := AHandle;
end;

class operator TBLFile.Equal(const ALeft: TBLFile;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.FHandle = THandle.MaxValue) then
    Result := (ARight = nil)
  else
    Result := (ARight <> nil);
end;

class operator TBLFile.Finalize(var ADest: TBLFile);
begin
  _BLCheck(_blFileReset(@ADest));
end;

function TBLFile.GetInfo: TBLFileInfo;
begin
  _BLCheck(_blFileGetInfo(@Self, @Result));
end;

function TBLFile.GetIsOpen: Boolean;
begin
  Result := (FHandle <> THandle.MaxValue);
end;

function TBLFile.GetSize: Int64;
begin
  _BLCheck(_blFileGetSize(@Self, @Result));
end;

class operator TBLFile.Initialize(out ADest: TBLFile);
begin
  ADest.FHandle := THandle.MaxValue;
end;

class operator TBLFile.NotEqual(const ALeft: TBLFile;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.FHandle = THandle.MaxValue) then
    Result := (ARight <> nil)
  else
    Result := (ARight = nil);
end;

procedure TBLFile.Open(const AFilename: String;
  const AOpenFlags: TBLFileOpenFlags);
begin
  _BLCheck(_blFileOpen(@Self, PUTF8Char(UTF8String(AFilename)), Cardinal(AOpenFlags)));
end;

function TBLFile.Read(var ABuffer; const ACount: Int64): Int64;
begin
  var BytesRead: Size_T;
  _BLCheck(_blFileRead(@Self, @ABuffer, ACount, @BytesRead));
  Result := BytesRead;
end;

function TBLFile.Seek(const AOffset: Int64; const ASeekType: TBLFileSeekType): Int64;
begin
  _BLCheck(_blFileSeek(@Self, AOffset, Ord(ASeekType), @Result));
end;

procedure TBLFile.Truncate(const AMaxSize: Int64);
begin
  _BLCheck(_blFileTruncate(@Self, AMaxSize));
end;

function TBLFile.Write(const ABuffer; const ACount: Int64): Int64;
begin
  var BytesWritten: Size_T;
  _BLCheck(_blFileWrite(@Self, @ABuffer, ACount, @BytesWritten));
  Result := BytesWritten;
end;

{ TBLFileSystem }

class function TBLFileSystem.FileInfo(const AFilename: String): TBLFileInfo;
begin
  _BLCheck(_blFileSystemGetInfo(PUTF8Char(UTF8String(AFilename)), @Result));
end;

class procedure TBLFileSystem.ReadFile(const AFilename: String;
  const ADst: TBLArray<Byte>; const AMaxSize: NativeInt;
  const AReadFlags: TBLFileReadFlags);
begin
  _BLCheck(_blFileSystemReadFile(PUTF8Char(UTF8String(AFilename)), @ADst, AMaxSize, Byte(AReadFlags)));
end;

class function TBLFileSystem.WriteFile(const AFilename: String; const AData;
  const ACount: NativeInt): NativeInt;
begin
  var BytesWritten: Size_T;
  _BLCheck(_blFileSystemWriteFile(PUTF8Char(UTF8String(AFilename)), @AData,
    ACount, @BytesWritten));
  Result := BytesWritten;
end;

class function TBLFileSystem.WriteFile(const AFilename: String;
  const AData: TBLArrayView<Byte>): NativeInt;
begin
  var BytesWritten: Size_T;
  _BLCheck(_blFileSystemWriteFile(PUTF8Char(UTF8String(AFilename)), AData.FData,
    AData.FCount, @BytesWritten));
  Result := BytesWritten;
end;

class function TBLFileSystem.WriteFile(const AFilename: String;
  const AData: TBLArray<Byte>): NativeInt;
begin
  var BytesWritten: Size_T;
  _BLCheck(_blFileSystemWriteFile(PUTF8Char(UTF8String(AFilename)), AData.Data,
    AData.Count, @BytesWritten));
  Result := BytesWritten;
end;

class function TBLFileSystem.WriteFile(const AFilename: String;
  const AData: TBytes): NativeInt;
begin
  var BytesWritten: Size_T;
  _BLCheck(_blFileSystemWriteFile(PUTF8Char(UTF8String(AFilename)), AData,
    Length(AData), @BytesWritten));
  Result := BytesWritten;
end;

{$ENDREGION 'File System'}

{$REGION 'Geometries'}

function BLPoint(const AX, AY: Double): TBLPoint; inline;
begin
  Result.Reset(AX, AY);
end;

function BLAbs(const AValue: TBLPoint): TBLPoint; overload; inline;
begin
  Result.Reset(Abs(AValue.X), Abs(AValue.Y));
end;

function BLMin(const AA, AB: TBLPoint): TBLPoint; overload; inline;
begin
  Result.Reset(Min(AA.X, AB.X), Min(AA.Y, AB.Y));
end;

function BLMin(const AA: TBLPoint; const AB: Double): TBLPoint; overload; inline;
begin
  Result.Reset(Min(AA.X, AB), Min(AA.Y, AB));
end;

function BLMin(const AA: Double; const AB: TBLPoint): TBLPoint; overload; inline;
begin
  Result.Reset(Min(AA, AB.X), Min(AA, AB.Y));
end;

function BLMax(const AA, AB: TBLPoint): TBLPoint; overload; inline;
begin
  Result.Reset(Max(AA.X, AB.X), Max(AA.Y, AB.Y));
end;

function BLMax(const AA: TBLPoint; const AB: Double): TBLPoint; overload; inline;
begin
  Result.Reset(Max(AA.X, AB), Max(AA.Y, AB));
end;

function BLMax(const AA: Double; const AB: TBLPoint): TBLPoint; overload; inline;
begin
  Result.Reset(Max(AA, AB.X), Max(AA, AB.Y));
end;

function BLClamp(const AA: TBLPoint; const AB, AC: Double): TBLPoint; inline;
begin
  Result := BLMin(AC, BLMax(AB, AA));
end;

function BLPointI(const AX, AY: Integer): TBLPointI; inline;
begin
  Result.Reset(AX, AY);
end;

function BLSize(const AW, AH: Double): TBLSize; inline;
begin
  Result.Reset(AW, AH);
end;

function BLAbs(const AValue: TBLSize): TBLSize; overload; inline;
begin
  Result.Reset(Abs(AValue.W), Abs(AValue.H));
end;

function BLMin(const AA, AB: TBLSize): TBLSize; overload; inline;
begin
  Result.Reset(Min(AA.W, AB.W), Min(AA.H, AB.H));
end;

function BLMax(const AA, AB: TBLSize): TBLSize; overload; inline;
begin
  Result.Reset(Max(AA.W, AB.W), Max(AA.H, AB.H));
end;

function BLSizeI(const AW, AH: Integer): TBLSizeI; inline;
begin
  Result.Reset(AW, AH);
end;

function BLBox(const AX0, AY0, AX1, AY1: Double): TBLBox; inline;
begin
  Result.Reset(AX0, AY0, AX1, AY1);
end;

function BLBoxI(const AX0, AY0, AX1, AY1: Integer): TBLBoxI; inline;
begin
  Result.Reset(AX0, AY0, AX1, AY1);
end;

function BLRect(const AX, AY, AW, AH: Double): TBLRect; inline;
begin
  Result.Reset(AX, AY, AW, AH);
end;

function BLRectI(const AX, AY, AW, AH: Integer): TBLRectI; inline;
begin
  Result.Reset(AX, AY, AW, AH);
end;

function BLRoundRect(const ARect: TBLRect; const AR: Double): TBLRoundRect; overload; inline;
begin
  Result.Reset(ARect, AR);
end;

function BLRoundRect(const ARect: TBLRect; const ARX, ARY: Double): TBLRoundRect; overload; inline;
begin
  Result.Reset(ARect, ARX, ARY);
end;

function BLRoundRect(const AX, AY, AW, AH, AR: Double): TBLRoundRect; overload; inline;
begin
  Result.Reset(AX, AY, AW, AH, AR);
end;

function BLRoundRect(const AX, AY, AW, AH, ARX, ARY: Double): TBLRoundRect; overload; inline;
begin
  Result.Reset(AX, AY, AW, AH, ARX, ARY);
end;

function BLCircle(const ACX, ACY, AR: Double): TBLCircle; overload; inline;
begin
  Result.Reset(ACX, ACY, AR);
end;

function BLEllipse(const ACX, ACY, AR: Double): TBLEllipse; overload; inline;
begin
  Result.Reset(ACX, ACY, AR);
end;

function BLEllipse(const ACX, ACY, ARX, ARY: Double): TBLEllipse; overload; inline;
begin
  Result.Reset(ACX, ACY, ARX, ARY);
end;

function BLArc(const ACX, ACY, ARX, ARY, AStart, ASweep: Double): TBLArc; inline;
begin
  Result.Reset(ACX, ACY, ARX, ARY, AStart, ASweep);
end;

function BLLine(const AX0, AY0, AX1, AY1: Double): TBLLine; inline;
begin
  Result.Reset(AX0, AY0, AX1, AY1);
end;

function BLLine(const AP0, AP1: TBLPoint): TBLLine; overload; inline;
begin
  Result.Reset(AP0, AP1);
end;

function BLTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double): TBLTriangle; inline;
begin
  Result.Reset(AX0, AY0, AX1, AY1, AX2, AY2);
end;

{ TBLPoint }

class operator TBLPoint.Add(const ALeft, ARight: TBLPoint): TBLPoint;
begin
  Result.Reset(ALeft.X + ARight.X, ALeft.Y + ARight.Y);
end;

class operator TBLPoint.Add(const ALeft: Double;
  const ARight: TBLPoint): TBLPoint;
begin
  Result.Reset(ALeft + ARight.X, ALeft + ARight.Y);
end;

class operator TBLPoint.Add(const ALeft: TBLPoint;
  const ARight: Double): TBLPoint;
begin
  Result.Reset(ALeft.X + ARight, ALeft.Y + ARight);
end;

constructor TBLPoint.Create(const AX, AY: Double);
begin
  X := AX;
  Y := AY;
end;

class operator TBLPoint.Divide(const ALeft: TBLPoint;
  const ARight: Double): TBLPoint;
begin
  Result.Reset(ALeft.X / ARight, ALeft.Y / ARight);
end;

class operator TBLPoint.Divide(const ALeft: Double;
  const ARight: TBLPoint): TBLPoint;
begin
  Result.Reset(ALeft / ARight.X, ALeft / ARight.Y);
end;

class operator TBLPoint.Divide(const ALeft, ARight: TBLPoint): TBLPoint;
begin
  Result.Reset(ALeft.X / ARight.X, ALeft.Y / ARight.Y);
end;

class operator TBLPoint.Equal(const ALeft, ARight: TBLPoint): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLPoint.Equals(const AOther: TBLPoint): Boolean;
begin
  Result := (X = AOther.X) and (Y = AOther.Y);
end;

class operator TBLPoint.Multiply(const ALeft, ARight: TBLPoint): TBLPoint;
begin
  Result.Reset(ALeft.X * ARight.X, ALeft.Y * ARight.Y);
end;

class operator TBLPoint.Multiply(const ALeft: Double;
  const ARight: TBLPoint): TBLPoint;
begin
  Result.Reset(ALeft * ARight.X, ALeft * ARight.Y);
end;

class operator TBLPoint.Multiply(const ALeft: TBLPoint;
  const ARight: Double): TBLPoint;
begin
  Result.Reset(ALeft.X * ARight, ALeft.Y * ARight);
end;

class operator TBLPoint.Negative(const AValue: TBLPoint): TBLPoint;
begin
  Result.Reset(-AValue.X, -AValue.Y);
end;

class operator TBLPoint.NotEqual(const ALeft, ARight: TBLPoint): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLPoint.Reset(const AOther: TBLPoint);
begin
  Self := AOther;
end;

class operator TBLPoint.Subtract(const ALeft: TBLPoint;
  const ARight: Double): TBLPoint;
begin
  Result.Reset(ALeft.X - ARight, ALeft.Y - ARight);
end;

class operator TBLPoint.Subtract(const ALeft: Double;
  const ARight: TBLPoint): TBLPoint;
begin
  Result.Reset(ALeft - ARight.X, ALeft - ARight.Y);
end;

class operator TBLPoint.Subtract(const ALeft, ARight: TBLPoint): TBLPoint;
begin
  Result.Reset(ALeft.X - ARight.X, ALeft.Y - ARight.Y);
end;

procedure TBLPoint.Reset(const AX, AY: Double);
begin
  X := AX;
  Y := AY;
end;

procedure TBLPoint.Reset;
begin
  X := 0;
  Y := 0;
end;

{ TBLPointI }

class operator TBLPointI.Add(const ALeft: TBLPointI;
  const ARight: Integer): TBLPointI;
begin
  Result.Reset(ALeft.X + ARight, ALeft.Y + ARight);
end;

class operator TBLPointI.Add(const ALeft: Integer;
  const ARight: TBLPointI): TBLPointI;
begin
  Result.Reset(ALeft + ARight.X, ALeft + ARight.Y);
end;

class operator TBLPointI.Add(const ALeft, ARight: TBLPointI): TBLPointI;
begin
  Result.Reset(ALeft.X + ARight.X, ALeft.X + ARight.Y);
end;

constructor TBLPointI.Create(const AX, AY: Integer);
begin
  X := AX;
  Y := AY;
end;

class operator TBLPointI.Equal(const ALeft, ARight: TBLPointI): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLPointI.Equals(const AOther: TBLPointI): Boolean;
begin
  Result := (X = AOther.X) and (Y = AOther.Y);
end;

class operator TBLPointI.Multiply(const ALeft: Integer;
  const ARight: TBLPointI): TBLPointI;
begin
  Result.Reset(ALeft * ARight.X, ALeft * ARight.Y);
end;

class operator TBLPointI.Multiply(const ALeft: TBLPointI;
  const ARight: Integer): TBLPointI;
begin
  Result.Reset(ALeft.X * ARight, ALeft.Y * ARight);
end;

class operator TBLPointI.Negative(const AValue: TBLPointI): TBLPointI;
begin
  Result.Reset(-AValue.X, -AValue.Y);
end;

class operator TBLPointI.NotEqual(const ALeft, ARight: TBLPointI): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLPointI.Reset(const AOther: TBLPointI);
begin
  Self := AOther;
end;

class operator TBLPointI.Subtract(const ALeft, ARight: TBLPointI): TBLPointI;
begin
  Result.Reset(ALeft.X - ARight.X, ALeft.X - ARight.Y);
end;

class operator TBLPointI.Subtract(const ALeft: Integer;
  const ARight: TBLPointI): TBLPointI;
begin
  Result.Reset(ALeft - ARight.X, ALeft - ARight.Y);
end;

class operator TBLPointI.Subtract(const ALeft: TBLPointI;
  const ARight: Integer): TBLPointI;
begin
  Result.Reset(ALeft.X - ARight, ALeft.Y - ARight);
end;

procedure TBLPointI.Reset(const AX, AY: Integer);
begin
  X := AX;
  Y := AY;
end;

procedure TBLPointI.Reset;
begin
  X := 0;
  Y := 0;
end;

class operator TBLPointI.Multiply(const ALeft, ARight: TBLPointI): TBLPointI;
begin
  Result.Reset(ALeft.X * ARight.X, ALeft.X * ARight.Y);
end;

{ TBLSize }

constructor TBLSize.Create(const AW, AH: Double);
begin
  W := AW;
  H := AH;
end;

class operator TBLSize.Equal(const ALeft, ARight: TBLSize): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLSize.Equals(const AOther: TBLSize): Boolean;
begin
  Result := (W = AOther.W) and (H = AOther.H);
end;

class operator TBLSize.NotEqual(const ALeft, ARight: TBLSize): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLSize.Reset(const AOther: TBLSize);
begin
  Self := AOther;
end;

procedure TBLSize.Reset(const AW, AH: Double);
begin
  W := AW;
  H := AH;
end;

procedure TBLSize.Reset;
begin
  W := 0;
  H := 0;
end;

{ TBLSizeI }

constructor TBLSizeI.Create(const AW, AH: Integer);
begin
  W := AW;
  H := AH;
end;

class operator TBLSizeI.Equal(const ALeft, ARight: TBLSizeI): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLSizeI.Equals(const AOther: TBLSizeI): Boolean;
begin
  Result := (W = AOther.W) and (H = AOther.H);
end;

class operator TBLSizeI.NotEqual(const ALeft, ARight: TBLSizeI): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLSizeI.Reset(const AOther: TBLSizeI);
begin
  Self := AOther;
end;

procedure TBLSizeI.Reset(const AW, AH: Integer);
begin
  W := AW;
  H := AH;
end;

procedure TBLSizeI.Reset;
begin
  W := 0;
  H := 0;
end;

{ TBLBox }

function TBLBox.Contains(const AX, AY: Double): Boolean;
begin
  Result := (AX >= X0) and (AY >= Y0) and (AX < X1) and (AY < Y1);
end;

class operator TBLBox.Add(const ALeft: TBLPoint; const ARight: TBLBox): TBLBox;
begin
  Result.Reset(ALeft.X + ARight.X0, ALeft.Y + ARight.Y0, ALeft.X + ARight.X1, ALeft.Y + ARight.Y1);
end;

class operator TBLBox.Add(const ALeft: TBLBox; const ARight: TBLPoint): TBLBox;
begin
  Result.Reset(ALeft.X0 + ARight.X, ALeft.Y0 + ARight.Y, ALeft.X1 + ARight.X, ALeft.Y1 + ARight.Y);
end;

class operator TBLBox.Add(const ALeft: Double; const ARight: TBLBox): TBLBox;
begin
  Result.Reset(ALeft + ARight.X0, ALeft + ARight.Y0, ALeft + ARight.X1, ALeft + ARight.Y1);
end;

class operator TBLBox.Add(const ALeft: TBLBox; const ARight: Double): TBLBox;
begin
  Result.Reset(ALeft.X0 + ARight, ALeft.Y0 + ARight, ALeft.X1 + ARight, ALeft.Y1 + ARight);
end;

function TBLBox.Contains(const APoint: TBLPoint): Boolean;
begin
  Result := Contains(APoint.X, APoint.Y);
end;

constructor TBLBox.Create(const AX0, AY0, AX1, AY1: Double);
begin
  X0 := AX0;
  Y0 := AY0;
  X1 := AX1;
  Y1 := AY1;
end;

class operator TBLBox.Divide(const ALeft: TBLPoint;
  const ARight: TBLBox): TBLBox;
begin
  Result.Reset(ALeft.X / ARight.X0, ALeft.Y / ARight.Y0, ALeft.X / ARight.X1, ALeft.Y / ARight.Y1);
end;

class operator TBLBox.Divide(const ALeft: TBLBox;
  const ARight: TBLPoint): TBLBox;
begin
  Result.Reset(ALeft.X0 / ARight.X, ALeft.Y0 / ARight.Y, ALeft.X1 / ARight.X, ALeft.Y1 / ARight.Y);
end;

class operator TBLBox.Divide(const ALeft: Double; const ARight: TBLBox): TBLBox;
begin
  Result.Reset(ALeft / ARight.X0, ALeft / ARight.Y0, ALeft / ARight.X1, ALeft / ARight.Y1);
end;

class operator TBLBox.Divide(const ALeft: TBLBox; const ARight: Double): TBLBox;
begin
  Result.Reset(ALeft.X0 / ARight, ALeft.Y0 / ARight, ALeft.X1 / ARight, ALeft.Y1 / ARight);
end;

class operator TBLBox.Equal(const ALeft, ARight: TBLBox): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLBox.Equals(const AOther: TBLBox): Boolean;
begin
  Result := (X0 = AOther.X0) and (Y0 = AOther.Y0)
        and (X1 = AOther.X1) and (Y1 = AOther.Y1);
end;

class operator TBLBox.Multiply(const ALeft: TBLPoint;
  const ARight: TBLBox): TBLBox;
begin
  Result.Reset(ALeft.X * ARight.X0, ALeft.Y * ARight.Y0, ALeft.X * ARight.X1, ALeft.Y * ARight.Y1);
end;

class operator TBLBox.Multiply(const ALeft: TBLBox;
  const ARight: TBLPoint): TBLBox;
begin
  Result.Reset(ALeft.X0 * ARight.X, ALeft.Y0 * ARight.Y, ALeft.X1 * ARight.X, ALeft.Y1 * ARight.Y);
end;

class operator TBLBox.Multiply(const ALeft: Double;
  const ARight: TBLBox): TBLBox;
begin
  Result.Reset(ALeft * ARight.X0, ALeft * ARight.Y0, ALeft * ARight.X1, ALeft * ARight.Y1);
end;

class operator TBLBox.Multiply(const ALeft: TBLBox;
  const ARight: Double): TBLBox;
begin
  Result.Reset(ALeft.X0 * ARight, ALeft.Y0 * ARight, ALeft.X1 * ARight, ALeft.Y1 * ARight);
end;

class operator TBLBox.NotEqual(const ALeft, ARight: TBLBox): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLBox.Reset(const AOther: TBLBox);
begin
  Self := AOther;
end;

class operator TBLBox.Subtract(const ALeft: TBLPoint;
  const ARight: TBLBox): TBLBox;
begin
  Result.Reset(ALeft.X - ARight.X0, ALeft.Y - ARight.Y0, ALeft.X - ARight.X1, ALeft.Y - ARight.Y1);
end;

class operator TBLBox.Subtract(const ALeft: TBLBox;
  const ARight: TBLPoint): TBLBox;
begin
  Result.Reset(ALeft.X0 - ARight.X, ALeft.Y0 - ARight.Y, ALeft.X1 - ARight.X, ALeft.Y1 - ARight.Y);
end;

class operator TBLBox.Subtract(const ALeft: Double;
  const ARight: TBLBox): TBLBox;
begin
  Result.Reset(ALeft - ARight.X0, ALeft - ARight.Y0, ALeft - ARight.X1, ALeft - ARight.Y1);
end;

class operator TBLBox.Subtract(const ALeft: TBLBox;
  const ARight: Double): TBLBox;
begin
  Result.Reset(ALeft.X0 - ARight, ALeft.Y0 - ARight, ALeft.X1 - ARight, ALeft.Y1 - ARight);
end;

procedure TBLBox.Reset(const AX0, AY0, AX1, AY1: Double);
begin
  X0 := AX0;
  Y0 := AY0;
  X1 := AX1;
  Y1 := AY1;
end;

procedure TBLBox.Reset;
begin
  X0 := 0;
  Y0 := 0;
  X1 := 0;
  Y1 := 0;
end;

{ TBLBoxI }

function TBLBoxI.Contains(const AX, AY: Integer): Boolean;
begin
  Result := (AX >= X0) and (AY >= Y0) and (AX < X1) and (AY < Y1);
end;

function TBLBoxI.Contains(const APoint: TBLPointI): Boolean;
begin
  Result := Contains(APoint.X, APoint.Y);
end;

constructor TBLBoxI.Create(const AX0, AY0, AX1, AY1: Integer);
begin
  X0 := AX0;
  Y0 := AY0;
  X1 := AX1;
  Y1 := AY1;
end;

class operator TBLBoxI.Equal(const ALeft, ARight: TBLBoxI): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLBoxI.Equals(const AOther: TBLBoxI): Boolean;
begin
  Result := (X0 = AOther.X0) and (Y0 = AOther.Y0)
        and (X1 = AOther.X1) and (Y1 = AOther.Y1);
end;

class operator TBLBoxI.NotEqual(const ALeft, ARight: TBLBoxI): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLBoxI.Reset(const AOther: TBLBoxI);
begin
  Self := AOther;
end;

procedure TBLBoxI.Reset(const AX0, AY0, AX1, AY1: Integer);
begin
  X0 := AX0;
  Y0 := AY0;
  X1 := AX1;
  Y1 := AY1;
end;

procedure TBLBoxI.Reset;
begin
  X0 := 0;
  Y0 := 0;
  X1 := 0;
  Y1 := 0;
end;

{ TBLRect }

constructor TBLRect.Create(const AX, AY, AW, AH: Double);
begin
  X := AX;
  Y := AY;
  W := AW;
  H := AH;
end;

class operator TBLRect.Equal(const ALeft, ARight: TBLRect): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLRect.Equals(const AOther: TBLRect): Boolean;
begin
  Result := (X = AOther.X) and (Y = AOther.Y)
        and (W = AOther.W) and (H = AOther.H);
end;

class operator TBLRect.NotEqual(const ALeft, ARight: TBLRect): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLRect.Reset(const AOther: TBLRect);
begin
  Self := AOther;
end;

procedure TBLRect.Reset(const AX, AY, AW, AH: Double);
begin
  X := AX;
  Y := AY;
  W := AW;
  H := AH;
end;

procedure TBLRect.Reset;
begin
  X := 0;
  Y := 0;
  W := 0;
  H := 0;
end;

{ TBLRectI }

constructor TBLRectI.Create(const AX, AY, AW, AH: Integer);
begin
  X := AX;
  Y := AY;
  W := AW;
  H := AH;
end;

class operator TBLRectI.Equal(const ALeft, ARight: TBLRectI): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLRectI.Equals(const AOther: TBLRectI): Boolean;
begin
  Result := (X = AOther.X) and (Y = AOther.Y)
        and (W = AOther.W) and (H = AOther.H);
end;

class operator TBLRectI.NotEqual(const ALeft, ARight: TBLRectI): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLRectI.Reset(const AOther: TBLRectI);
begin
  Self := AOther;
end;

procedure TBLRectI.Reset(const AX, AY, AW, AH: Integer);
begin
  X := AX;
  Y := AY;
  W := AW;
  H := AH;
end;

procedure TBLRectI.Reset;
begin
  X := 0;
  Y := 0;
  W := 0;
  H := 0;
end;

{ TBLRoundRect }

constructor TBLRoundRect.Create(const ARect: TBLRect; const AR: Double);
begin
  Reset(ARect, AR);
end;

constructor TBLRoundRect.Create(const ARect: TBLRect; const ARX, ARY: Double);
begin
  Reset(ARect, ARX, ARY);
end;

constructor TBLRoundRect.Create(const AX, AY, AW, AH, ARX, ARY: Double);
begin
  Reset(AX, AY, AW, AH, ARX, ARY);
end;

constructor TBLRoundRect.Create(const AX, AY, AW, AH, AR: Double);
begin
  Reset(AX, AY, AW, AH, AR);
end;

class operator TBLRoundRect.Equal(const ALeft, ARight: TBLRoundRect): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLRoundRect.Equals(const AOther: TBLRoundRect): Boolean;
begin
  Result := (X = AOther.X) and (Y = AOther.Y)
        and (W = AOther.W) and (H = AOther.H)
        and (RX = AOther.RX) and (RY = AOther.RY);
end;

class operator TBLRoundRect.NotEqual(const ALeft,
  ARight: TBLRoundRect): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLRoundRect.Reset;
begin
  X := 0;
  Y := 0;
  W := 0;
  H := 0;
  RX := 0;
  RY := 0;
end;

procedure TBLRoundRect.Reset(const ARect: TBLRect; const AR: Double);
begin
  X := ARect.X;
  Y := ARect.Y;
  W := ARect.W;
  H := ARect.H;
  RX := AR;
  RY := AR;
end;

procedure TBLRoundRect.Reset(const ARect: TBLRect; const ARX, ARY: Double);
begin
  X := ARect.X;
  Y := ARect.Y;
  W := ARect.W;
  H := ARect.H;
  RX := ARX;
  RY := ARY;
end;

procedure TBLRoundRect.Reset(const AOther: TBLRoundRect);
begin
  Self := AOther;
end;

procedure TBLRoundRect.Reset(const AX, AY, AW, AH, ARX, ARY: Double);
begin
  X := AX;
  Y := AY;
  W := AW;
  H := AH;
  RX := ARX;
  RY := ARY;
end;

procedure TBLRoundRect.Reset(const AX, AY, AW, AH, AR: Double);
begin
  X := AX;
  Y := AY;
  W := AW;
  H := AH;
  RX := AR;
  RY := AR;
end;

{ TBLCircle }

constructor TBLCircle.Create(const ACX, ACY, AR: Double);
begin
  CX := ACX;
  CY := ACY;
  R := AR;
end;

class operator TBLCircle.Equal(const ALeft, ARight: TBLCircle): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLCircle.Equals(const AOther: TBLCircle): Boolean;
begin
  Result := (CX = AOther.CX) and (CY = AOther.CY) and (R = AOther.R);
end;

class operator TBLCircle.NotEqual(const ALeft, ARight: TBLCircle): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLCircle.Reset(const AOther: TBLCircle);
begin
  Self := AOther;
end;

procedure TBLCircle.Reset(const ACX, ACY, AR: Double);
begin
  CX := ACX;
  CY := ACY;
  R := AR;
end;

procedure TBLCircle.Reset;
begin
  CX := 0;
  CY := 0;
  R := 0;
end;

{ TBLEllipse }

constructor TBLEllipse.Create(const ACX, ACY, AR: Double);
begin
  CX := ACX;
  CY := ACY;
  RX := AR;
  RY := AR;
end;

constructor TBLEllipse.Create(const ACX, ACY, ARX, ARY: Double);
begin
  CX := ACX;
  CY := ACY;
  RX := ARX;
  RY := ARY;
end;

class operator TBLEllipse.Equal(const ALeft, ARight: TBLEllipse): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLEllipse.Equals(const AOther: TBLEllipse): Boolean;
begin
  Result := (CX = AOther.CX) and (CY = AOther.CY)
        and (RX = AOther.RX) and (RY = AOther.RY);
end;

class operator TBLEllipse.NotEqual(const ALeft, ARight: TBLEllipse): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLEllipse.Reset(const AOther: TBLEllipse);
begin
  Self := AOther;
end;

procedure TBLEllipse.Reset(const ACX, ACY, ARX, ARY: Double);
begin
  CX := ACX;
  CY := ACY;
  RX := ARX;
  RY := ARY;
end;

procedure TBLEllipse.Reset(const ACX, ACY, AR: Double);
begin
  CX := ACX;
  CY := ACY;
  RX := AR;
  RY := AR;
end;

procedure TBLEllipse.Reset;
begin
  CX := 0;
  CY := 0;
  RX := 0;
  RY := 0;
end;

{ TBLArc }

constructor TBLArc.Create(const ACX, ACY, ARX, ARY, AStart, ASweep: Double);
begin
  CX := ACX;
  CY := ACY;
  RX := ARX;
  RY := ARY;
  Start := AStart;
  Sweep := ASweep;
end;

class operator TBLArc.Equal(const ALeft, ARight: TBLArc): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLArc.Equals(const AOther: TBLArc): Boolean;
begin
  Result := (CX = AOther.CX) and (CY = AOther.CY)
        and (RX = AOther.RX) and (RY = AOther.RY)
        and (Start = AOther.Start) and (Sweep = AOther.Sweep);
end;

class operator TBLArc.NotEqual(const ALeft, ARight: TBLArc): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLArc.Reset(const AOther: TBLArc);
begin
  Self := AOther;
end;

procedure TBLArc.Reset(const ACX, ACY, ARX, ARY, AStart, ASweep: Double);
begin
  CX := ACX;
  CY := ACY;
  RX := ARX;
  RY := ARY;
  Start := AStart;
  Sweep := ASweep;
end;

procedure TBLArc.Reset;
begin
  CX := 0;
  CY := 0;
  RX := 0;
  RY := 0;
  Start := 0;
  Sweep := 0;
end;

{ TBLLine }

constructor TBLLine.Create(const AX0, AY0, AX1, AY1: Double);
begin
  X0 := AX0;
  Y0 := AY0;
  X1 := AX1;
  Y1 := AY1;
end;

class operator TBLLine.Equal(const ALeft, ARight: TBLLine): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLLine.Equals(const AOther: TBLLine): Boolean;
begin
  Result := (X0 = AOther.X0) and (Y0 = AOther.Y0)
        and (X1 = AOther.X1) and (Y1 = AOther.Y1);
end;

class operator TBLLine.NotEqual(const ALeft, ARight: TBLLine): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLLine.Reset(const AOther: TBLLine);
begin
  Self := AOther;
end;

procedure TBLLine.Reset(const AP0, AP1: TBLPoint);
begin
  X0 := AP0.X;
  Y0 := AP0.Y;
  X1 := AP1.X;
  Y1 := AP1.Y;
end;

procedure TBLLine.Reset(const AX0, AY0, AX1, AY1: Double);
begin
  X0 := AX0;
  Y0 := AY0;
  X1 := AX1;
  Y1 := AY1;
end;

procedure TBLLine.Reset;
begin
  X0 := 0;
  Y0 := 0;
  X1 := 0;
  Y1 := 0;
end;

{ TBLTriangle }

constructor TBLTriangle.Create(const AX0, AY0, AX1, AY1, AX2, AY2: Double);
begin
  X0 := AX0;
  Y0 := AY0;
  X1 := AX1;
  Y1 := AY1;
  X2 := AX2;
  Y2 := AY2;
end;

class operator TBLTriangle.Equal(const ALeft, ARight: TBLTriangle): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLTriangle.Equals(const AOther: TBLTriangle): Boolean;
begin
  Result := (X0 = AOther.X0) and (Y0 = AOther.Y0)
        and (X1 = AOther.X1) and (Y1 = AOther.Y1)
        and (X2 = AOther.X2) and (Y2 = AOther.Y2);
end;

class operator TBLTriangle.NotEqual(const ALeft, ARight: TBLTriangle): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLTriangle.Reset(const AOther: TBLTriangle);
begin
  Self := AOther;
end;

procedure TBLTriangle.Reset(const AX0, AY0, AX1, AY1, AX2, AY2: Double);
begin
  X0 := AX0;
  Y0 := AY0;
  X1 := AX1;
  Y1 := AY1;
  X2 := AX2;
  Y2 := AY2;
end;

procedure TBLTriangle.Reset;
begin
  X0 := 0;
  Y0 := 0;
  X1 := 0;
  Y1 := 0;
  X2 := 0;
  Y2 := 0;
end;

{ TBLMatrix2D }

constructor TBLMatrix2D.Create(const AM00, AM01, AM10, AM11, AM20,
  AM21: Double);
begin
  Reset(AM00, AM01, AM10, AM11, AM20, AM21);
end;

function TBLMatrix2D.Determinant: Double;
begin
  Result := (M00 * M11) - (M01 * M10);
end;

class operator TBLMatrix2D.Equal(const ALeft, ARight: TBLMatrix2D): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLMatrix2D.Equals(const AOther: TBLMatrix2D): Boolean;
begin
  Result := (M[0] = AOther.M[0]) and (M[1] = AOther.M[1])
        and (M[2] = AOther.M[2]) and (M[3] = AOther.M[3])
        and (M[4] = AOther.M[4]) and (M[5] = AOther.M[5]);
end;

function TBLMatrix2D.GetKind: TBLTransformKind;
begin
  Result := TBLTransformKind(_blMatrix2DGetType(@Self));
end;

class function TBLMatrix2D.Invert(const ASrc: TBLMatrix2D;
  out ADst: TBLMatrix2D): Boolean;
begin
  Result := (_blMatrix2DInvert(@ADst, @ASrc) = 0);
end;

function TBLMatrix2D.Invert: Boolean;
begin
  Result := (_blMatrix2DInvert(@Self, @Self) = 0);
end;

class function TBLMatrix2D.MakeIdentity: TBLMatrix2D;
begin
  Result := Identity;
end;

class function TBLMatrix2D.MakeRotation(const AAngle: Double): TBLMatrix2D;
begin
  Result.ResetToRotation(AAngle, 0, 0);
end;

class function TBLMatrix2D.MakeRotation(const AAngle, AX,
  AY: Double): TBLMatrix2D;
begin
  Result.ResetToRotation(AAngle, AX, AY);
end;

class function TBLMatrix2D.MakeRotation(const AAngle: Double;
  const AOrigin: TBLPoint): TBLMatrix2D;
begin
  Result.ResetToRotation(AAngle, AOrigin.X, AOrigin.Y);
end;

class function TBLMatrix2D.MakeScaling(const AXY: Double): TBLMatrix2D;
begin
  Result.Reset(AXY, 0, 0, AXY, 0, 0);
end;

class function TBLMatrix2D.MakeScaling(const AX, AY: Double): TBLMatrix2D;
begin
  Result.Reset(AX, 0, 0, AY, 0, 0);
end;

class function TBLMatrix2D.MakeScaling(const AP: TBLPoint): TBLMatrix2D;
begin
  Result.Reset(AP.X, 0, 0, AP.Y, 0, 0);
end;

class function TBLMatrix2D.MakeScaling(const AP: TBLPointI): TBLMatrix2D;
begin
  Result.Reset(AP.X, 0, 0, AP.Y, 0, 0);
end;

class function TBLMatrix2D.MakeSinCos(const ASin, ACos: Double;
  const AP: TBLPoint): TBLMatrix2D;
begin
  Result.Reset(ACos, ASin, -ASin, ACos, AP.X, AP.Y);
end;

class function TBLMatrix2D.MakeSinCos(const ASin, ACos, ATX,
  ATY: Double): TBLMatrix2D;
begin
  Result.Reset(ACos, ASin, -ASin, ACos, ATX, ATY);
end;

class function TBLMatrix2D.MakeSkewing(const AOrigin: TBLPoint): TBLMatrix2D;
begin
  Result.ResetToSkewing(AOrigin.X, AOrigin.Y);
end;

class function TBLMatrix2D.MakeSkewing(const AX, AY: Double): TBLMatrix2D;
begin
  Result.ResetToSkewing(AX, AY);
end;

class function TBLMatrix2D.MakeTranslation(const AX, AY: Double): TBLMatrix2D;
begin
  Result.Reset(1, 0, 0, 1, AX, AY);
end;

class function TBLMatrix2D.MakeTranslation(const AP: TBLPoint): TBLMatrix2D;
begin
  Result.Reset(1, 0, 0, 1, AP.X, AP.Y);
end;

class function TBLMatrix2D.MakeTranslation(const AP: TBLPointI): TBLMatrix2D;
begin
  Result.Reset(1, 0, 0, 1, AP.X, AP.Y);
end;

function TBLMatrix2D.MapPoint(const AP: TBLPoint): TBLPoint;
begin
  Result := MapPoint(AP.X, AP.Y);
end;

function TBLMatrix2D.MapPoint(const AX, AY: Double): TBLPoint;
begin
  Result.X := (AX * M00) + (AY * M10) + M20;
  Result.Y := (AX * M01) + (AY * M11) + M21;
end;

function TBLMatrix2D.MapVector(const AP: TBLPoint): TBLPoint;
begin
  Result := MapVector(AP.X, AP.Y);
end;

function TBLMatrix2D.MapVector(const AX, AY: Double): TBLPoint;
begin
  Result.X := (AX * M00) + (AY * M10);
  Result.Y := (AX * M01) + (AY * M11);
end;

class operator TBLMatrix2D.NotEqual(const ALeft, ARight: TBLMatrix2D): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLMatrix2D.PostTranslate(const AX, AY: Double);
begin
  M20 := M20 + AX;
  M21 := M21 + AY;
end;

procedure TBLMatrix2D.PostTranslate(const AP: TBLPoint);
begin
  M20 := M20 + AP.X;
  M21 := M21 + AP.Y;
end;

procedure TBLMatrix2D.PostScale(const AXY: Double);
begin
  PostScale(AXY, AXY);
end;

procedure TBLMatrix2D.PostScale(const AX, AY: Double);
begin
  M00 := M00 * AX;
  M01 := M01 * AY;
  M10 := M10 * AX;
  M11 := M11 * AY;
  M20 := M20 * AX;
  M21 := M21 * AY;
end;

procedure TBLMatrix2D.PostScale(const AP: TBLPoint);
begin
  PostScale(AP.X, AP.Y);
end;

procedure TBLMatrix2D.PostRotate(const AAngle: Double);
begin
  _blMatrix2DApplyOp(@Self, Ord(TBLTransformOp.PostRotate), @AAngle);
end;

procedure TBLMatrix2D.PostRotate(const AAngle, AX, AY: Double);
var
  OpData: array [0..2] of Double;
begin
  OpData[0] := AAngle;
  OpData[1] := AX;
  OpData[2] := AY;
  _blMatrix2DApplyOp(@Self, Ord(TBLTransformOp.PostRotatePoint), @OpData);
end;

procedure TBLMatrix2D.PostRotate(const AAngle: Double; const AP: TBLPoint);
var
  OpData: array [0..2] of Double;
begin
  OpData[0] := AAngle;
  OpData[1] := AP.X;
  OpData[2] := AP.Y;
  _blMatrix2DApplyOp(@Self, Ord(TBLTransformOp.PostRotatePoint), @OpData);
end;

procedure TBLMatrix2D.PostRotate(const AAngle: Double; const AP: TBLPointI);
var
  OpData: array [0..2] of Double;
begin
  OpData[0] := AAngle;
  OpData[1] := AP.X;
  OpData[2] := AP.Y;
  _blMatrix2DApplyOp(@Self, Ord(TBLTransformOp.PostRotatePoint), @OpData);
end;

procedure TBLMatrix2D.PostScale(const AP: TBLPointI);
begin
  PostScale(AP.X, AP.Y);
end;

procedure TBLMatrix2D.PostSkew(const AP: TBLPoint);
begin
  _blMatrix2DApplyOp(@Self, Ord(TBLTransformOp.PostSkew), @AP);
end;

procedure TBLMatrix2D.PostSkew(const AX, AY: Double);
begin
  var P: TBLPoint;
  P.Reset(AX, AY);
  _blMatrix2DApplyOp(@Self, Ord(TBLTransformOp.PostSkew), @P);
end;

procedure TBLMatrix2D.PostTransform(const AM: TBLMatrix2D);
begin
  _blMatrix2DApplyOp(@Self, Ord(TBLTransformOp.PostTransform), @AM);
end;

procedure TBLMatrix2D.PostTranslate(const AP: TBLPointI);
begin
  M20 := M20 + AP.X;
  M21 := M21 + AP.Y;
end;

procedure TBLMatrix2D.Reset;
begin
  M[0] := 1;
  M[1] := 0;
  M[2] := 0;
  M[3] := 1;
  M[4] := 0;
  M[5] := 0;
end;

procedure TBLMatrix2D.Reset(const AM00, AM01, AM10, AM11, AM20, AM21: Double);
begin
  M[0] := AM00;
  M[1] := AM01;
  M[2] := AM10;
  M[3] := AM11;
  M[4] := AM20;
  M[5] := AM21;
end;

procedure TBLMatrix2D.Reset(const AOther: TBLMatrix2D);
begin
  Self := AOther;
end;

procedure TBLMatrix2D.ResetToRotation(const AAngle: Double);
begin
  _blMatrix2DSetRotation(@Self, AAngle, 0, 0);
end;

procedure TBLMatrix2D.ResetToRotation(const AAngle, AX, AY: Double);
begin
  _blMatrix2DSetRotation(@Self, AAngle, AX, AY);
end;

procedure TBLMatrix2D.ResetToRotation(const AAngle: Double;
  const AOrigin: TBLPoint);
begin
  _blMatrix2DSetRotation(@Self, AAngle, AOrigin.X, AOrigin.Y);
end;

procedure TBLMatrix2D.ResetToScaling(const AXY: Double);
begin
  Reset(AXY, 0, 0, AXY, 0, 0);
end;

procedure TBLMatrix2D.ResetToScaling(const AX, AY: Double);
begin
  Reset(AX, 0, 0, AY, 0, 0);
end;

procedure TBLMatrix2D.ResetToScaling(const AP: TBLPoint);
begin
  Reset(AP.X, 0, 0, AP.Y, 0, 0);
end;

procedure TBLMatrix2D.ResetToScaling(const AP: TBLPointI);
begin
  Reset(AP.X, 0, 0, AP.Y, 0, 0);
end;

procedure TBLMatrix2D.ResetToSinCos(const ASin, ACos: Double;
  const AP: TBLPoint);
begin
  Reset(ACos, ASin, -ASin, ACos, AP.X, AP.Y);
end;

procedure TBLMatrix2D.ResetToSinCos(const ASin, ACos, ATX, ATY: Double);
begin
  Reset(ACos, ASin, -ASin, ACos, ATX, ATY);
end;

procedure TBLMatrix2D.ResetToSkewing(const AP: TBLPoint);
begin
  _blMatrix2DSetSkewing(@Self, AP.X, AP.Y);
end;

procedure TBLMatrix2D.ResetToSkewing(const AX, AY: Double);
begin
  _blMatrix2DSetSkewing(@Self, AX, AY);
end;

procedure TBLMatrix2D.ResetToTranslation(const AX, AY: Double);
begin
  Reset(1, 0, 0, 1, AX, AY);
end;

procedure TBLMatrix2D.ResetToTranslation(const AP: TBLPoint);
begin
  Reset(1, 0, 0, 1, AP.X, AP.Y);
end;

procedure TBLMatrix2D.ResetToTranslation(const AP: TBLPointI);
begin
  Reset(1, 0, 0, 1, AP.X, AP.Y);
end;

procedure TBLMatrix2D.Rotate(const AAngle: Double);
begin
  _blMatrix2DApplyOp(@Self, Ord(TBLTransformOp.Rotate), @AAngle);
end;

procedure TBLMatrix2D.Rotate(const AAngle, AX, AY: Double);
var
  OpData: array [0..2] of Double;
begin
  OpData[0] := AAngle;
  OpData[1] := AX;
  OpData[2] := AY;
  _blMatrix2DApplyOp(@Self, Ord(TBLTransformOp.RotatePoint), @OpData);
end;

procedure TBLMatrix2D.Rotate(const AAngle: Double; const AP: TBLPoint);
var
  OpData: array [0..2] of Double;
begin
  OpData[0] := AAngle;
  OpData[1] := AP.X;
  OpData[2] := AP.Y;
  _blMatrix2DApplyOp(@Self, Ord(TBLTransformOp.RotatePoint), @OpData);
end;

procedure TBLMatrix2D.Rotate(const AAngle: Double; const AP: TBLPointI);
var
  OpData: array [0..2] of Double;
begin
  OpData[0] := AAngle;
  OpData[1] := AP.X;
  OpData[2] := AP.Y;
  _blMatrix2DApplyOp(@Self, Ord(TBLTransformOp.RotatePoint), @OpData);
end;

procedure TBLMatrix2D.Scale(const AXY: Double);
begin
  Scale(AXY, AXY);
end;

procedure TBLMatrix2D.Scale(const AX, AY: Double);
begin
  M00 := M00 * AX;
  M01 := M01 * AX;
  M10 := M10 * AY;
  M11 := M11 * AY;
end;

procedure TBLMatrix2D.Scale(const AP: TBLPoint);
begin
  Scale(AP.X, AP.Y);
end;

procedure TBLMatrix2D.Scale(const AP: TBLPointI);
begin
  Scale(AP.X, AP.Y);
end;

procedure TBLMatrix2D.Skew(const AP: TBLPoint);
begin
  _blMatrix2DApplyOp(@Self, Ord(TBLTransformOp.Skew), @AP);
end;

procedure TBLMatrix2D.Skew(const AX, AY: Double);
begin
  var P: TBLPoint;
  P.Reset(AX, AY);
  _blMatrix2DApplyOp(@Self, Ord(TBLTransformOp.Skew), @P);
end;

procedure TBLMatrix2D.Transform(const AM: TBLMatrix2D);
begin
  _blMatrix2DApplyOp(@Self, Ord(TBLTransformOp.Transform), @AM);
end;

procedure TBLMatrix2D.Translate(const AX, AY: Double);
begin
  M20 := M20 + (AX * M00) + (AY * M10);
  M21 := M21 + (AX * M01) + (AY * M11);
end;

procedure TBLMatrix2D.Translate(const AP: TBLPoint);
begin
  Translate(AP.X, AP.Y);
end;

procedure TBLMatrix2D.Translate(const AP: TBLPointI);
begin
  Translate(AP.X, AP.Y);
end;

{ TBLStrokeOptions }

class operator TBLStrokeOptions.Assign(var ADest: TBLStrokeOptions;
  const [ref] ASrc: TBLStrokeOptions);
begin
  _BLCheck(_blStrokeOptionsInitWeak(@ADest, @ASrc));
end;

class operator TBLStrokeOptions.Equal(const ALeft,
  ARight: TBLStrokeOptions): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLStrokeOptions.Equals(const AOther: TBLStrokeOptions): Boolean;
begin
  Result := _blStrokeOptionsEquals(@Self, @AOther);
end;

class operator TBLStrokeOptions.Finalize(var ADest: TBLStrokeOptions);
begin
  _BLCheck(_blStrokeOptionsDestroy(@ADest));
end;

function TBLStrokeOptions.GetCap(
  const AIndex: TBLStrokeCapPosition): TBLStrokeCap;
begin
  Result := TBLStrokeCap(FValues.Caps[AIndex]);
end;

function TBLStrokeOptions.GetEndCap: TBLStrokeCap;
begin
  Result := TBLStrokeCap(FValues.EndCap);
end;

function TBLStrokeOptions.GetJoin: TBLStrokeJoin;
begin
  Result := TBLStrokeJoin(FValues.Join);
end;

function TBLStrokeOptions.GetStartCap: TBLStrokeCap;
begin
  Result := TBLStrokeCap(FValues.StartCap);
end;

function TBLStrokeOptions.GetTransformOrder: TBLStrokeTransformOrder;
begin
  Result := TBLStrokeTransformOrder(FValues.TransformOrder);
end;

class operator TBLStrokeOptions.Initialize(out ADest: TBLStrokeOptions);
begin
  _BLCheck(_blStrokeOptionsInit(@ADest));
end;

class operator TBLStrokeOptions.NotEqual(const ALeft,
  ARight: TBLStrokeOptions): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLStrokeOptions.Reset;
begin
  _BLCheck(_blStrokeOptionsReset(@Self));
end;

procedure TBLStrokeOptions.SetCap(const AIndex: TBLStrokeCapPosition;
  const AValue: TBLStrokeCap);
begin
  FValues.Caps[AIndex] := Ord(AValue);
end;

procedure TBLStrokeOptions.SetCaps(const ACap: TBLStrokeCap);
begin
  FValues.StartCap := Ord(ACap);
  FValues.EndCap := Ord(ACap);
end;

procedure TBLStrokeOptions.SetEndCap(const AValue: TBLStrokeCap);
begin
  FValues.EndCap := Ord(AValue);
end;

procedure TBLStrokeOptions.SetJoin(const AValue: TBLStrokeJoin);
begin
  FValues.Join := Ord(AValue);
end;

procedure TBLStrokeOptions.SetStartCap(const AValue: TBLStrokeCap);
begin
  FValues.StartCap := Ord(AValue);
end;

procedure TBLStrokeOptions.SetTransformOrder(
  const AValue: TBLStrokeTransformOrder);
begin
  FValues.TransformOrder := Ord(AValue);
end;

{ TBLApproximationOptions }

function TBLApproximationOptions.GetFlattenMode: TBLFlattenMode;
begin
  Result := TBLFlattenMode(FFlattenMode);
end;

function TBLApproximationOptions.GetOffsetMode: TBLOffsetMode;
begin
  Result := TBLOffsetMode(FOffsetMode);
end;

procedure TBLApproximationOptions.SetFlattenMode(const AValue: TBLFlattenMode);
begin
  FFlattenMode := Ord(AValue);
end;

procedure TBLApproximationOptions.SetOffsetMode(const AValue: TBLOffsetMode);
begin
  FOffsetMode := Ord(AValue);
end;

{ TBLPathView }

procedure TBLPathView.Reset(const ACommandDataIn: PByte;
  const AVertexDataIn: PBLPoint; const ACountIn: NativeInt);
begin
  FCommandData := ACommandDataIn;
  FVertexData := AVertexDataIn;
  FCount := ACountIn;
end;

procedure TBLPathView.Reset;
begin
  FCommandData := nil;
  FVertexData := nil;
  FCount := 0;
end;

{ TBLPath }

procedure TBLPath.AddBox(const ABox: TBLBoxI; const ADir: TBLGeometryDirection);
begin
  _BLCheck(_blPathAddBoxI(@Self, @ABox, Ord(ADir)));
end;

procedure TBLPath.AddBox(const ABox: TBLBox; const ADir: TBLGeometryDirection);
begin
  _BLCheck(_blPathAddBoxD(@Self, @ABox, Ord(ADir)));
end;

procedure TBLPath.AddArc(const AArc: TBLArc; const ATransform: TBLMatrix2D;
  const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.Arc, @AArc, ATransform, ADir);
end;

procedure TBLPath.AddArc(const AArc: TBLArc; const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.Arc, @AArc, ADir);
end;

procedure TBLPath.AddBox(const AX0, AY0, AX1, AY1: Double;
  const ADir: TBLGeometryDirection);
begin
  var Box: TBLBox;
  Box.Reset(AX0, AY0, AX1, AY1);
  _BLCheck(_blPathAddBoxD(@Self, @Box, Ord(ADir)));
end;

procedure TBLPath.AddBoxArray(const AArray: TArray<TBLBoxI>;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLBoxI>;
  View.Reset(Pointer(AArray), Length(AArray));
  AddBoxArray(View, ATransform, ADir);
end;

procedure TBLPath.AddBoxArray(const AArray: PBLBoxI; const ACount: NativeInt;
  const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLBoxI>;
  View.Reset(Pointer(AArray), ACount);
  AddBoxArray(View, ADir);
end;

procedure TBLPath.AddBoxArray(const AArray: PBLBoxI; const ACount: NativeInt;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLBoxI>;
  View.Reset(Pointer(AArray), ACount);
  AddBoxArray(View, ATransform, ADir);
end;

procedure TBLPath.AddBoxArray(const AArray: TBLArrayView<TBLBoxI>;
  const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.ArrayViewBoxI, @AArray, ADir);
end;

procedure TBLPath.AddBoxArray(const AArray: TBLArrayView<TBLBoxI>;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.ArrayViewBoxI, @AArray, ATransform, ADir);
end;

procedure TBLPath.AddBoxArray(const AArray: TArray<TBLBoxI>;
  const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLBoxI>;
  View.Reset(Pointer(AArray), Length(AArray));
  AddBoxArray(View, ADir);
end;

procedure TBLPath.AddBoxArray(const AArray: TArray<TBLBox>;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLBox>;
  View.Reset(Pointer(AArray), Length(AArray));
  AddBoxArray(View, ATransform, ADir);
end;

procedure TBLPath.AddBoxArray(const AArray: PBLBox; const ACount: NativeInt;
  const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLBox>;
  View.Reset(Pointer(AArray), ACount);
  AddBoxArray(View, ADir);
end;

procedure TBLPath.AddBoxArray(const AArray: PBLBox; const ACount: NativeInt;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLBox>;
  View.Reset(Pointer(AArray), ACount);
  AddBoxArray(View, ATransform, ADir);
end;

procedure TBLPath.AddBoxArray(const AArray: TBLArrayView<TBLBox>;
  const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.ArrayViewBoxD, @AArray, ADir);
end;

procedure TBLPath.AddBoxArray(const AArray: TBLArrayView<TBLBox>;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.ArrayViewBoxD, @AArray, ATransform, ADir);
end;

procedure TBLPath.AddBoxArray(const AArray: TArray<TBLBox>;
  const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLBox>;
  View.Reset(Pointer(AArray), Length(AArray));
  AddBoxArray(View, ADir);
end;

procedure TBLPath.AddChord(const AChord: TBLArc; const ATransform: TBLMatrix2D;
  const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.Chord, @AChord, ATransform, ADir);
end;

procedure TBLPath.AddChord(const AChord: TBLArc;
  const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.Chord, @AChord, ADir);
end;

procedure TBLPath.AddCircle(const ACircle: TBLCircle;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.Circle, @ACircle, ATransform, ADir);
end;

procedure TBLPath.AddCircle(const ACircle: TBLCircle;
  const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.Circle, @ACircle, ADir);
end;

procedure TBLPath.AddCubicToSegments(const APoints: PBLPoint;
  const ASegmentCount: NativeInt);
begin
  var CmdPtr: PByte;
  var VtxPtr: PBLPoint;
  var PointCount: NativeInt := ASegmentCount * 3;
  _BLCheck(_blPathModifyOp(@Self, Ord(TBLModifyOp.AppendGrow), PointCount, @CmdPtr, @VtxPtr));

  for var I := 0 to ASegmentCount - 1 do
  begin
    CmdPtr^ := Ord(TBLPathCmd.Cubic);
    Inc(CmdPtr);
    CmdPtr^ := Ord(TBLPathCmd.Cubic);
    Inc(CmdPtr);
    CmdPtr^ := Ord(TBLPathCmd.OnPath);
    Inc(CmdPtr);
  end;

  Move(APoints^, VtxPtr^, PointCount * SizeOf(TBLPoint));
end;

procedure TBLPath.AddEllipse(const AEllipse: TBLEllipse;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.Ellipse, @AEllipse, ATransform, ADir);
end;

procedure TBLPath.AddEllipse(const AEllipse: TBLEllipse;
  const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.Ellipse, @AEllipse, ADir);
end;

procedure TBLPath.AddGeometry(const AGeometryType: TBLGeometryType;
  const AGeometryData: Pointer; const AMatrix: TBLMatrix2D;
  const ADir: TBLGeometryDirection);
begin
  _BLCheck(_blPathAddGeometry(@Self, Ord(AGeometryType), AGeometryData, @AMatrix, Ord(ADir)));
end;

procedure TBLPath.AddGeometry(const AGeometryType: TBLGeometryType;
  const AGeometryData: Pointer; const ADir: TBLGeometryDirection);
begin
  _BLCheck(_blPathAddGeometry(@Self, Ord(AGeometryType), AGeometryData, nil, Ord(ADir)));
end;

procedure TBLPath.AddCubicToSegments(const APoints: TArray<TBLPoint>);
begin
  Assert((Length(APoints) mod 3) = 0);
  AddCubicToSegments(Pointer(APoints), Length(APoints) div 3);
end;

procedure TBLPath.AddLine(const ALine: TBLLine; const ATransform: TBLMatrix2D;
  const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.Line, @ALine, ATransform, ADir);
end;

procedure TBLPath.AddLine(const ALine: TBLLine;
  const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.Line, @ALine, ADir);
end;

procedure TBLPath.AddLineToSegments(const APoints: PBLPoint;
  const ACount: NativeInt);
begin
  var CmdPtr: PByte;
  var VtxPtr: PBLPoint;
  _BLCheck(_blPathModifyOp(@Self, Ord(TBLModifyOp.AppendGrow), ACount, @CmdPtr, @VtxPtr));
  FillChar(CmdPtr^, ACount, Ord(TBLPathCmd.OnPath));
  Move(APoints^, VtxPtr^, ACount * SizeOf(TBLPoint));
end;

procedure TBLPath.AddPath(const APath: TBLPath; const AP: TBLPoint);
begin
  _BLCheck(_blPathAddTranslatedPath(@Self, @APath, nil, @AP));
end;

procedure TBLPath.AddPath(const APath: TBLPath; const ARange: TBLRange);
begin
  _BLCheck(_blPathAddPath(@Self, @APath, @ARange));
end;

procedure TBLPath.AddPath(const APath: TBLPath);
begin
  _BLCheck(_blPathAddPath(@Self, @APath, nil));
end;

procedure TBLPath.AddPath(const APath: TBLPath; const ARange: TBLRange;
  const ATransform: TBLMatrix2D);
begin
  _BLCheck(_blPathAddTransformedPath(@Self, @APath, @ARange, @ATransform));
end;

procedure TBLPath.AddPath(const APath: TBLPath; const ATransform: TBLMatrix2D);
begin
  _BLCheck(_blPathAddTransformedPath(@Self, @APath, nil, @ATransform));
end;

procedure TBLPath.AddPath(const APath: TBLPath; const ARange: TBLRange;
  const AP: TBLPoint);
begin
  _BLCheck(_blPathAddTranslatedPath(@Self, @APath, @ARange, @AP));
end;

procedure TBLPath.AddPie(const APie: TBLArc; const ATransform: TBLMatrix2D;
  const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.Pie, @APie, ATransform, ADir);
end;

procedure TBLPath.AddPolygon(const APoly: TArray<TBLPointI>;
  const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLPointI>;
  View.Reset(Pointer(APoly), Length(APoly));
  AddPolygon(View, ADir);
end;

procedure TBLPath.AddPolygon(const APoly: PBLPointI; const ACount: NativeInt;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLPointI>;
  View.Reset(Pointer(APoly), ACount);
  AddPolygon(View, ATransform, ADir);
end;

procedure TBLPath.AddPolygon(const APoly: PBLPointI; const ACount: NativeInt;
  const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLPointI>;
  View.Reset(Pointer(APoly), ACount);
  AddPolygon(View, ADir);
end;

procedure TBLPath.AddPolygon(const APoly: TBLArrayView<TBLPointI>;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.PolygonI, @APoly, ATransform, ADir);
end;

procedure TBLPath.AddPolygon(const APoly: TBLArrayView<TBLPointI>;
  const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.PolygonI, @APoly, ADir);
end;

procedure TBLPath.AddPolygon(const APoly: TArray<TBLPointI>;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLPointI>;
  View.Reset(Pointer(APoly), Length(APoly));
  AddPolygon(View, ATransform, ADir);
end;

procedure TBLPath.AddPolygon(const APoly: TArray<TBLPoint>;
  const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLPoint>;
  View.Reset(Pointer(APoly), Length(APoly));
  AddPolygon(View, ADir);
end;

procedure TBLPath.AddPolygon(const APoly: PBLPoint; const ACount: NativeInt;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLPoint>;
  View.Reset(Pointer(APoly), ACount);
  AddPolygon(View, ATransform, ADir);
end;

procedure TBLPath.AddPolygon(const APoly: PBLPoint; const ACount: NativeInt;
  const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLPoint>;
  View.Reset(Pointer(APoly), ACount);
  AddPolygon(View, ADir);
end;

procedure TBLPath.AddPolygon(const APoly: TBLArrayView<TBLPoint>;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.PolygonD, @APoly, ATransform, ADir);
end;

procedure TBLPath.AddPolygon(const APoly: TBLArrayView<TBLPoint>;
  const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.PolygonD, @APoly, ADir);
end;

procedure TBLPath.AddPolygon(const APoly: TArray<TBLPoint>;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLPoint>;
  View.Reset(Pointer(APoly), Length(APoly));
  AddPolygon(View, ATransform, ADir);
end;

procedure TBLPath.AddPolyline(const APoly: TArray<TBLPointI>;
  const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLPointI>;
  View.Reset(Pointer(APoly), Length(APoly));
  AddPolyline(View, ADir);
end;

procedure TBLPath.AddPolyline(const APoly: PBLPointI; const ACount: NativeInt;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLPointI>;
  View.Reset(Pointer(APoly), ACount);
  AddPolyline(View, ATransform, ADir);
end;

procedure TBLPath.AddPolyline(const APoly: PBLPointI; const ACount: NativeInt;
  const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLPointI>;
  View.Reset(Pointer(APoly), ACount);
  AddPolyline(View, ADir);
end;

procedure TBLPath.AddPolyline(const APoly: TBLArrayView<TBLPointI>;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.PolylineI, @APoly, ATransform, ADir);
end;

procedure TBLPath.AddPolyline(const APoly: TBLArrayView<TBLPointI>;
  const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.PolylineI, @APoly, ADir);
end;

procedure TBLPath.AddPolyline(const APoly: TArray<TBLPointI>;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLPointI>;
  View.Reset(Pointer(APoly), Length(APoly));
  AddPolyline(View, ATransform, ADir);
end;

procedure TBLPath.AddPolyline(const APoly: TArray<TBLPoint>;
  const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLPoint>;
  View.Reset(Pointer(APoly), Length(APoly));
  AddPolyline(View, ADir);
end;

procedure TBLPath.AddPolyline(const APoly: PBLPoint; const ACount: NativeInt;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLPoint>;
  View.Reset(Pointer(APoly), ACount);
  AddPolyline(View, ATransform, ADir);
end;

procedure TBLPath.AddPolyline(const APoly: PBLPoint; const ACount: NativeInt;
  const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLPoint>;
  View.Reset(Pointer(APoly), ACount);
  AddPolyline(View, ADir);
end;

procedure TBLPath.AddPolyline(const APoly: TBLArrayView<TBLPoint>;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.PolylineD, @APoly, ATransform, ADir);
end;

procedure TBLPath.AddPolyline(const APoly: TBLArrayView<TBLPoint>;
  const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.PolylineD, @APoly, ADir);
end;

procedure TBLPath.AddPolyline(const APoly: TArray<TBLPoint>;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLPoint>;
  View.Reset(Pointer(APoly), Length(APoly));
  AddPolyline(View, ATransform, ADir);
end;

procedure TBLPath.AddPie(const APie: TBLArc; const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.Pie, @APie, ADir);
end;

procedure TBLPath.AddQuadToSegments(const APoints: PBLPoint;
  const ASegmentCount: NativeInt);
begin
  var CmdPtr: PByte;
  var VtxPtr: PBLPoint;
  var PointCount: NativeInt := ASegmentCount shl 1;
  _BLCheck(_blPathModifyOp(@Self, Ord(TBLModifyOp.AppendGrow), PointCount, @CmdPtr, @VtxPtr));

  for var I := 0 to ASegmentCount - 1 do
  begin
    CmdPtr^ := Ord(TBLPathCmd.Quad);
    Inc(CmdPtr);
    CmdPtr^ := Ord(TBLPathCmd.OnPath);
    Inc(CmdPtr);
  end;

  Move(APoints^, VtxPtr^, PointCount * SizeOf(TBLPoint));
end;

procedure TBLPath.AddRect(const ARect: TBLRectI;
  const ADir: TBLGeometryDirection);
begin
  _BLCheck(_blPathAddRectI(@Self, @ARect, Ord(ADir)));
end;

procedure TBLPath.AddRect(const ARect: TBLRect;
  const ADir: TBLGeometryDirection);
begin
  _BLCheck(_blPathAddRectD(@Self, @ARect, Ord(ADir)));
end;

procedure TBLPath.AddRect(const AX, AY, AW, AH: Double;
  const ADir: TBLGeometryDirection);
begin
  var R: TBLRect;
  R.Reset(AX, AY, AW, AH);
  _BLCheck(_blPathAddRectD(@Self, @R, Ord(ADir)));
end;

procedure TBLPath.AddRectArray(const AArray: TArray<TBLRectI>;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLRectI>;
  View.Reset(Pointer(AArray), Length(AArray));
  AddGeometry(TBLGeometryType.ArrayViewRectI, @View, ATransform, ADir);
end;

procedure TBLPath.AddRectArray(const AArray: PBLRectI; const ACount: NativeInt;
  const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLRectI>;
  View.Reset(Pointer(AArray), ACount);
  AddGeometry(TBLGeometryType.ArrayViewRectI, @View, ADir);
end;

procedure TBLPath.AddRectArray(const AArray: PBLRectI; const ACount: NativeInt;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLRectI>;
  View.Reset(Pointer(AArray), ACount);
  AddGeometry(TBLGeometryType.ArrayViewRectI, @View, ATransform, ADir);
end;

procedure TBLPath.AddRectArray(const AArray: TBLArrayView<TBLRectI>;
  const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.ArrayViewRectI, @AArray, ADir);
end;

procedure TBLPath.AddRectArray(const AArray: TBLArrayView<TBLRectI>;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.ArrayViewRectI, @AArray, ATransform, ADir);
end;

procedure TBLPath.AddRectArray(const AArray: TArray<TBLRectI>;
  const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLRectI>;
  View.Reset(Pointer(AArray), Length(AArray));
  AddGeometry(TBLGeometryType.ArrayViewRectI, @View, ADir);
end;

procedure TBLPath.AddRectArray(const AArray: TArray<TBLRect>;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLRect>;
  View.Reset(Pointer(AArray), Length(AArray));
  AddGeometry(TBLGeometryType.ArrayViewRectD, @View, ATransform, ADir);
end;

procedure TBLPath.AddRectArray(const AArray: PBLRect; const ACount: NativeInt;
  const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLRect>;
  View.Reset(Pointer(AArray), ACount);
  AddGeometry(TBLGeometryType.ArrayViewRectD, @View, ADir);
end;

procedure TBLPath.AddRectArray(const AArray: PBLRect; const ACount: NativeInt;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLRect>;
  View.Reset(Pointer(AArray), ACount);
  AddGeometry(TBLGeometryType.ArrayViewRectD, @View, ATransform, ADir);
end;

procedure TBLPath.AddReversedPath(const APath: TBLPath; const ARange: TBLRange;
  const AReverseMode: TBLPathReverseMode);
begin
  _BLCheck(_blPathAddReversedPath(@Self, @APath, @ARange, Ord(AReverseMode)));
end;

procedure TBLPath.AddReversedPath(const APath: TBLPath;
  const AReverseMode: TBLPathReverseMode);
begin
  _BLCheck(_blPathAddReversedPath(@Self, @APath, nil, Ord(AReverseMode)));
end;

procedure TBLPath.AddRectArray(const AArray: TBLArrayView<TBLRect>;
  const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.ArrayViewRectD, @AArray, ADir);
end;

procedure TBLPath.AddRectArray(const AArray: TBLArrayView<TBLRect>;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.ArrayViewRectD, @AArray, ATransform, ADir);
end;

procedure TBLPath.AddRectArray(const AArray: TArray<TBLRect>;
  const ADir: TBLGeometryDirection);
begin
  var View: TBLArrayView<TBLRect>;
  View.Reset(Pointer(AArray), Length(AArray));
  AddGeometry(TBLGeometryType.ArrayViewRectD, @View, ADir);
end;

procedure TBLPath.AddRoundRect(const ARR: TBLRoundRect;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.RoundRect, @ARR, ATransform, ADir);
end;

procedure TBLPath.AddStrokedPath(const APath: TBLPath; const ARange: TBLRange;
  const AStrokeOptions: TBLStrokeOptions;
  const AApproximationOptions: TBLApproximationOptions);
begin
  _BLCheck(_blPathAddStrokedPath(@Self, @APath, @ARange, @AStrokeOptions, @AApproximationOptions));
end;

procedure TBLPath.AddStrokedPath(const APath: TBLPath;
  const AStrokeOptions: TBLStrokeOptions;
  const AApproximationOptions: TBLApproximationOptions);
begin
  _BLCheck(_blPathAddStrokedPath(@Self, @APath, nil, @AStrokeOptions, @AApproximationOptions));
end;

procedure TBLPath.AddTriangle(const ATriangle: TBLTriangle;
  const ATransform: TBLMatrix2D; const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.Triangle, @ATriangle, ATransform, ADir);
end;

procedure TBLPath.AddTriangle(const ATriangle: TBLTriangle;
  const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.Triangle, @ATriangle, ADir);
end;

procedure TBLPath.AddRoundRect(const ARR: TBLRoundRect;
  const ADir: TBLGeometryDirection);
begin
  AddGeometry(TBLGeometryType.RoundRect, @ARR, ADir);
end;

procedure TBLPath.AddQuadToSegments(const APoints: TArray<TBLPoint>);
begin
  Assert((Length(APoints) and 1) = 0);
  AddQuadToSegments(Pointer(APoints), Length(APoints) shr 1);
end;

procedure TBLPath.AddLineToSegments(const APoints: TArray<TBLPoint>);
begin
  AddLineToSegments(Pointer(APoints), Length(APoints));
end;

procedure TBLPath.ArcQuadrantTo(const AX1, AY1, AX2, AY2: Double);
begin
  _BLCheck(_blPathArcQuadrantTo(@Self, AX1, AY1, AX2, AY2));
end;

procedure TBLPath.ArcQuadrantTo(const AP1, AP2: TBLPoint);
begin
  _BLCheck(_blPathArcQuadrantTo(@Self, AP1.X, AP1.Y, AP2.X, AP2.Y));
end;

procedure TBLPath.ArcTo(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AForceMoveTo: Boolean);
begin
  _BLCheck(_blPathArcTo(@Self, ACX, ACY, ARX, ARY, AStart, ASweep, AForceMoveTo));
end;

procedure TBLPath.ArcTo(const AC, AR: TBLPoint; const AStart, ASweep: Double;
  const AForceMoveTo: Boolean);
begin
  _BLCheck(_blPathArcTo(@Self, AC.X, AC.Y, AR.X, AR.Y, AStart, ASweep, AForceMoveTo));
end;

class operator TBLPath.Assign(var ADest: TBLPath; const [ref] ASrc: TBLPath);
begin
  _BLCheck(_blPathInitWeak(@ADest, @ASrc));
end;

procedure TBLPath.AssignDeep(const AOther: TBLPath);
begin
  _BLCheck(_blPathAssignDeep(@Self, @AOther));
end;

procedure TBLPath.Clear;
begin
  _BLCheck(_blPathClear(@Self));
end;

procedure TBLPath.Close;
begin
  _BLCheck(_blPathClose(@Self));
end;

procedure TBLPath.ConicTo(const AX1, AY1, AX2, AY2, AWeight: Double);
begin
  _BLCheck(_blPathConicTo(@Self, AX1, AY1, AX2, AY2, AWeight));
end;

procedure TBLPath.ConicTo(const AP1, AP2: TBLPoint; const AWeight: Double);
begin
  _BLCheck(_blPathConicTo(@Self, AP1.X, AP1.Y, AP2.X, AP2.Y, AWeight));
end;

procedure TBLPath.CubicTo(const AP1, AP2, AP3: TBLPoint);
begin
  _BLCheck(_blPathCubicTo(@Self, AP1.X, AP1.Y, AP2.X, AP2.Y, AP3.X, AP3.Y));
end;

procedure TBLPath.CubicTo(const AX1, AY1, AX2, AY2, AX3, AY3: Double);
begin
  _BLCheck(_blPathCubicTo(@Self, AX1, AY1, AX2, AY2, AX3, AY3));
end;

class operator TBLPath.Equal(const ALeft: TBLPath;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsEmpty) then
    Result := (ARight = nil)
  else
    Result := (ARight <> nil);
end;

procedure TBLPath.EllipticArcTo(const ARX, ARY, AXAxisRotation: Double;
  const ALargeArcFlag, ASweepFlag: Boolean; const AX1, AY1: Double);
begin
  _BLCheck(_blPathEllipticArcTo(@Self, ARX, ARY, AXAxisRotation, ALargeArcFlag,
    ASweepFlag, AX1, AY1));
end;

procedure TBLPath.EllipticArcTo(const ARP: TBLPoint;
  const AXAxisRotation: Double; const ALargeArcFlag, ASweepFlag: Boolean;
  const AP1: TBLPoint);
begin
  _BLCheck(_blPathEllipticArcTo(@Self, ARP.X, ARP.Y, AXAxisRotation,
    ALargeArcFlag, ASweepFlag, AP1.X, AP1.Y));
end;

class operator TBLPath.Equal(const ALeft, ARight: TBLPath): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLPath.Equals(const AOther: TBLPath): Boolean;
begin
  Result := _blPathEquals(@Self, @AOther);
end;

class operator TBLPath.Finalize(var ADest: TBLPath);
begin
  _BLCheck(_blPathDestroy(@ADest));
end;

procedure TBLPath.FitTo(const ARange: TBLRange; const ARect: TBLRect);
begin
  _BLCheck(_blPathFitTo(@Self, @ARange, @ARect, 0));
end;

procedure TBLPath.FitTo(const ARect: TBLRect);
begin
  _BLCheck(_blPathFitTo(@Self, nil, @ARect, 0));
end;

function TBLPath.GetBoundingBox: TBLBox;
begin
  _BLCheck(_blPathGetBoundingBox(@Self, @Result));
end;

function TBLPath.GetCapacity: NativeInt;
begin
  Result := _blPathGetCapacity(@Self);
end;

function TBLPath.GetClosestVertex(const AP: TBLPoint;
  const AMaxDistance: Double; out ADistanceOut: Double): NativeInt;
begin
  _BLCheck(_blPathGetClosestVertex(@Self, @AP, AMaxDistance, @Result, @ADistanceOut));
end;

function TBLPath.GetClosestVertex(const AP: TBLPoint;
  const AMaxDistance: Double): NativeInt;
begin
  var DistanceOut: Double;
  _BLCheck(_blPathGetClosestVertex(@Self, @AP, AMaxDistance, @Result, @DistanceOut));
end;

function TBLPath.GetCommandData: PByte;
begin
  Result := _blPathGetCommandData(@Self);
end;

function TBLPath.GetCommandDataEnd: PByte;
begin
  Result := _blPathGetCommandData(@Self);
  Inc(Result, Count);
end;

function TBLPath.GetControlBox: TBLBox;
begin
  _BLCheck(_blPathGetControlBox(@Self, @Result));
end;

function TBLPath.GetCount: NativeInt;
begin
  Result := _blPathGetSize(@Self);
end;

function TBLPath.GetFigureRange(const AIndex: Integer): TBLRange;
begin
  _BLCheck(_blPathGetFigureRange(@Self, AIndex, @Result));
end;

function TBLPath.GetInfoFlags: TBLPathFlags;
begin
  _BLCheck(_blPathGetInfoFlags(@Self, @Result));
end;

function TBLPath.GetIsEmpty: Boolean;
begin
  Result := (Count = 0);
end;

function TBLPath.GetLastVertex: TBLPoint;
begin
  _BLCheck(_blPathGetLastVertex(@Self, @Result));
end;

function TBLPath.GetVertexData: PBLPoint;
begin
  Result := _blPathGetVertexData(@Self);
end;

function TBLPath.GetVertexDataEnd: PBLPoint;
begin
  Result := _blPathGetVertexData(@Self);
  Inc(Result, Count);
end;

function TBLPath.HitTest(const AP: TBLPoint;
  const AFillRule: TBLFillRule): TBLHitTest;
begin
  Result := TBLHitTest(_blPathHitTest(@Self, @AP, Ord(AFillRule)));
end;

class operator TBLPath.Initialize(out ADest: TBLPath);
begin
  _BLCheck(_blPathInit(@ADest));
end;

procedure TBLPath.LineTo(const AX1, AY1: Double);
begin
  _BLCheck(_blPathLineTo(@Self, AX1, AY1));
end;

procedure TBLPath.LineTo(const AP1: TBLPoint);
begin
  _BLCheck(_blPathLineTo(@Self, AP1.X, AP1.Y));
end;

procedure TBLPath.ModifyOp(const AOp: TBLModifyOp; const ACount: NativeInt;
  out ACmdDataOut: PByte; out AVertexDataOut: PBLPoint);
begin
  _BLCheck(_blPathModifyOp(@Self, Ord(AOp), ACount, @ACmdDataOut, @AVertexDataOut));
end;

procedure TBLPath.MoveTo(const AP0: TBLPoint);
begin
  _BLCheck(_blPathMoveTo(@Self, AP0.X, AP0.Y));
end;

procedure TBLPath.MoveTo(const AX0, AY0: Double);
begin
  _BLCheck(_blPathMoveTo(@Self, AX0, AY0));
end;

class operator TBLPath.NotEqual(const ALeft: TBLPath;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsEmpty) then
    Result := (ARight <> nil)
  else
    Result := (ARight = nil);
end;

class operator TBLPath.NotEqual(const ALeft, ARight: TBLPath): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLPath.PolyTo(const APoly: TArray<TBLPoint>);
begin
  _BLCheck(_blPathPolyTo(@Self, Pointer(APoly), Length(APoly)));
end;

procedure TBLPath.QuadTo(const AX1, AY1, AX2, AY2: Double);
begin
  _BLCheck(_blPathQuadTo(@Self, AX1, AY1, AX2, AY2));
end;

procedure TBLPath.QuadTo(const AP1, AP2: TBLPoint);
begin
  _BLCheck(_blPathQuadTo(@Self, AP1.X, AP1.Y, AP2.X, AP2.Y));
end;

procedure TBLPath.PolyTo(const APoly: PBLPoint; const ACount: NativeInt);
begin
  _BLCheck(_blPathPolyTo(@Self, APoly, ACount));
end;

procedure TBLPath.RemoveRange(const ARange: TBLRange);
begin
  _BLCheck(_blPathRemoveRange(@Self, @ARange));
end;

procedure TBLPath.Reserve(const AMinCapacity: NativeInt);
begin
  _BLCheck(_blPathReserve(@Self, AMinCapacity));
end;

procedure TBLPath.Reset;
begin
  _BLCheck(_blPathReset(@Self));
end;

procedure TBLPath.SetVertexAt(const AIndex: NativeInt; const ACmd: TBLPathCmd;
  const AX, AY: Double);
begin
  _BLCheck(_blPathSetVertexAt(@Self, AIndex, Ord(ACmd), AX, AY));
end;

procedure TBLPath.SetVertexAt(const AIndex: NativeInt; const ACmd: TBLPathCmd;
  const APt: TBLPoint);
begin
  _BLCheck(_blPathSetVertexAt(@Self, AIndex, Ord(ACmd), APt.X, APt.Y));
end;

procedure TBLPath.Shrink;
begin
  _BLCheck(_blPathShrink(@Self));
end;

procedure TBLPath.SmoothCubicTo(const AX2, AY2, AX3, AY3: Double);
begin
  _BLCheck(_blPathSmoothCubicTo(@Self, AX2, AY2, AX3, AY3));
end;

procedure TBLPath.SmoothCubicTo(const AP2, AP3: TBLPoint);
begin
  _BLCheck(_blPathSmoothCubicTo(@Self, AP2.X, AP2.Y, AP3.X, AP3.Y));
end;

procedure TBLPath.SmoothQuadTo(const AX2, AY2: Double);
begin
  _BLCheck(_blPathSmoothQuadTo(@Self, AX2, AY2));
end;

procedure TBLPath.SmoothQuadTo(const AP2: TBLPoint);
begin
  _BLCheck(_blPathSmoothQuadTo(@Self, AP2.X, AP2.Y));
end;

procedure TBLPath.Swap(var AOther: TBLPath);
begin
  FBase.Swap(AOther.FBase);
end;

procedure TBLPath.Transform(const ARange: TBLRange; const AM: TBLMatrix2D);
begin
  _BLCheck(_blPathTransform(@Self, @ARange, @AM));
end;

procedure TBLPath.Transform(const AM: TBLMatrix2D);
begin
  _BLCheck(_blPathTransform(@Self, nil, @AM));
end;

procedure TBLPath.Translate(const ARange: TBLRange; const AP: TBLPoint);
begin
  _BLCheck(_blPathTranslate(@Self, @ARange, @AP));
end;

procedure TBLPath.Translate(const AP: TBLPoint);
begin
  _BLCheck(_blPathTranslate(@Self, nil, @AP));
end;

function TBLPath.View: TBLPathView;
type
  PBLPathView = ^TBLPathview;
begin
  Result := PBLPathView(FBase.FImpl)^;
end;

{$ENDREGION 'Geometries'}

{$REGION 'Containers'}

{ TBLArrayView<T> }

class constructor TBLArrayView<T>.Create;
begin
  Assert(not System.HasWeakRef(T));
end;

constructor TBLArrayView<T>.Create(const ADataIn: P; const ACountIn: NativeInt);
begin
  FData := ADataIn;
  FCount := ACountIn;
end;

function TBLArrayView<T>.First: P;
begin
  Result := FData;
end;

function TBLArrayView<T>.GetItem(const AIndex: NativeInt): T;
begin
  Assert(NativeUInt(AIndex) < NativeUInt(FCount));
  Result := FData[AIndex];
end;

function TBLArrayView<T>.GetRef(const AIndex: NativeInt): P;
begin
  Assert(NativeUInt(AIndex) < NativeUInt(FCount));
  Result := FData + AIndex;
end;

class operator TBLArrayView<T>.Initialize(out ADest: TBLArrayView<T>);
begin
  ADest.FData := nil;
  ADest.FCount := 0;
end;

function TBLArrayView<T>.Last: P;
begin
  Result := FData + FCount - 1;
end;

procedure TBLArrayView<T>.Reset;
begin
  FData := nil;
  FCount := 0;
end;

procedure TBLArrayView<T>.Reset(const ADataIn: P; const ACountIn: NativeInt);
begin
  FData := ADataIn;
  FCount := ACountIn;
end;

{ TBLRange }

class operator TBLRange.Equal(const ALeft, ARight: TBLRange): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLRange.Equals(const AOther: TBLRange): Boolean;
begin
  Result := (Start = AOther.Start) and (Stop = AOther.Stop);
end;

class operator TBLRange.NotEqual(const ALeft, ARight: TBLRange): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLRange.Reset(const AStart, AStop: NativeInt);
begin
  Start := AStart;
  Stop := AStop;
end;

procedure TBLRange.Reset;
begin
  Start := 0;
  Stop := 0;
end;

{ TBLArray<T> }

class operator TBLArray<T>.Assign(var ADest: TBLArray<T>;
  const [ref] ASrc: TBLArray<T>);
begin
  _BLCheck(_blArrayInitWeak(@ADest, @ASrc));
end;

procedure TBLArray<T>.Append(const AItems: array of T);
begin
  Modify(TBLModifyOp.AppendGrow, AItems);
end;

procedure TBLArray<T>.AppendData(const AItems: P; const ACount: NativeInt);
begin
  _BLCheck(_blArrayAppendData(@Self, AItems, ACount));
end;

procedure TBLArray<T>.AppendData(const AView: TBLArrayView<T>);
begin
  _BLCheck(_blArrayAppendData(@Self, AView.FData, AView.FCount));
end;

procedure TBLArray<T>.Append(const AItem: T);
begin
  _BLCheck(_blArrayAppendItem(@Self, @AItem));
end;

procedure TBLArray<T>.Assign(const AItems: array of T);
begin
  Modify(TBLModifyOp.AssignFit, AItems);
end;

procedure TBLArray<T>.AssignData(const AView: TBLArrayView<T>);
begin
  _BLCheck(_blArrayAssignData(@Self, AView.FData, AView.FCount));
end;

procedure TBLArray<T>.AssignData(const AItems: P; const ACount: NativeInt);
begin
  _BLCheck(_blArrayAssignData(@Self, AItems, ACount));
end;

procedure TBLArray<T>.AssignDeep(const AOther: TBLArray<T>);
begin
  _BLCheck(_blArrayAssignDeep(@Self, @AOther));
end;

procedure TBLArray<T>.AssignExternalData(const AData: P; const ACount,
  ACapacity: NativeInt; const AAccessFlags: TBLDataAccessFlags;
  const ADestroyFunc: TBLDestroyExternalDataFunc; const AUserData: Pointer);
begin
  _BLCheck(_blArrayAssignExternalData(@Self, AData, ACount, ACapacity,
    Ord(AAccessFlags), ADestroyFunc, AUserData));
end;

function TBLArray<T>.At(const AIndex: NativeInt): T;
begin
  Assert(NativeUInt(AIndex) < NativeUInt(Count));
  var Data := P(_blArrayGetData(@Self));
  Result := Data[AIndex];
end;

procedure TBLArray<T>.Clear;
begin
  _BLCheck(_blArrayClear(@Self));
end;

class constructor TBLArray<T>.Create;
begin
  Assert(not System.HasWeakRef(T));

  FArrayType := TBLObjectType.Null;

  var Info := PTypeInfo(TypeInfo(T));
  var Data := GetTypeData(Info);

  case Info.Kind of
    tkInteger,
    tkEnumeration:
      case Data.OrdType of
        otSByte: FArrayType := TBLObjectType.ArrayInt8;
        otUByte: FArrayType := TBLObjectType.ArrayUInt8;
        otSWord: FArrayType := TBLObjectType.ArrayInt16;
        otUWord: FArrayType := TBLObjectType.ArrayUInt16;
        otSLong: FArrayType := TBLObjectType.ArrayInt32;
        otULong: FArrayType := TBLObjectType.ArrayUInt32;
      end;

    tkInt64:
      if (Data.MaxInt64Value > Data.MinInt64Value) then
        FArrayType := TBLObjectType.ArrayInt64
      else
        FArrayType := TBLObjectType.ArrayUInt64;

    tkFloat:
      case Data.FloatType of
        ftSingle: FArrayType := TBLObjectType.ArrayFloat32;
        ftDouble: FArrayType := TBLObjectType.ArrayFloat64;
      end;

    tkRecord:
      begin
        case SizeOf(T) of
          1: FArrayType := TBLObjectType.ArrayStruct1;
          2: FArrayType := TBLObjectType.ArrayStruct2;
          3: FArrayType := TBLObjectType.ArrayStruct3;
          4: FArrayType := TBLObjectType.ArrayStruct4;
          6: FArrayType := TBLObjectType.ArrayStruct6;
          8: FArrayType := TBLObjectType.ArrayStruct8;
         10: FArrayType := TBLObjectType.ArrayStruct10;
         12: FArrayType := TBLObjectType.ArrayStruct12;
         16: FArrayType := TBLObjectType.ArrayStruct16;
         20: FArrayType := TBLObjectType.ArrayStruct20;
         24: FArrayType := TBLObjectType.ArrayStruct24;
         32: FArrayType := TBLObjectType.ArrayStruct32;
        end;
      end;

    tkMRecord:
      if (SizeOf(T) = 16) then
      begin
         { Check if this record is compatible with TBLObject. That is, it
           has a single field with name 'FBase' of type TBLObjectCore. }
         var P := PByte(@Data.ManagedFldCount);
         Inc(P, SizeOf(Integer)); // Skip ManagedFldCount field

         // Skip ManagedFields
         var Count := Data.ManagedFldCount;
         Inc(P, Count * SizeOf(TManagedField));

         Count := P^; // NumOps
         Inc(P); // Skip NumOps field
         Inc(P, Count * SizeOf(Pointer)); // Skip RecOps

         Count := PInteger(P)^; // RecFldCnt
         if (Count = 1) then
         begin
           Inc(P, SizeOf(Integer)); // Skip RecFldCnt
           var RecType := PRecordTypeField(P);
           if (RecType.NameFld.ToString = 'FBase') then
             FArrayType := TBLObjectType.ArrayObject;
         end;
      end;
  end;
  Assert(FArrayType <> TBLObjectType.Null, 'Unsupported array element type: ' + String(Info.Name));
end;

class operator TBLArray<T>.Equal(const ALeft: TBLArray<T>;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.Count = 0) then
    Result := (ARight = nil)
  else
    Result := (ARight <> nil);
end;

class operator TBLArray<T>.Equal(const ALeft, ARight: TBLArray<T>): Boolean;
begin
  Result := _blArrayEquals(@ALeft, @ARight);
end;

function TBLArray<T>.Equals(const AOther: TBLArray<T>): Boolean;
begin
  Result := _blArrayEquals(@Self, @AOther);
end;

class operator TBLArray<T>.Finalize(var ADest: TBLArray<T>);
begin
  if (ADest.FBase.NeedsCleanup) then
    _BLCheck(_blArrayDestroy(@ADest));
end;

function TBLArray<T>.First: P;
begin
  Result := RefAt(0);
end;

function TBLArray<T>.GetCapacity: NativeInt;
begin
  Result := _blArrayGetCapacity(@Self);
end;

function TBLArray<T>.GetCount: NativeInt;
begin
  Result := _blArrayGetSize(@Self);
end;

function TBLArray<T>.GetData: P;
begin
  Result := _blArrayGetData(@Self);
end;

function TBLArray<T>.GetIsEmpty: Boolean;
begin
  Result := (Count = 0);
end;

function TBLArray<T>.GetItem(const AIndex: NativeInt): T;
begin
  Result := At(AIndex);
end;

function TBLArray<T>.GetRef(const AIndex: NativeInt): P;
begin
  Result := RefAt(AIndex);
end;

function TBLArray<T>.IndexOf(const AItem: T): NativeInt;
begin
  Result := IndexOf(AItem, 0);
end;

function TBLArray<T>.IndexOf(const AItem: T;
  const AFromIndex: NativeInt): NativeInt;
begin
  var P := GetData;
  var IEnd := GetCount;
  for var I: NativeInt := AFromIndex to IEnd - 1 do
  begin
    if (_TBLGenericUtils<T>.AreEqual(P^, AItem)) then
      Exit(I);
    Inc(P);
  end;
  Result := -1;
end;

class operator TBLArray<T>.Initialize(out ADest: TBLArray<T>);
begin
  _BLCheck(_blArrayInit(@ADest, Ord(FArrayType)));
end;

procedure TBLArray<T>.Insert(const AIndex: NativeInt; const AItems: array of T);
begin
  var Dst: P;
  _BLCheck(_blArrayInsertOp(@Self, AIndex, Length(AItems), @Dst));
  _TBLGenericUtils<T>.CopyToUnitialized(Dst, AItems, FArrayType);
end;

procedure TBLArray<T>.InsertData(const AIndex: NativeInt; const AItems: P;
  const ACount: NativeInt);
begin
  _BLCheck(_blArrayInsertData(@Self, AIndex, AItems, ACount));
end;

procedure TBLArray<T>.InsertData(const AIndex: NativeInt;
  const AView: TBLArrayView<T>);
begin
  _BLCheck(_blArrayInsertData(@Self, AIndex, AView.FData, AView.FCount));
end;

procedure TBLArray<T>.Insert(const AIndex: NativeInt; const AItem: T);
begin
  _BLCheck(_blArrayInsertItem(@Self, AIndex, @AItem));
end;

function TBLArray<T>.InsertOp(const AIndex, ACount: NativeInt): P;
begin
  _BLCheck(_blArrayInsertOp(@Self, AIndex, ACount, @Result));
end;

function TBLArray<T>.Last: P;
begin
  Result := RefAt(Count - 1);
end;

function TBLArray<T>.LastIndexOf(const AItem: T;
  const AFromIndex: NativeInt): NativeInt;
begin
  var P := GetData;
  var I := GetCount - 1;
  if (I < 0) then
    Exit(-1);

  I := Min(I, AFromIndex);
  Inc(P, I);
  while (not _TBLGenericUtils<T>.AreEqual(P^, AItem)) and (I >= 0) do
  begin
    Dec(P);
    Dec(I);
  end;

  Result := I;
end;

function TBLArray<T>.LastIndexOf(const AItem: T): NativeInt;
begin
  var P := GetData;
  var Count := GetCount;
  Inc(P, Count - 1);
  for var I: NativeInt := Count - 1 downto 0 do
  begin
    if (_TBLGenericUtils<T>.AreEqual(P^, AItem)) then
      Exit(I);
    Dec(P);
  end;
  Result := -1;
end;

function TBLArray<T>.MakeMutable: P;
begin
  _BLCheck(_blArrayMakeMutable(@Self, @Result));
end;

procedure TBLArray<T>.Modify(const AOp: TBLModifyOp; const AItems: array of T);
begin
  var Dst: P;
  _BLCheck(_blArrayModifyOp(@Self, Ord(AOp), Length(AItems), @Dst));
  _TBLGenericUtils<T>.CopyToUnitialized(Dst, AItems, FArrayType);
end;

function TBLArray<T>.ModifyOp(const AOp: TBLModifyOp;
  const ACount: NativeInt): P;
begin
  _BLCheck(_blArrayModifyOp(@Self, Ord(AOp), ACount, @Result));
end;

class operator TBLArray<T>.NotEqual(const ALeft: TBLArray<T>;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.Count = 0) then
    Result := (ARight <> nil)
  else
    Result := (ARight = nil);
end;

class operator TBLArray<T>.NotEqual(const ALeft, ARight: TBLArray<T>): Boolean;
begin
  Result := not _blArrayEquals(@ALeft, @ARight);
end;

procedure TBLArray<T>.Prepend(const AItem: T);
begin
  _BLCheck(_blArrayInsertItem(@Self, 0, @AItem));
end;

procedure TBLArray<T>.Prepend(const AItems: array of T);
begin
  Insert(0, AItems);
end;

procedure TBLArray<T>.PrependData(const AItems: P; const ACount: NativeInt);
begin
  _BLCheck(_blArrayInsertData(@Self, 0, AItems, ACount));
end;

procedure TBLArray<T>.PrependData(const AView: TBLArrayView<T>);
begin
  _BLCheck(_blArrayInsertData(@Self, 0, AView.FData, AView.FCount));
end;

function TBLArray<T>.RefAt(const AIndex: NativeInt): P;
begin
  Assert(NativeUInt(AIndex) < NativeUInt(Count));
  var Data := P(_blArrayGetData(@Self));
  Result := Data + AIndex;
end;

procedure TBLArray<T>.Remove(const ARange: TBLRange);
begin
  _BLCheck(_blArrayRemoveRange(@Self, ARange.Start, ARange.Stop));
end;

procedure TBLArray<T>.Remove(const AIndex: NativeInt);
begin
  _BLCheck(_blArrayRemoveIndex(@Self, AIndex));
end;

procedure TBLArray<T>.Replace(const AIndex: NativeInt; const AItem: T);
begin
  _BLCheck(_blArrayReplaceItem(@Self, AIndex, @AItem));
end;

procedure TBLArray<T>.ReplaceData(const ARange: TBLRange; const AItems: P;
  const ACount: NativeInt);
begin
  _BLCheck(_blArrayReplaceData(@Self, ARange.Start, ARange.Stop, AItems, ACount));
end;

procedure TBLArray<T>.ReplaceData(const ARange: TBLRange;
  const AView: TBLArrayView<T>);
begin
  _BLCheck(_blArrayReplaceData(@Self, ARange.Start, ARange.Stop, AView.FData, AView.FCount));
end;

procedure TBLArray<T>.Reserve(const AMinCapacity: NativeInt);
begin
  _BLCheck(_blArrayReserve(@Self, AMinCapacity));
end;

procedure TBLArray<T>.Reset;
begin
  _BLCheck(_blArrayReset(@Self));
end;

procedure TBLArray<T>.Resize(const ACount: NativeInt; const AFill: T);
begin
  _BLCheck(_blArrayResize(@Self, ACount, @AFill));
end;

procedure TBLArray<T>.SetItem(const AIndex: NativeInt; const AValue: T);
begin
  _BLCheck(_blArrayReplaceItem(@Self, AIndex, @AValue));
end;

procedure TBLArray<T>.Shrink;
begin
  _BLCheck(_blArrayShrink(@Self));
end;

procedure TBLArray<T>.Swap(var AOther: TBLArray<T>);
begin
  FBase.Swap(AOther.FBase);
end;

function TBLArray<T>.ToArray: TArray<T>;
begin
  SetLength(Result, Count);
  if (FArrayType = TBLObjectType.ArrayObject) then
  begin
    { Call CMR operators }
    var Data := P(_blArrayGetData(@Self));
    for var I := 0 to Length(Result) - 1 do
    begin
      Result[I] := Data^;
      Inc(Data);
    end;
  end
  else
    Move(Data^, Result[0], Length(Result) * SizeOf(T));
end;

procedure TBLArray<T>.Truncate(const AMaxCount: NativeInt);
begin
  _BLCheck(_blArrayResize(@Self, Min(Count, AMaxCount), nil));
end;

function TBLArray<T>.View: TBLArrayView<T>;
begin
  Result.Reset(Data, Count);
end;

{ TBLString }

class operator TBLString.Assign(var ADest: TBLString; const [ref] ASrc: TBLString);
begin
  _BLCheck(_blStringInitWeak(@ADest, @ASrc));
end;

constructor TBLString.Create(const AView: TBLStringView);
begin
  _BLCheck(_blStringInitWithData(@Self, Pointer(AView.FData), AView.FCount));
end;

constructor TBLString.Create(const AStr: PUTF8Char; const ALength: NativeInt);
begin
  _BLCheck(_blStringInitWithData(@Self, AStr, ALength));
end;

function TBLString.Compare(const AOther: TBLString): Integer;
begin
  Result := _blStringCompare(@Self, @AOther);
end;

function TBLString.Compare(const AOther: TBLStringView): Integer;
begin
  Result := _blStringCompareData(@Self, Pointer(AOther.FData), AOther.FCount);
end;

function TBLString.Compare(const AOther: PUTF8Char;
  const ALength: NativeInt): Integer;
begin
  Result := _blStringCompareData(@Self, AOther, ALength);
end;

function TBLString.Compare(const AOther: UTF8String): Integer;
begin
  Result := Compare(PUTF8Char(AOther), System.Length(AOther));
end;

procedure TBLString.Assign(const AChar: UTF8Char; const ACount: NativeInt);
begin
  _BLCheck(_blStringApplyOpChar(@Self, Ord(TBLModifyOp.AssignFit), AChar, ACount));
end;

procedure TBLString.Assign(const AView: TBLStringView);
begin
  _BLCheck(_blStringAssignData(@Self, Pointer(AView.FData), AView.FCount));
end;

procedure TBLString.Append(const AChar: UTF8Char; const ACount: NativeInt);
begin
  _BLCheck(_blStringApplyOpChar(@Self, Ord(TBLModifyOp.AppendGrow), AChar, ACount));
end;

procedure TBLString.Append(const AOther: TBLString);
begin
  _BLCheck(_blStringApplyOpString(@Self, Ord(TBLModifyOp.AppendGrow), @AOther));
end;

procedure TBLString.Append(const AView: TBLStringView);
begin
  _BLCheck(_blStringApplyOpData(@Self, Ord(TBLModifyOp.AppendGrow), Pointer(AView.FData), AView.FCount));
end;

procedure TBLString.Append(const AStr: PUTF8Char; const ALength: NativeInt);
begin
  _BLCheck(_blStringApplyOpData(@Self, Ord(TBLModifyOp.AppendGrow), AStr, ALength));
end;

procedure TBLString.Append(const AStr: UTF8String);
begin
  _BLCheck(_blStringApplyOpData(@Self, Ord(TBLModifyOp.AppendGrow), PUTF8Char(AStr), System.Length(AStr)));
end;

procedure TBLString.Append(const AStr: String);
begin
  Append(UTF8String(AStr));
end;

procedure TBLString.AppendFormat(const AFmt: String;
  const AArgs: array of const);
begin
  Append(Format(AFmt, AArgs));
end;

procedure TBLString.Assign(const AStr: PUTF8Char; const ALength: NativeInt);
begin
  _BLCheck(_blStringAssignData(@Self, AStr, ALength));
end;

procedure TBLString.AssignDeep(const AOther: TBLString);
begin
  _BLCheck(_blStringAssignDeep(@Self, @AOther));
end;

procedure TBLString.AssignFormat(const AFmt: String;
  const AArgs: array of const);
begin
  var Formatted := Format(AFmt, AArgs);
  var S := UTF8String(Formatted);
  _BLCheck(_blStringAssignData(@Self, PUTF8Char(S), System.Length(S)));
end;

function TBLString.At(const AIndex: NativeInt): UTF8Char;
begin
  Assert(NativeUInt(AIndex) < NativeUInt(GetLength));
  Result := Data[AIndex];
end;

procedure TBLString.Clear;
begin
  _BLCheck(_blStringClear(@Self));
end;

function TBLString.Compare(const AOther: String): Integer;
begin
  var S := UTF8String(AOther);
  Result := Compare(PUTF8Char(S), System.Length(S));
end;

constructor TBLString.Create(const AStr: UTF8String);
begin
  _BLCheck(_blStringInitWithData(@Self, Pointer(AStr), System.Length(AStr)));
end;

constructor TBLString.Create(const AStr: String);
begin
  var S := UTF8String(AStr);
  _BLCheck(_blStringInitWithData(@Self, Pointer(S), System.Length(S)));
end;

class operator TBLString.Equal(const ALeft: TBLString;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsEmpty) then
    Result := (ARight = nil)
  else
    Result := (ARight <> nil);
end;

class operator TBLString.Equal(const ALeft, ARight: TBLString): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLString.Equal(const ALeft: TBLString;
  const ARight: TBLStringView): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLString.Equal(const ALeft: TBLString;
  const ARight: PUTF8Char): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLString.Equal(const ALeft: TBLString;
  const ARight: UTF8String): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLString.Equal(const ALeft: TBLString;
  const ARight: String): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLString.Equals(const AOther: PUTF8Char;
  const ALength: NativeInt): Boolean;
begin
  Result := _blStringEqualsData(@Self, AOther, ALength);
end;

function TBLString.Equals(const AOther: TBLStringView): Boolean;
begin
  Result := _blStringEqualsData(@Self, Pointer(AOther.FData), AOther.FCount);
end;

function TBLString.Equals(const AOther: TBLString): Boolean;
begin
  Result := _blStringEquals(@Self, @AOther);
end;

function TBLString.Equals(const AOther: UTF8String): Boolean;
begin
  Result := Equals(PUTF8Char(AOther), System.Length(AOther));
end;

function TBLString.Equals(const AOther: String): Boolean;
begin
  var S := UTF8String(AOther);
  Result := Equals(PUTF8Char(S), System.Length(S));
end;

class operator TBLString.Finalize(var ADest: TBLString);
begin
  if (ADest.FBase.NeedsCleanup) then
    _BLCheck(_blStringDestroy(@ADest));
end;

function TBLString.GetCapacity: NativeInt;
begin
  Result := _blStringGetCapacity(@Self);
end;

function TBLString.GetChar(const AIndex: NativeInt): UTF8Char;
begin
  Result := At(AIndex);
end;

function TBLString.GetData: PUTF8Char;
begin
  Result := _blStringGetData(@Self);
end;

function TBLString.GetIsEmpty: Boolean;
begin
  Result := (Length = 0);
end;

function TBLString.GetLength: NativeInt;
begin
  Result := _blStringGetSize(@Self);
end;

class operator TBLString.GreaterThan(const ALeft, ARight: TBLString): Boolean;
begin
  Result := (ALeft.Compare(ARight) > 0);
end;

class operator TBLString.GreaterThan(const ALeft: TBLString;
  const ARight: TBLStringView): Boolean;
begin
  Result := (ALeft.Compare(ARight) > 0);
end;

class operator TBLString.GreaterThan(const ALeft: TBLString;
  const ARight: PUTF8Char): Boolean;
begin
  Result := (ALeft.Compare(ARight) > 0);
end;

class operator TBLString.GreaterThan(const ALeft: TBLString;
  const ARight: UTF8String): Boolean;
begin
  Result := (ALeft.Compare(ARight) > 0);
end;

class operator TBLString.GreaterThan(const ALeft: TBLString;
  const ARight: String): Boolean;
begin
  Result := (ALeft.Compare(ARight) > 0);
end;

class operator TBLString.GreaterThanOrEqual(const ALeft: TBLString;
  const ARight: UTF8String): Boolean;
begin
  Result := (ALeft.Compare(ARight) >= 0);
end;

class operator TBLString.GreaterThanOrEqual(const ALeft,
  ARight: TBLString): Boolean;
begin
  Result := (ALeft.Compare(ARight) >= 0);
end;

class operator TBLString.GreaterThanOrEqual(const ALeft: TBLString;
  const ARight: TBLStringView): Boolean;
begin
  Result := (ALeft.Compare(ARight) >= 0);
end;

class operator TBLString.GreaterThanOrEqual(const ALeft: TBLString;
  const ARight: PUTF8Char): Boolean;
begin
  Result := (ALeft.Compare(ARight) >= 0);
end;

class operator TBLString.GreaterThanOrEqual(const ALeft: TBLString;
  const ARight: String): Boolean;
begin
  Result := (ALeft.Compare(ARight) >= 0);
end;

class operator TBLString.Implicit(const AStr: String): TBLString;
begin
  var S := UTF8String(AStr);
  _BLCheck(_blStringInitWithData(@Result, Pointer(S), System.Length(S)));
end;

class operator TBLString.Implicit(const AStr: UTF8String): TBLString;
begin
  _BLCheck(_blStringInitWithData(@Result, Pointer(AStr), System.Length(AStr)));
end;

function TBLString.IndexOf(const AChar: UTF8Char): NativeInt;
begin
  Result := IndexOf(AChar, 0);
end;

function TBLString.IndexOf(const AChar: UTF8Char;
  const AFromIndex: NativeInt): NativeInt;
begin
  var IEnd := GetLength;
  var P := GetData;

  for var I := AFromIndex to IEnd - 1 do
  begin
    if (P[I] = AChar) then
      Exit(I);
  end;

  Result := -1;
end;

class operator TBLString.Initialize(out ADest: TBLString);
begin
  _BLCheck(_blStringInit(@ADest));
end;

procedure TBLString.Insert(const AIndex: NativeInt; const AView: TBLStringView);
begin
  _BLCheck(_blStringInsertData(@Self, AIndex, PUTF8Char(AView.FData), AView.FCount));
end;

procedure TBLString.Insert(const AIndex: NativeInt; const AOther: TBLString);
begin
  _BLCheck(_blStringInsertString(@Self, AIndex, @AOther));
end;

procedure TBLString.Insert(const AIndex: NativeInt; const AChar: UTF8Char;
  const ACount: NativeInt);
begin
  _BLCheck(_blStringInsertChar(@Self, AIndex, AChar, ACount));
end;

procedure TBLString.Insert(const AIndex: NativeInt; const AStr: String);
begin
  Insert(AIndex, UTF8String(AStr));
end;

procedure TBLString.Insert(const AIndex: NativeInt; const AStr: UTF8String);
begin
  _BLCheck(_blStringInsertData(@Self, AIndex, PUTF8Char(AStr), System.Length(AStr)));
end;

procedure TBLString.Insert(const AIndex: NativeInt; const AStr: PUTF8Char;
  const ALength: NativeInt);
begin
  _BLCheck(_blStringInsertData(@Self, AIndex, AStr, ALength));
end;

function TBLString.InsertOp(const AIndex, ALength: NativeInt): PUTF8Char;
begin
  _BLCheck(_blStringInsertOp(@Self, AIndex, ALength, @Result));
end;

class operator TBLString.LessThan(const ALeft, ARight: TBLString): Boolean;
begin
  Result := (ALeft.Compare(ARight) < 0);
end;

class operator TBLString.LessThan(const ALeft: TBLString;
  const ARight: TBLStringView): Boolean;
begin
  Result := (ALeft.Compare(ARight) < 0);
end;

class operator TBLString.LessThan(const ALeft: TBLString;
  const ARight: PUTF8Char): Boolean;
begin
  Result := (ALeft.Compare(ARight) < 0);
end;

class operator TBLString.LessThan(const ALeft: TBLString;
  const ARight: UTF8String): Boolean;
begin
  Result := (ALeft.Compare(ARight) < 0);
end;

function TBLString.LastIndexOf(const AChar: UTF8Char): NativeInt;
begin
  var I := GetLength - 1;
  var P := GetData;

  while (I >= 0) and (P[I] <> AChar) do
    Dec(I);

  Result := I;
end;

function TBLString.LastIndexOf(const AChar: UTF8Char;
  const AFromIndex: NativeInt): NativeInt;
begin
  var I := GetLength - 1;
  var P := GetData;

  if (I < 0) then
    Exit(-1);

  I := Min(I, AFromIndex);
  while (P[I] <> AChar) and (I >= 0) do
    Dec(I);

  Result := I;
end;

class operator TBLString.LessThan(const ALeft: TBLString;
  const ARight: String): Boolean;
begin
  Result := (ALeft.Compare(ARight) < 0);
end;

class operator TBLString.LessThanOrEqual(const ALeft: TBLString;
  const ARight: UTF8String): Boolean;
begin
  Result := (ALeft.Compare(ARight) <= 0);
end;

class operator TBLString.LessThanOrEqual(const ALeft,
  ARight: TBLString): Boolean;
begin
  Result := (ALeft.Compare(ARight) <= 0);
end;

class operator TBLString.LessThanOrEqual(const ALeft: TBLString;
  const ARight: TBLStringView): Boolean;
begin
  Result := (ALeft.Compare(ARight) <= 0);
end;

class operator TBLString.LessThanOrEqual(const ALeft: TBLString;
  const ARight: PUTF8Char): Boolean;
begin
  Result := (ALeft.Compare(ARight) <= 0);
end;

class operator TBLString.LessThanOrEqual(const ALeft: TBLString;
  const ARight: String): Boolean;
begin
  Result := (ALeft.Compare(ARight) <= 0);
end;

function TBLString.MakeMutable: PUTF8Char;
begin
  _BLCheck(_blStringMakeMutable(@Self, @Result));
end;

function TBLString.ModifyOp(const AOp: TBLModifyOp;
  const ALength: NativeInt): PUTF8Char;
begin
  _BLCheck(_blStringModifyOp(@Self, Ord(AOp), ALength, @Result));
end;

class operator TBLString.NotEqual(const ALeft: TBLString;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsEmpty) then
    Result := (ARight <> nil)
  else
    Result := (ARight = nil);
end;

class operator TBLString.NotEqual(const ALeft, ARight: TBLString): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLString.NotEqual(const ALeft: TBLString;
  const ARight: TBLStringView): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLString.NotEqual(const ALeft: TBLString;
  const ARight: PUTF8Char): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLString.NotEqual(const ALeft: TBLString;
  const ARight: UTF8String): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLString.NotEqual(const ALeft: TBLString;
  const ARight: String): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLString.Prepend(const AView: TBLStringView);
begin
  _BLCheck(_blStringInsertData(@Self, 0, Pointer(AView.FData), AView.FCount));
end;

procedure TBLString.Prepend(const AOther: TBLString);
begin
  _BLCheck(_blStringInsertString(@Self, 0, @AOther));
end;

procedure TBLString.Prepend(const AChar: UTF8Char; const ACount: NativeInt);
begin
  _BLCheck(_blStringInsertChar(@Self, 0, AChar, ACount));
end;

procedure TBLString.Prepend(const AStr: String);
begin
  Prepend(UTF8String(AStr));
end;

procedure TBLString.Prepend(const AStr: UTF8String);
begin
  _BLCheck(_blStringInsertData(@Self, 0, PUTF8Char(AStr), System.Length(AStr)));
end;

procedure TBLString.Prepend(const AStr: PUTF8Char; const ALength: NativeInt);
begin
  _BLCheck(_blStringInsertData(@Self, 0, AStr, ALength));
end;

procedure TBLString.Remove(const AIndex: NativeInt);
begin
  _BLCheck(_blStringRemoveIndex(@Self, AIndex));
end;

procedure TBLString.Remove(const ARange: TBLRange);
begin
  _BLCheck(_blStringRemoveRange(@Self, ARange.Start, ARange.Stop));
end;

procedure TBLString.Reserve(const AMinSize: NativeInt);
begin
  _BLCheck(_blStringReserve(@Self, AMinSize));
end;

procedure TBLString.Reset;
begin
  _BLCheck(_blStringReset(@Self));
end;

procedure TBLString.Resize(const ALength: NativeInt; const AFill: UTF8Char);
begin
  _BLCheck(_blStringResize(@Self, ALength, AFill));
end;

procedure TBLString.Shrink;
begin
  _BLCheck(_blStringShrink(@Self));
end;

procedure TBLString.Swap(var AOther: TBLString);
begin
  FBase.Swap(AOther.FBase);
end;

function TBLString.ToString: String;
begin
  var S: UTF8String;
  SetString(S, Data, Length);
  Result := String(S);
end;

procedure TBLString.Truncate(const ALength: NativeInt);
begin
  _BLCheck(_blStringResize(@Self, ALength, #0));
end;

function TBLString.View: TBLStringView;
begin
  Result.Reset(Pointer(Data), Length);
end;

{ TBLBitArray }

procedure TBLBitArray.AppendBit(const ABitValue: Boolean);
begin
  _BLCheck(_blBitArrayAppendBit(@Self, ABitValue));
end;

procedure TBLBitArray.AppendWord(const AWordValue: UInt32);
begin
  _BLCheck(_blBitArrayAppendWord(@Self, AWordValue));
end;

procedure TBLBitArray.AppendWords(const AWordData: PUInt32;
  const AWordCount: Integer);
begin
  _BLCheck(_blBitArrayAppendWords(@Self, AWordData, AWordCount));
end;

procedure TBLBitArray.AppendWords(const AWordData: TArray<UInt32>);
begin
  _BLCheck(_blBitArrayAppendWords(@Self, Pointer(AWordData), Length(AWordData)));
end;

class operator TBLBitArray.Assign(var ADest: TBLBitArray;
  const [ref] ASrc: TBLBitArray);
begin
  _BLCheck(_blBitArrayInitWeak(@ADest, @ASrc));
end;

class operator TBLBitArray.Equal(const ALeft: TBLBitArray;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsEmpty) then
    Result := (ARight = nil)
  else
    Result := (ARight <> nil);
end;

procedure TBLBitArray.AssignWords(const AWordData: PUInt32;
  const AWordCount: Integer);
begin
  _BLCheck(_blBitArrayAssignWords(@Self, AWordData, AWordCount));
end;

procedure TBLBitArray.AssignWords(const AWordData: TArray<UInt32>);
begin
  _BLCheck(_blBitArrayAssignWords(@Self, Pointer(AWordData), Length(AWordData)));
end;

function TBLBitArray.CardinalityInRange(const AStartBit,
  AEndBit: Integer): Integer;
begin
  Result := _blBitArrayGetCardinalityInRange(@Self, AStartBit, AEndBit);
end;

procedure TBLBitArray.Clear;
begin
  _BLCheck(_blBitArrayClear(@Self));
end;

procedure TBLBitArray.ClearBit(const ABitIndex: Integer);
begin
  _BLCheck(_blBitArrayClearBit(@Self, ABitIndex));
end;

procedure TBLBitArray.ClearRange(const AStartBit, AEndBit: Integer);
begin
  _BLCheck(_blBitArrayClearRange(@Self, AStartBit, AEndBit));
end;

procedure TBLBitArray.ClearWord(const ABitIndex: Integer;
  const AWordValue: UInt32);
begin
  _BLCheck(_blBitArrayClearWord(@Self, ABitIndex, AWordValue));
end;

procedure TBLBitArray.ClearWords(const ABitIndex: Integer;
  const AWordData: PUInt32; const AWordCount: UInt32);
begin
  _BLCheck(_blBitArrayClearWords(@Self, ABitIndex, AWordData, AWordCount));
end;

procedure TBLBitArray.ClearWords(const ABitIndex: Integer;
  const AWordData: TArray<UInt32>);
begin
  _BLCheck(_blBitArrayClearWords(@Self, ABitIndex, Pointer(AWordData), Length(AWordData)));
end;

function TBLBitArray.Compare(const AOther: TBLBitArray): Integer;
begin
  Result := _blBitArrayCompare(@Self, @AOther);
end;

class operator TBLBitArray.Equal(const ALeft, ARight: TBLBitArray): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLBitArray.Equals(const AOther: TBLBitArray): Boolean;
begin
  Result := _blBitArrayEquals(@Self, @AOther);
end;

procedure TBLBitArray.FillRange(const AStartBit, AEndBit: Integer);
begin
  _BLCheck(_blBitArrayFillRange(@Self, AStartBit, AEndBit));
end;

procedure TBLBitArray.FillWords(const ABitIndex: Integer;
  const AWordData: PUInt32; const AWordCount: UInt32);
begin
  _BLCheck(_blBitArrayFillWords(@Self, ABitIndex, AWordData, AWordCount));
end;

procedure TBLBitArray.FillWords(const ABitIndex: Integer;
  const AWordData: TArray<UInt32>);
begin
  _BLCheck(_blBitArrayFillWords(@Self, ABitIndex, Pointer(AWordData), Length(AWordData)));
end;

class operator TBLBitArray.Finalize(var ADest: TBLBitArray);
begin
  if (ADest.FBase.NeedsCleanup) then
    _BLCheck(_blBitArrayDestroy(@ADest));
end;

function TBLBitArray.GetBit(const AIndex: Integer): Boolean;
begin
  Result := _blBitArrayHasBit(@Self, AIndex);
end;

function TBLBitArray.GetCapacity: Integer;
begin
  Result := _blBitArrayGetCapacity(@Self);
end;

function TBLBitArray.GetCardinality: Integer;
begin
  Result := _blBitArrayGetCardinality(@Self);
end;

function TBLBitArray.GetCount: Integer;
begin
  Result := _blBitArrayGetSize(@Self);
end;

function TBLBitArray.GetData: PUInt32;
begin
  Result := _blBitArrayGetData(@Self);
end;

function TBLBitArray.GetIsEmpty: Boolean;
begin
  Result := _blBitArrayIsEmpty(@Self);
end;

function TBLBitArray.GetWordCount: Integer;
begin
  Result := _blBitArrayGetWordCount(@Self);
end;

class operator TBLBitArray.GreaterThan(const ALeft,
  ARight: TBLBitArray): Boolean;
begin
  Result := (ALeft.Compare(ARight) > 0);
end;

class operator TBLBitArray.GreaterThanOrEqual(const ALeft,
  ARight: TBLBitArray): Boolean;
begin
  Result := (ALeft.Compare(ARight) >= 0);
end;

function TBLBitArray.HasBit(const ABitIndex: Integer): Boolean;
begin
  Result := _blBitArrayHasBit(@Self, ABitIndex);
end;

function TBLBitArray.HasBitsInRange(const AStartBit, AEndBit: Integer): Boolean;
begin
  Result := _blBitArrayHasBitsInRange(@Self, AStartBit, AEndBit);
end;

class operator TBLBitArray.Initialize(out ADest: TBLBitArray);
begin
  _BLCheck(_blBitArrayInit(@ADest));
end;

function TBLBitArray.Intersects(const AOther: TBLBitArray): Boolean;
begin
  Result := _blBitArrayIntersects(@Self, @AOther);
end;

class operator TBLBitArray.LessThan(const ALeft, ARight: TBLBitArray): Boolean;
begin
  Result := (ALeft.Compare(ARight) < 0);
end;

class operator TBLBitArray.LessThanOrEqual(const ALeft,
  ARight: TBLBitArray): Boolean;
begin
  Result := (ALeft.Compare(ARight) <= 0);
end;

class operator TBLBitArray.NotEqual(const ALeft: TBLBitArray;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsEmpty) then
    Result := (ARight <> nil)
  else
    Result := (ARight = nil);
end;

class operator TBLBitArray.NotEqual(const ALeft, ARight: TBLBitArray): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLBitArray.ReplaceBit(const ABitIndex: Integer;
  const ABitValue: Boolean);
begin
  _BLCheck(_blBitArrayReplaceBit(@Self, ABitIndex, ABitValue));
end;

function TBLBitArray.ReplaceOp(const ANumBits: Integer): PUInt32;
begin
  _BLCheck(_blBitArrayReplaceOp(@Self, ANumBits, @Result));
end;

procedure TBLBitArray.ReplaceWord(const ABitIndex: Integer;
  const AWordValue: UInt32);
begin
  _BLCheck(_blBitArrayReplaceWord(@Self, ABitIndex, AWordValue));
end;

procedure TBLBitArray.ReplaceWords(const ABitIndex: Integer;
  const AWordData: PUInt32; const AWordCount: UInt32);
begin
  _BLCheck(_blBitArrayReplaceWords(@Self, ABitIndex, AWordData, AWordCount));
end;

procedure TBLBitArray.ReplaceWords(const ABitIndex: Integer;
  const AWordData: TArray<UInt32>);
begin
  _BLCheck(_blBitArrayReplaceWords(@Self, ABitIndex, Pointer(AWordData), Length(AWordData)));
end;

procedure TBLBitArray.Reserve(const ANumBits: Integer);
begin
  _BLCheck(_blBitArrayReserve(@Self, ANumBits));
end;

procedure TBLBitArray.Reset;
begin
  _BLCheck(_blBitArrayReset(@Self));
end;

procedure TBLBitArray.Resize(const ANumBits: Integer);
begin
  _BLCheck(_blBitArrayResize(@Self, ANumBits));
end;

procedure TBLBitArray.SetBit(const ABitIndex: Integer);
begin
  _BLCheck(_blBitArraySetBit(@Self, ABitIndex));
end;

procedure TBLBitArray.SetBit(const AIndex: Integer; const AValue: Boolean);
begin
  _BLCheck(_blBitArrayReplaceBit(@Self, AIndex, AValue));
end;

procedure TBLBitArray.Shrink;
begin
  _BLCheck(_blBitArrayShrink(@Self));
end;

function TBLBitArray.Subsumes(const AOther: TBLBitArray): Boolean;
begin
  Result := _blBitArraySubsumes(@Self, @AOther);
end;

procedure TBLBitArray.Swap(var AOther: TBLBitArray);
begin
  FBase.Swap(AOther.FBase);
end;

{$ENDREGION 'Containers'}

{$REGION 'Styling'}

{ TBLRgba32 }

function BLRgba32: TBLRgba32; overload; inline;
begin
  Result.Reset;
end;

function BLRgba32(const ARgba32: UInt32): TBLRgba32; overload; inline;
begin
  Result.Reset(ARgba32);
end;

function BLRgba32(const ARgba64: TBLRgba64): TBLRgba32; overload; inline;
begin
  Result.Reset(ARgba64);
end;

function BLRgba32(const AR, AG, AB: Byte; const AA: Byte = $FF): TBLRgba32; overload; inline;
begin
  Result.Reset(AR, AG, AB, AA);
end;

function BLRgba32(const AColor: TAlphaColorRec): TBLRgba32; overload; inline;
begin
  Result.Reset(AColor);
end;

function BLMin(const AA, AB: TBLRgba32): TBLRgba32; overload; inline;
begin
  Result.Reset(Min(AA.R, AB.R), Min(AA.G, AB.G), Min(AA.B, AB.B), Min(AA.A, AB.A));
end;

function BLMax(const AA, AB: TBLRgba32): TBLRgba32; overload; inline;
begin
  Result.Reset(Max(AA.R, AB.R), Max(AA.G, AB.G), Max(AA.B, AB.B), Max(AA.A, AB.A));
end;

constructor TBLRgba32.Create(const ARgba32: UInt32);
begin
  Value := ARgba32;
end;

constructor TBLRgba32.Create(const AR, AG, AB, AA: Byte);
begin
  Value := (AA shl 24) or (AR shl 16) or (AG shl 8) or AB;
end;

class function TBLRgba32.Create: TBLRgba32;
begin
  Result.Value := 0;
end;

constructor TBLRgba32.Create(const AColor: TAlphaColorRec);
begin
  Value := AColor.Color;
end;

class operator TBLRgba32.Equal(const ALeft, ARight: TBLRgba32): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLRgba32.Equals(const AOther: TBLRgba32): Boolean;
begin
  Result := (Value = AOther.Value);
end;

function TBLRgba32.GetA: Byte;
begin
  Result := Value shr 24;
end;

function TBLRgba32.GetB: Byte;
begin
  Result := Value;
end;

function TBLRgba32.GetG: Byte;
begin
  Result := Value shr 8;
end;

function TBLRgba32.GetIsOpaque: Boolean;
begin
  Result := (Value >= $FF000000);
end;

function TBLRgba32.GetIsTransparent: Boolean;
begin
  Result := (Value <= $00FFFFFF);
end;

function TBLRgba32.GetR: Byte;
begin
  Result := Value shr 16;
end;

class operator TBLRgba32.Implicit(const AValue: TBLRgba32): UInt32;
begin
  Result := AValue.Value;
end;

class operator TBLRgba32.Implicit(const AValue: TAlphaColorRec): TBLRgba32;
begin
  Result.Value := AValue.Color;
end;

class operator TBLRgba32.Implicit(const AValue: UInt32): TBLRgba32;
begin
  Result.Value := AValue;
end;

class operator TBLRgba32.NotEqual(const ALeft, ARight: TBLRgba32): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLRgba32.Reset;
begin
  Value := 0;
end;

procedure TBLRgba32.Reset(const AR, AG, AB, AA: Byte);
begin
  Value := (AA shl 24) or (AR shl 16) or (AG shl 8) or AB;
end;

procedure TBLRgba32.Reset(const ARgba32: UInt32);
begin
  Value := ARgba32;
end;

procedure TBLRgba32.Reset(const AColor: TAlphaColorRec);
begin
  Value := AColor.Color;
end;

procedure TBLRgba32.SetA(const AValue: Byte);
begin
  Value := (Value and $00FFFFFF) or (AValue shl 24);
end;

procedure TBLRgba32.SetB(const AValue: Byte);
begin
  Value := (Value and $FFFFFF00) or AValue;
end;

procedure TBLRgba32.SetG(const AValue: Byte);
begin
  Value := (Value and $FFFF00FF) or (AValue shl 8);
end;

procedure TBLRgba32.SetR(const AValue: Byte);
begin
  Value := (Value and $FF00FFFF) or (AValue shl 16);
end;

{ _TBLRgba32Helper }

constructor _TBLRgba32Helper.Create(const ARgba64: TBLRgba64);
begin
  Reset(ARgba64);
end;

procedure _TBLRgba32Helper.Reset(const ARgba64: TBLRgba64);
begin
  Reset(ARgba64.Value shr 40,
        ARgba64.Value shr 24,
        ARgba64.Value shr  8,
        ARgba64.Value shr 56);
end;

{ TBLRgba64 }

function BLRgba64: TBLRgba64; overload; inline;
begin
  Result.Reset;
end;

function BLRgba64(const ARgba32: UInt32): TBLRgba64; overload; inline;
begin
  Result.Reset(ARgba32);
end;

function BLRgba64(const ARgba64: UInt64): TBLRgba64; overload; inline;
begin
  Result.Reset(ARgba64);
end;

function BLRgba64(const ARgba32: TBLRgba32): TBLRgba64; overload; inline;
begin
  Result.Reset(ARgba32);
end;

function BLRgba64(const AR, AG, AB: Word; const AA: Word = $FFFF): TBLRgba64; overload; inline;
begin
  Result.Reset(AR, AG, AB, AA);
end;

function BLMin(const AA, AB: TBLRgba64): TBLRgba64; overload; inline;
begin
  Result.Reset(Min(AA.R, AB.R), Min(AA.G, AB.G), Min(AA.B, AB.B), Min(AA.A, AB.A));
end;

function BLMax(const AA, AB: TBLRgba64): TBLRgba64; overload; inline;
begin
  Result.Reset(Max(AA.R, AB.R), Max(AA.G, AB.G), Max(AA.B, AB.B), Max(AA.A, AB.A));
end;

constructor TBLRgba64.Create(const ARgba64: UInt64);
begin
  Value := ARgba64;
end;

constructor TBLRgba64.Create(const ARgba32: TBLRgba32);
begin
  Reset(ARgba32);
end;

constructor TBLRgba64.Create(const AR, AG, AB, AA: Word);
begin
  Value := (UInt64(AA) shl 48) or (UInt64(AR) shl 32) or (UInt64(AG) shl 16) or UInt64(AB);
end;

class function TBLRgba64.Create: TBLRgba64;
begin
  Result.Value := 0;
end;

class operator TBLRgba64.Equal(const ALeft, ARight: TBLRgba64): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLRgba64.Equals(const AOther: TBLRgba64): Boolean;
begin
  Result := (Value = AOther.Value);
end;

function TBLRgba64.GetA: Word;
begin
  Result := Value shr 48;
end;

function TBLRgba64.GetB: Word;
begin
  Result := Value;
end;

function TBLRgba64.GetG: Word;
begin
  Result := Value shr 16;
end;

function TBLRgba64.GetIsOpaque: Boolean;
begin
  Result := (Value >= $FFFF000000000000);
end;

function TBLRgba64.GetIsTransparent: Boolean;
begin
  Result := (Value <= $0000FFFFFFFFFFFF);
end;

function TBLRgba64.GetR: Word;
begin
  Result := Value shr 32;
end;

class operator TBLRgba64.Implicit(const AValue: TBLRgba64): UInt64;
begin
  Result := AValue.Value;
end;

class operator TBLRgba64.Implicit(const AValue: UInt64): TBLRgba64;
begin
  Result.Value := AValue;
end;

class operator TBLRgba64.NotEqual(const ALeft, ARight: TBLRgba64): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLRgba64.Reset(const AR, AG, AB, AA: Word);
begin
  Value := (UInt64(AA) shl 48) or (UInt64(AR) shl 32) or (UInt64(AG) shl 16) or UInt64(AB);
end;

procedure TBLRgba64.Reset(const ARgba32: UInt32);
var
  C: TAlphaColorRec absolute ARgba32;
begin
  Value := (UInt64(C.A) shl 48) or (UInt64(C.R) shl 32) or (UInt64(C.G) shl 16) or UInt64(C.B);
  Value := Value * $0101;
end;

procedure TBLRgba64.Reset(const ARgba32: TBLRgba32);
begin
  Value := (UInt64(ARgba32.A) shl 48) or (UInt64(ARgba32.R) shl 32) or (UInt64(ARgba32.G) shl 16) or UInt64(ARgba32.B);
  Value := Value * $0101;
end;

procedure TBLRgba64.Reset(const ARgba64: UInt64);
begin
  Value := ARgba64;
end;

procedure TBLRgba64.Reset;
begin
  Value := 0;
end;

procedure TBLRgba64.SetA(const AValue: Word);
begin
  Value := (Value and $0000FFFFFFFFFFFF) or (UInt64(AValue) shl 48);
end;

procedure TBLRgba64.SetB(const AValue: Word);
begin
  Value := (Value and $FFFFFFFFFFFF0000) or UInt64(AValue);
end;

procedure TBLRgba64.SetG(const AValue: Word);
begin
  Value := (Value and $FFFFFFFF0000FFFF) or (UInt64(AValue) shl 16);
end;

procedure TBLRgba64.SetR(const AValue: Word);
begin
  Value := (Value and $FFFF0000FFFFFFFF) or (UInt64(AValue) shl 32);
end;

{ TBLRgba }

function BLRgba: TBLRgba; overload; inline;
begin
  Result.Reset;
end;

function BLRgba(const ARgba32: TBLRgba32): TBLRgba; overload; inline;
begin
  Result.Reset(ARgba32);
end;

function BLRgba(const ARgba64: TBLRgba64): TBLRgba; overload; inline;
begin
  Result.Reset(ARgba64);
end;

function BLRgba(const AR, AG, AB: Single; const AA: Single = 1): TBLRgba; overload; inline;
begin
  Result.Reset(AR, AG, AB, AA);
end;

function BLRgba(const AColor: TAlphaColorF): TBLRgba; overload; inline;
begin
  Result.Reset(AColor);
end;

function BLMin(const AA, AB: TBLRgba): TBLRgba; overload; inline;
begin
  Result.Reset(Min(AA.R, AB.R), Min(AA.G, AB.G), Min(AA.B, AB.B), Min(AA.A, AB.A));
end;

function BLMax(const AA, AB: TBLRgba): TBLRgba; overload; inline;
begin
  Result.Reset(Max(AA.R, AB.R), Max(AA.G, AB.G), Max(AA.B, AB.B), Max(AA.A, AB.A));
end;

class function TBLRgba.Create: TBLRgba;
begin
  FillChar(Result, SizeOf(Result), 0);
end;

constructor TBLRgba.Create(const AR, AG, AB, AA: Single);
begin
  R := AR;
  G := AG;
  B := AB;
  A := AA;
end;

constructor TBLRgba.Create(const ARgba32: TBLRgba32);
begin
  Reset(ARgba32);
end;

constructor TBLRgba.Create(const ARgba64: TBLRgba64);
begin
  Reset(ARgba64);
end;

constructor TBLRgba.Create(const AColor: TAlphaColorF);
begin
  Self := TBLRgba(AColor);
end;

class operator TBLRgba.Equal(const ALeft, ARight: TBLRgba): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLRgba.Equals(const AOther: TBLRgba32): Boolean;
begin
  var Other: TBLRgba;
  Other.Reset(AOther);
  Result := Equals(Other);
end;

function TBLRgba.Equals(const AOther: TBLRgba64): Boolean;
begin
  var Other: TBLRgba;
  Other.Reset(AOther);
  Result := Equals(Other);
end;

function TBLRgba.Equals(const AR, AG, AB, AA: Single): Boolean;
begin
  Result := (R = AR) and (G = AG) and (B = AB) and (A = AA);
end;

function TBLRgba.GetIsOpaque: Boolean;
begin
  Result := (A >= 1);
end;

function TBLRgba.GetIsTransparent: Boolean;
begin
  Result := (A <= 0);
end;

function TBLRgba.Equals(const AOther: TBLRgba): Boolean;
begin
  Result := (R = AOther.R) and (G = AOther.G) and (B = AOther.B) and (A = AOther.A);
end;

class operator TBLRgba.NotEqual(const ALeft, ARight: TBLRgba): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLRgba.Reset;
begin
  FillChar(Self, SizeOf(Self), 0);
end;

procedure TBLRgba.Reset(const ARgba32: TBLRgba32);
begin
  R := ARgba32.R * (1 / $FF);
  G := ARgba32.G * (1 / $FF);
  B := ARgba32.B * (1 / $FF);
  A := ARgba32.A * (1 / $FF);
end;

procedure TBLRgba.Reset(const ARgba64: TBLRgba64);
begin
  R := ARgba64.R * (1 / $FFFF);
  G := ARgba64.G * (1 / $FFFF);
  B := ARgba64.B * (1 / $FFFF);
  A := ARgba64.A * (1 / $FFFF);
end;

procedure TBLRgba.Reset(const AR, AG, AB, AA: Single);
begin
  R := AR;
  G := AG;
  B := AB;
  A := AA;
end;

procedure TBLRgba.Reset(const AColor: TAlphaColorF);
begin
  Self := TBLRgba(AColor);
end;

function TBLRgba.ToRgba32: TBLRgba32;
begin
  Result.Reset(Trunc(EnsureRange(R, 0, 1) * $FF + 0.5),
               Trunc(EnsureRange(G, 0, 1) * $FF + 0.5),
               Trunc(EnsureRange(B, 0, 1) * $FF + 0.5),
               Trunc(EnsureRange(A, 0, 1) * $FF + 0.5));
end;

function TBLRgba.ToRgba64: TBLRgba64;
begin
  Result.Reset(Trunc(EnsureRange(R, 0, 1) * $FFFF + 0.5),
               Trunc(EnsureRange(G, 0, 1) * $FFFF + 0.5),
               Trunc(EnsureRange(B, 0, 1) * $FFFF + 0.5),
               Trunc(EnsureRange(A, 0, 1) * $FFFF + 0.5));
end;

{ TBLPattern }

procedure TBLPattern.ApplyTransform(const ATransform: TBLMatrix2D);
begin
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.Transform), @ATransform));
end;

class operator TBLPattern.Assign(var ADest: TBLPattern;
  const [ref] ASrc: TBLPattern);
begin
  _BLCheck(_blPatternInitWeak(@ADest, @ASrc));
end;

constructor TBLPattern.Create(const AImage: TBLImage;
  const AExtendMode: TBLExtendMode);
begin
  _BLCheck(_blPatternInitAs(@Self, @AImage, nil, Ord(AExtendMode), nil));
end;

constructor TBLPattern.Create(const AImage: TBLImage;
  const AExtendMode: TBLExtendMode; const ATransform: TBLMatrix2D);
begin
  _BLCheck(_blPatternInitAs(@Self, @AImage, nil, Ord(AExtendMode), @ATransform));
end;

constructor TBLPattern.Create(const AImage: TBLImage; const AArea: TBLRectI;
  const AExtendMode: TBLExtendMode);
begin
  _BLCheck(_blPatternInitAs(@Self, @AImage, @AArea, Ord(AExtendMode), nil));
end;

constructor TBLPattern.Create(const AImage: TBLImage; const AArea: TBLRectI;
  const AExtendMode: TBLExtendMode; const ATransform: TBLMatrix2D);
begin
  _BLCheck(_blPatternInitAs(@Self, @AImage, @AArea, Ord(AExtendMode), @ATransform));
end;

class operator TBLPattern.Equal(const ALeft, ARight: TBLPattern): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLPattern.Equals(const AOther: TBLPattern): Boolean;
begin
  Result := _blPatternEquals(@Self, @AOther);
end;

class operator TBLPattern.Finalize(var ADest: TBLPattern);
begin
  _BLCheck(_blPatternDestroy(@ADest));
end;

function TBLPattern.GetArea: TBLRectI;
begin
  _BLCheck(_blPatternGetArea(@Self, @Result));
end;

function TBLPattern.GetExtendMode: TBLExtendMode;
begin
  Result := TBLExtendMode(_blPatternGetExtendMode(@Self));
end;

function TBLPattern.GetHasTransform: Boolean;
begin
  Result := (TransformKind <> TBLTransformKind.Identity);
end;

function TBLPattern.GetImage: TBLImage;
begin
  _BLCheck(_blPatternGetImage(@Self, @Result));
end;

function TBLPattern.GetTransform: TBLMatrix2D;
begin
  _BLCheck(_blPatternGetTransform(@Self, @Result));
end;

function TBLPattern.GetTransformKind: TBLTransformKind;
begin
  Result := TBLTransformKind(_blPatternGetTransformType(@Self));
end;

class operator TBLPattern.Initialize(out ADest: TBLPattern);
begin
  _BLCheck(_blPatternInit(@ADest));
end;

procedure TBLPattern.Make(const AImage: TBLImage;
  const AExtendMode: TBLExtendMode);
begin
  _BLCheck(_blPatternCreate(@Self, @AImage, nil, Ord(AExtendMode), nil));
end;

procedure TBLPattern.Make(const AImage: TBLImage;
  const AExtendMode: TBLExtendMode; const ATransform: TBLMatrix2D);
begin
  _BLCheck(_blPatternCreate(@Self, @AImage, nil, Ord(AExtendMode), @ATransform));
end;

procedure TBLPattern.Make(const AImage: TBLImage; const AArea: TBLRectI;
  const AExtendMode: TBLExtendMode);
begin
  _BLCheck(_blPatternCreate(@Self, @AImage, @AArea, Ord(AExtendMode), nil));
end;

procedure TBLPattern.Make(const AImage: TBLImage; const AArea: TBLRectI;
  const AExtendMode: TBLExtendMode; const ATransform: TBLMatrix2D);
begin
  _BLCheck(_blPatternCreate(@Self, @AImage, @AArea, Ord(AExtendMode), @ATransform));
end;

class operator TBLPattern.NotEqual(const ALeft, ARight: TBLPattern): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLPattern.PostRotate(const AAngle: Double);
begin
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.PostRotate), @AAngle));
end;

procedure TBLPattern.PostRotate(const AAngle, AX, AY: Double);
var
  Values: array [0..2] of Double;
begin
  Values[0] := AAngle;
  Values[1] := AX;
  Values[2] := AY;
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.PostRotatePoint), @Values));
end;

procedure TBLPattern.PostRotate(const AAngle: Double; const AOrigin: TBLPointI);
var
  Values: array [0..2] of Double;
begin
  Values[0] := AAngle;
  Values[1] := AOrigin.X;
  Values[2] := AOrigin.Y;
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.PostRotatePoint), @Values));
end;

procedure TBLPattern.PostRotate(const AAngle: Double; const AOrigin: TBLPoint);
var
  Values: array [0..2] of Double;
begin
  Values[0] := AAngle;
  Values[1] := AOrigin.X;
  Values[2] := AOrigin.Y;
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.PostRotatePoint), @Values));
end;

procedure TBLPattern.PostScale(const AP: TBLPoint);
begin
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.PostScale), @AP));
end;

procedure TBLPattern.PostScale(const AP: TBLPointI);
begin
  var P := BLPoint(AP.X, AP.Y);
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.PostScale), @P));
end;

procedure TBLPattern.PostScale(const AX, AY: Double);
begin
  var P := BLPoint(AX, AY);
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.PostScale), @P));
end;

procedure TBLPattern.PostScale(const AXY: Double);
begin
  var P := BLPoint(AXY, AXY);
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.PostScale), @P));
end;

procedure TBLPattern.PostSkew(const AX, AY: Double);
begin
  var P := BLPoint(AX, AY);
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.PostSkew), @P));
end;

procedure TBLPattern.PostSkew(const AP: TBLPoint);
begin
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.PostSkew), @AP));
end;

procedure TBLPattern.PostTransform(const ATransform: TBLMatrix2D);
begin
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.PostTransform), @ATransform));
end;

procedure TBLPattern.PostTranslate(const AP: TBLPoint);
begin
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.PostTranslate), @AP));
end;

procedure TBLPattern.PostTranslate(const AP: TBLPointI);
begin
  var P := BLPoint(AP.X, AP.Y);
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.PostTranslate), @P));
end;

procedure TBLPattern.PostTranslate(const AX, AY: Double);
begin
  var P := BLPoint(AX, AY);
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.PostTranslate), @P));
end;

procedure TBLPattern.Reset;
begin
  _BLCheck(_blPatternReset(@Self));
end;

procedure TBLPattern.ResetArea;
begin
  _BLCheck(_blPatternResetArea(@Self));
end;

procedure TBLPattern.ResetExtendMode;
begin
  _BLCheck(_blPatternSetExtendMode(@Self, Ord(TBLExtendMode.Repeating)));
end;

procedure TBLPattern.ResetImage;
begin
  _BLCheck(_blPatternResetImage(@Self));
end;

procedure TBLPattern.ResetTransform;
begin
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.Reset), nil));
end;

procedure TBLPattern.Rotate(const AAngle: Double);
begin
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.Rotate), @AAngle));
end;

procedure TBLPattern.Rotate(const AAngle, AX, AY: Double);
var
  Values: array [0..2] of Double;
begin
  Values[0] := AAngle;
  Values[1] := AX;
  Values[2] := AY;
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.RotatePoint), @Values));
end;

procedure TBLPattern.Rotate(const AAngle: Double; const AOrigin: TBLPoint);
var
  Values: array [0..2] of Double;
begin
  Values[0] := AAngle;
  Values[1] := AOrigin.X;
  Values[2] := AOrigin.Y;
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.RotatePoint), @Values));
end;

procedure TBLPattern.Rotate(const AAngle: Double; const AOrigin: TBLPointI);
var
  Values: array [0..2] of Double;
begin
  Values[0] := AAngle;
  Values[1] := AOrigin.X;
  Values[2] := AOrigin.Y;
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.RotatePoint), @Values));
end;

procedure TBLPattern.SetImage(const AValue: TBLImage);
begin
  _BLCheck(_blPatternSetImage(@Self, @AValue, nil));
end;

procedure TBLPattern.Scale(const AX, AY: Double);
begin
  var P := BLPoint(AX, AY);
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.Scale), @P));
end;

procedure TBLPattern.Scale(const AXY: Double);
begin
  var P := BLPoint(AXY, AXY);
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.Scale), @P));
end;

procedure TBLPattern.Scale(const AP: TBLPoint);
begin
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.Scale), @AP));
end;

procedure TBLPattern.Scale(const AP: TBLPointI);
begin
  var P := BLPoint(AP.X, AP.Y);
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.Scale), @P));
end;

procedure TBLPattern.SetArea(const AValue: TBLRectI);
begin
  _BLCheck(_blPatternSetArea(@Self, @AValue));
end;

procedure TBLPattern.SetExtendMode(const AValue: TBLExtendMode);
begin
  _BLCheck(_blPatternSetExtendMode(@Self, Ord(AValue)));
end;

procedure TBLPattern.SetImage(const AValue: TBLImage; const AArea: TBLRectI);
begin
  _BLCheck(_blPatternSetImage(@Self, @AValue, @AArea));
end;

procedure TBLPattern.SetTransform(const AValue: TBLMatrix2D);
begin
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.Assign), @AValue));
end;

procedure TBLPattern.Skew(const AP: TBLPoint);
begin
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.Skew), @AP));
end;

procedure TBLPattern.Skew(const AX, AY: Double);
begin
  var P := BLPoint(AX, AY);
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.Skew), @P));
end;

procedure TBLPattern.Swap(var AOther: TBLPattern);
begin
  FBase.Swap(AOther.FBase);
end;

procedure TBLPattern.Translate(const AP: TBLPointI);
begin
  var P := BLPoint(AP.X, AP.Y);
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.Translate), @P));
end;

procedure TBLPattern.Translate(const AP: TBLPoint);
begin
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.Translate), @AP));
end;

procedure TBLPattern.Translate(const AX, AY: Double);
begin
  var P := BLPoint(AX, AY);
  _BLCheck(_blPatternApplyTransformOp(@Self, Ord(TBLTransformOp.Translate), @P));
end;

{ TBLGradientStop }

function BLGradientStop: TBLGradientStop; overload; inline;
begin
  Result.Reset;
end;

function BLGradientStop(const AOffset: Double; const ARgba32: TBLRgba32): TBLGradientStop; overload; inline;
begin
  Result.Reset(AOffset, ARgba32);
end;

function BLGradientStop(const AOffset: Double; const ARgba64: TBLRgba64): TBLGradientStop; overload; inline;
begin
  Result.Reset(AOffset, ARgba64);
end;

function BLGradientStop(const AOffset: Double; const AColor: TAlphaColor): TBLGradientStop; overload; inline;
begin
  Result.Reset(AOffset, AColor);
end;

class function TBLGradientStop.Create: TBLGradientStop;
begin
  Result.Offset := 0;
  Result.Rgba := 0;
end;

constructor TBLGradientStop.Create(const AOffset: Double;
  const ARgba32: TBLRgba32);
begin
  Offset := AOffset;
  Rgba.Reset(ARgba32);
end;

constructor TBLGradientStop.Create(const AOffset: Double;
  const ARgba64: TBLRgba64);
begin
  Offset := AOffset;
  Rgba := ARgba64;
end;

constructor TBLGradientStop.Create(const AOffset: Double;
  const AColor: TAlphaColor);
begin
  Offset := AOffset;
  Rgba.Reset(AColor);
end;

class operator TBLGradientStop.Equal(const ALeft,
  ARight: TBLGradientStop): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLGradientStop.Equals(const AOther: TBLGradientStop): Boolean;
begin
  Result := (Offset = AOther.Offset) and (Rgba = AOther.Rgba);
end;

class operator TBLGradientStop.NotEqual(const ALeft,
  ARight: TBLGradientStop): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLGradientStop.Reset(const AOffset: Double;
  const AColor: TAlphaColor);
begin
  Offset := AOffset;
  Rgba.Reset(AColor);
end;

procedure TBLGradientStop.Reset;
begin
  Offset := 0;
  Rgba := 0;
end;

procedure TBLGradientStop.Reset(const AOffset: Double;
  const ARgba32: TBLRgba32);
begin
  Offset := AOffset;
  Rgba.Reset(ARgba32);
end;

procedure TBLGradientStop.Reset(const AOffset: Double;
  const ARgba64: TBLRgba64);
begin
  Offset := AOffset;
  Rgba := ARgba64;
end;

{ TBLLinearGradientValues }

function BLLinearGradientValues: TBLLinearGradientValues; overload; inline;
begin
  Result.Reset;
end;

function BLLinearGradientValues(const AX0, AY0, AX1, AY1: Double): TBLLinearGradientValues; overload; inline;
begin
  Result.Reset(AX0, AY0, AX1, AY1);
end;

class function TBLLinearGradientValues.Create: TBLLinearGradientValues;
begin
  FillChar(Result, SizeOf(Result), 0);
end;

constructor TBLLinearGradientValues.Create(const AX0, AY0, AX1, AY1: Double);
begin
  X0 := AX0;
  Y0 := AY0;
  X1 := AX1;
  Y1 := AY1;
end;

procedure TBLLinearGradientValues.Reset;
begin
  FillChar(Self, SizeOf(Self), 0);
end;

procedure TBLLinearGradientValues.Reset(const AX0, AY0, AX1, AY1: Double);
begin
  X0 := AX0;
  Y0 := AY0;
  X1 := AX1;
  Y1 := AY1;
end;

{ TBLRadialGradientValues }

function BLRadialGradientValues: TBLRadialGradientValues; overload; inline;
begin
  Result.Reset;
end;

function BLRadialGradientValues(const AX0, AY0, AX1, AY1, AR0: Double;
  const AR1: Double = 0): TBLRadialGradientValues; overload; inline;
begin
  Result.Reset(AX0, AY0, AX1, AY1, AR0, AR1);
end;

class function TBLRadialGradientValues.Create: TBLRadialGradientValues;
begin
  FillChar(Result, SizeOf(Result), 0);
end;

constructor TBLRadialGradientValues.Create(const AX0, AY0, AX1, AY1, AR0,
  AR1: Double);
begin
  X0 := AX0;
  Y0 := AY0;
  X1 := AX1;
  Y1 := AY1;
  R0 := AR0;
  R1 := AR1;
end;

procedure TBLRadialGradientValues.Reset;
begin
  FillChar(Self, SizeOf(Self), 0);
end;

procedure TBLRadialGradientValues.Reset(const AX0, AY0, AX1, AY1, AR0,
  AR1: Double);
begin
  X0 := AX0;
  Y0 := AY0;
  X1 := AX1;
  Y1 := AY1;
  R0 := AR0;
  R1 := AR1;
end;

{ TBLConicGradientValues }

function BLConicGradientValues: TBLConicGradientValues; overload; inline;
begin
  Result.Reset;
end;

function BLConicGradientValues(const AX0, AY0, AAngle: Double;
  const ARepeat: Double = 1): TBLConicGradientValues; overload; inline;
begin
  Result.Reset(AX0, AY0, AAngle, ARepeat);
end;

class function TBLConicGradientValues.Create: TBLConicGradientValues;
begin
  FillChar(Result, SizeOf(Result), 0);
end;

constructor TBLConicGradientValues.Create(const AX0, AY0, AAngle,
  ARepeat: Double);
begin
  X0 := AX0;
  Y0 := AY0;
  Angle := AAngle;
  Repetition := ARepeat;
end;

procedure TBLConicGradientValues.Reset;
begin
  FillChar(Self, SizeOf(Self), 0);
end;

procedure TBLConicGradientValues.Reset(const AX0, AY0, AAngle, ARepeat: Double);
begin
  X0 := AX0;
  Y0 := AY0;
  Angle := AAngle;
  Repetition := ARepeat;
end;

{ TBLGradient }

procedure TBLGradient.AddStop(const AOffset: Double; const ARgba64: TBLRgba64);
begin
  _BLCheck(_blGradientAddStopRgba64(@Self, AOffset, ARgba64.Value));
end;

procedure TBLGradient.AddStop(const AOffset: Double; const AColor: TAlphaColor);
begin
  _BLCheck(_blGradientAddStopRgba32(@Self, AOffset, AColor));
end;

procedure TBLGradient.AddStop(const AOffset: Double; const ARgba32: TBLRgba32);
begin
  _BLCheck(_blGradientAddStopRgba32(@Self, AOffset, ARgba32.Value));
end;

procedure TBLGradient.ApplyTransform(const ATransform: TBLMatrix2D);
begin
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.Transform), @ATransform));
end;

class operator TBLGradient.Assign(var ADest: TBLGradient;
  const [ref] ASrc: TBLGradient);
begin
  _BLCheck(_blGradientInitWeak(@ADest, @ASrc));
end;

class operator TBLGradient.Equal(const ALeft: TBLGradient;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsEmpty) then
    Result := (ARight = nil)
  else
    Result := (ARight <> nil);
end;

constructor TBLGradient.Create(const AValues: TBLConicGradientValues;
  const AExtendMode: TBLExtendMode);
begin
  _BLCheck(_blGradientInitAs(@Self, Ord(TBLGradientKind.Conic), @AValues,
    Ord(AExtendMode), nil, 0, nil));
end;

constructor TBLGradient.Create(const AValues: TBLRadialGradientValues;
  const AExtendMode: TBLExtendMode);
begin
  _BLCheck(_blGradientInitAs(@Self, Ord(TBLGradientKind.Radial), @AValues,
    Ord(AExtendMode), nil, 0, nil));
end;

constructor TBLGradient.Create(const AValues: TBLLinearGradientValues;
  const AExtendMode: TBLExtendMode);
begin
  _BLCheck(_blGradientInitAs(@Self, Ord(TBLGradientKind.Linear), @AValues,
    Ord(AExtendMode), nil, 0, nil));
end;

constructor TBLGradient.Create(const AKind: TBLGradientKind;
  const AValues: TArray<Double>);
begin
  _BLCheck(_blGradientInitAs(@Self, Ord(AKind), AValues, Ord(TBLExtendMode.Pad),
    nil, 0, nil));
end;

constructor TBLGradient.Create(const AKind: TBLGradientKind;
  const AValues: PDouble);
begin
  _BLCheck(_blGradientInitAs(@Self, Ord(AKind), AValues, Ord(TBLExtendMode.Pad),
    nil, 0, nil));
end;

constructor TBLGradient.Create(const AValues: TBLLinearGradientValues;
  const AExtendMode: TBLExtendMode; const AStops: TArray<TBLGradientStop>);
begin
  _BLCheck(_blGradientInitAs(@Self, Ord(TBLGradientKind.Linear), @AValues,
    Ord(AExtendMode), AStops, Length(AStops), nil));
end;

constructor TBLGradient.Create(const AValues: TBLConicGradientValues;
  const AExtendMode: TBLExtendMode; const AStops: TArray<TBLGradientStop>);
begin
  _BLCheck(_blGradientInitAs(@Self, Ord(TBLGradientKind.Conic), @AValues,
    Ord(AExtendMode), AStops, Length(AStops), nil));
end;

constructor TBLGradient.Create(const AValues: TBLRadialGradientValues;
  const AExtendMode: TBLExtendMode; const AStops: TArray<TBLGradientStop>);
begin
  _BLCheck(_blGradientInitAs(@Self, Ord(TBLGradientKind.Radial), @AValues,
    Ord(AExtendMode), AStops, Length(AStops), nil));
end;

procedure TBLGradient.AssignStops(const AStops: PBLGradientStop;
  const ACount: NativeInt);
begin
  _BLCheck(_blGradientAssignStops(@Self, AStops, ACount));
end;

procedure TBLGradient.AssignStops(const AStops: TArray<TBLGradientStop>);
begin
  _BLCheck(_blGradientAssignStops(@Self, AStops, Length(AStops)));
end;

procedure TBLGradient.AssignStops(const AStops: TBLArrayView<TBLGradientStop>);
begin
  _BLCheck(_blGradientAssignStops(@Self, AStops.FData, AStops.FCount));
end;

constructor TBLGradient.Create(const AValues: TBLConicGradientValues;
  const AExtendMode: TBLExtendMode; const AStops: TArray<TBLGradientStop>;
  const ATransform: TBLMatrix2D);
begin
  _BLCheck(_blGradientInitAs(@Self, Ord(TBLGradientKind.Conic), @AValues,
    Ord(AExtendMode), AStops, Length(AStops), @ATransform));
end;

constructor TBLGradient.Create(const AValues: TBLRadialGradientValues;
  const AExtendMode: TBLExtendMode; const AStops: TArray<TBLGradientStop>;
  const ATransform: TBLMatrix2D);
begin
  _BLCheck(_blGradientInitAs(@Self, Ord(TBLGradientKind.Radial), @AValues,
    Ord(AExtendMode), AStops, Length(AStops), @ATransform));
end;

constructor TBLGradient.Create(const AValues: TBLLinearGradientValues;
  const AExtendMode: TBLExtendMode; const AStops: TArray<TBLGradientStop>;
  const ATransform: TBLMatrix2D);
begin
  _BLCheck(_blGradientInitAs(@Self, Ord(TBLGradientKind.Linear), @AValues,
    Ord(AExtendMode), AStops, Length(AStops), @ATransform));
end;

class operator TBLGradient.Equal(const ALeft, ARight: TBLGradient): Boolean;
begin
  Result := _blGradientEquals(@ALeft, @ARight);
end;

function TBLGradient.Equals(const AOther: TBLGradient): Boolean;
begin
  Result := _blGradientEquals(@Self, @AOther);
end;

class operator TBLGradient.Finalize(var ADest: TBLGradient);
begin
  _BLCheck(_blGradientDestroy(@ADest));
end;

function TBLGradient.GetAngle: Double;
begin
  Result := PImpl(FBase.FImpl).Values[TBLGradientValue.ConicAngle];
end;

function TBLGradient.GetCapacity: NativeInt;
begin
  Result := PImpl(FBase.FImpl).Capacity;
end;

function TBLGradient.GetConic: TBLConicGradientValues;
begin
  Result := PImpl(FBase.FImpl).Conic;
end;

function TBLGradient.GetConicAngle: Double;
begin
  Result := PImpl(FBase.FImpl).Values[TBLGradientValue.ConicAngle];
end;

function TBLGradient.GetConicRepeat: Double;
begin
  Result := PImpl(FBase.FImpl).Values[TBLGradientValue.ConicRepeat];
end;

function TBLGradient.GetCount: NativeInt;
begin
  Result := PImpl(FBase.FImpl).Size;
end;

function TBLGradient.GetExtendMode: TBLExtendMode;
begin
  Result := TBLExtendMode(_blGradientGetExtendMode(@Self));
end;

function TBLGradient.GetHasTransform: Boolean;
begin
  Result := (GetTransformKind <> TBLTransformKind.Identity);
end;

function TBLGradient.GetIsEmpty: Boolean;
begin
  Result := (PImpl(FBase.FImpl).Size = 0);
end;

function TBLGradient.GetKind: TBLGradientKind;
begin
  Result := TBLGradientKind(_blGradientGetType(@Self));
end;

function TBLGradient.GetLinear: TBLLinearGradientValues;
begin
  Result := PImpl(FBase.FImpl).Linear;
end;

function TBLGradient.GetR0: Double;
begin
  Result := PImpl(FBase.FImpl).Values[TBLGradientValue.RadialR0];
end;

function TBLGradient.GetR1: Double;
begin
  Result := PImpl(FBase.FImpl).Values[TBLGradientValue.RadialR1];
end;

function TBLGradient.GetRadial: TBLRadialGradientValues;
begin
  Result := PImpl(FBase.FImpl).Radial;
end;

function TBLGradient.GetStop(const AIndex: NativeInt): TBLGradientStop;
begin
  Assert(NativeUInt(AIndex) < NativeUInt(GetCount));
  Result := PImpl(FBase.FImpl).Stops[AIndex];
end;

function TBLGradient.GetStopData: PBLGradientStop;
begin
  Result := PImpl(FBase.FImpl).Stops;
end;

function TBLGradient.GetTransform: TBLMatrix2D;
begin
  Result := PImpl(FBase.FImpl).Transform;
end;

function TBLGradient.GetTransformKind: TBLTransformKind;
begin
  Result := TBLTransformKind(_blGradientGetTransformType(@Self));
end;

function TBLGradient.GetValue(const AIndex: NativeInt): Double;
begin
  Assert(NativeUInt(AIndex) <= NativeUInt(High(TBLGradientValue)));
  Result := PImpl(FBase.FImpl).Values[TBLGradientValue(AIndex)];
end;

function TBLGradient.GetX0: Double;
begin
  Result := PImpl(FBase.FImpl).Values[TBLGradientValue.CommonX0];
end;

function TBLGradient.GetX1: Double;
begin
  Result := PImpl(FBase.FImpl).Values[TBLGradientValue.CommonX1];
end;

function TBLGradient.GetY0: Double;
begin
  Result := PImpl(FBase.FImpl).Values[TBLGradientValue.CommonY0];
end;

function TBLGradient.GetY1: Double;
begin
  Result := PImpl(FBase.FImpl).Values[TBLGradientValue.CommonY1];
end;

function TBLGradient.IndexOfStop(const AOffset: Double): NativeInt;
begin
  Result := _blGradientIndexOfStop(@Self, AOffset);
end;

class operator TBLGradient.Initialize(out ADest: TBLGradient);
begin
  _BLCheck(_blGradientInit(@ADest));
end;

procedure TBLGradient.Make(const AValues: TBLConicGradientValues;
  const AExtendMode: TBLExtendMode);
begin
  _BLCheck(_blGradientCreate(@Self, Ord(TBLGradientKind.Conic), @AValues,
    Ord(AExtendMode), nil, 0, nil));
end;

procedure TBLGradient.Make(const AValues: TBLRadialGradientValues;
  const AExtendMode: TBLExtendMode);
begin
  _BLCheck(_blGradientCreate(@Self, Ord(TBLGradientKind.Radial), @AValues,
    Ord(AExtendMode), nil, 0, nil));
end;

procedure TBLGradient.Make(const AValues: TBLLinearGradientValues;
  const AExtendMode: TBLExtendMode);
begin
  _BLCheck(_blGradientCreate(@Self, Ord(TBLGradientKind.Linear), @AValues,
    Ord(AExtendMode), nil, 0, nil));
end;

procedure TBLGradient.Make(const AValues: TBLLinearGradientValues;
  const AExtendMode: TBLExtendMode; const AStops: TArray<TBLGradientStop>);
begin
  _BLCheck(_blGradientCreate(@Self, Ord(TBLGradientKind.Linear), @AValues,
    Ord(AExtendMode), AStops, Length(AStops), nil));
end;

procedure TBLGradient.Make(const AValues: TBLRadialGradientValues;
  const AExtendMode: TBLExtendMode; const AStops: TArray<TBLGradientStop>);
begin
  _BLCheck(_blGradientCreate(@Self, Ord(TBLGradientKind.Radial), @AValues,
    Ord(AExtendMode), AStops, Length(AStops), nil));
end;

procedure TBLGradient.Make(const AValues: TBLConicGradientValues;
  const AExtendMode: TBLExtendMode; const AStops: TArray<TBLGradientStop>);
begin
  _BLCheck(_blGradientCreate(@Self, Ord(TBLGradientKind.Conic), @AValues,
    Ord(AExtendMode), AStops, Length(AStops), nil));
end;

procedure TBLGradient.Make(const AValues: TBLConicGradientValues;
  const AExtendMode: TBLExtendMode; const AStops: TArray<TBLGradientStop>;
  const ATransform: TBLMatrix2D);
begin
  _BLCheck(_blGradientCreate(@Self, Ord(TBLGradientKind.Conic), @AValues,
    Ord(AExtendMode), AStops, Length(AStops), @ATransform));
end;

procedure TBLGradient.Make(const AValues: TBLRadialGradientValues;
  const AExtendMode: TBLExtendMode; const AStops: TArray<TBLGradientStop>;
  const ATransform: TBLMatrix2D);
begin
  _BLCheck(_blGradientCreate(@Self, Ord(TBLGradientKind.Radial), @AValues,
    Ord(AExtendMode), AStops, Length(AStops), @ATransform));
end;

procedure TBLGradient.Make(const AValues: TBLLinearGradientValues;
  const AExtendMode: TBLExtendMode; const AStops: TArray<TBLGradientStop>;
  const ATransform: TBLMatrix2D);
begin
  _BLCheck(_blGradientCreate(@Self, Ord(TBLGradientKind.Linear), @AValues,
    Ord(AExtendMode), AStops, Length(AStops), @ATransform));
end;

class operator TBLGradient.NotEqual(const ALeft: TBLGradient;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsEmpty) then
    Result := (ARight <> nil)
  else
    Result := (ARight = nil);
end;

class operator TBLGradient.NotEqual(const ALeft, ARight: TBLGradient): Boolean;
begin
  Result := not _blGradientEquals(@ALeft, @ARight);
end;

procedure TBLGradient.PostTranslate(const AX, AY: Double);
begin
  var P := BLPoint(AX, AY);
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.PostTranslate), @P));
end;

procedure TBLGradient.PostTranslate(const AP: TBLPoint);
begin
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.PostTranslate), @AP));
end;

procedure TBLGradient.PostScale(const AXY: Double);
begin
  var P := BLPoint(AXY, AXY);
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.PostScale), @P));
end;

procedure TBLGradient.PostScale(const AX, AY: Double);
begin
  var P := BLPoint(AX, AY);
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.PostScale), @P));
end;

procedure TBLGradient.PostScale(const AP: TBLPoint);
begin
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.PostScale), @AP));
end;

procedure TBLGradient.PostRotate(const AAngle: Double);
begin
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.PostRotate), @AAngle));
end;

procedure TBLGradient.PostRotate(const AAngle, AX, AY: Double);
var
  Values: array [0..2] of Double;
begin
  Values[0] := AAngle;
  Values[1] := AX;
  Values[2] := AY;
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.PostRotatePoint), @Values));
end;

procedure TBLGradient.PostRotate(const AAngle: Double; const AOrigin: TBLPoint);
var
  Values: array [0..2] of Double;
begin
  Values[0] := AAngle;
  Values[1] := AOrigin.X;
  Values[2] := AOrigin.Y;
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.PostRotatePoint), @Values));
end;

procedure TBLGradient.PostRotate(const AAngle: Double;
  const AOrigin: TBLPointI);
var
  Values: array [0..2] of Double;
begin
  Values[0] := AAngle;
  Values[1] := AOrigin.X;
  Values[2] := AOrigin.Y;
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.PostRotatePoint), @Values));
end;

procedure TBLGradient.PostScale(const AP: TBLPointI);
begin
  var P := BLPoint(AP.X, AP.Y);
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.PostScale), @P));
end;

procedure TBLGradient.PostSkew(const AP: TBLPoint);
begin
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.PostSkew), @AP));
end;

procedure TBLGradient.PostSkew(const AX, AY: Double);
begin
  var P := BLPoint(AX, AY);
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.PostSkew), @P));
end;

procedure TBLGradient.PostTransform(const ATransform: TBLMatrix2D);
begin
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.PostTransform), @ATransform));
end;

procedure TBLGradient.PostTranslate(const AP: TBLPointI);
begin
  var P := BLPoint(AP.X, AP.Y);
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.PostTranslate), @P));
end;

procedure TBLGradient.RemoveStop(const AIndex: NativeInt);
begin
  _BLCheck(_blGradientRemoveStop(@Self, AIndex));
end;

procedure TBLGradient.RemoveStopByOffset(const AOffset: Double;
  const AAll: Boolean);
begin
  _BLCheck(_blGradientRemoveStopByOffset(@Self, AOffset, Ord(AAll)));
end;

procedure TBLGradient.RemoveStops(const ARange: TBLRange);
begin
  _BLCheck(_blGradientRemoveStopsByIndex(@Self, ARange.Start, ARange.Stop));
end;

procedure TBLGradient.RemoveStopsByOffset(const AOffsetMin, AOffsetMax: Double);
begin
  _BLCheck(_blGradientRemoveStopsByOffset(@Self, AOffsetMin, AOffsetMax));
end;

procedure TBLGradient.ReplaceStop(const AIndex: NativeInt;
  const AOffset: Double; const ARgba64: TBLRgba64);
begin
  _BLCheck(_blGradientReplaceStopRgba64(@Self, AIndex, AOffset, ARgba64.Value));
end;

procedure TBLGradient.ReplaceStop(const AIndex: NativeInt;
  const AOffset: Double; const ARgba32: TBLRgba32);
begin
  _BLCheck(_blGradientReplaceStopRgba32(@Self, AIndex, AOffset, ARgba32.Value));
end;

procedure TBLGradient.ReplaceStop(const AIndex: NativeInt;
  const AOffset: Double; const AColor: TAlphaColor);
begin
  _BLCheck(_blGradientReplaceStopRgba32(@Self, AIndex, AOffset, AColor));
end;

procedure TBLGradient.Reserve(const AMinCapacity: NativeInt);
begin
  _BLCheck(_blGradientReserve(@Self, AMinCapacity));
end;

procedure TBLGradient.Reset;
begin
  _BLCheck(_blGradientReset(@Self));
end;

procedure TBLGradient.ResetExtendMode;
begin
  _BLCheck(_blGradientSetExtendMode(@Self, Ord(TBLExtendMode.Pad)));
end;

procedure TBLGradient.ResetStops;
begin
  _BLCheck(_blGradientResetStops(@Self));
end;

procedure TBLGradient.ResetTransform;
begin
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.Reset), nil));
end;

procedure TBLGradient.Rotate(const AAngle: Double);
begin
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.Rotate), @AAngle));
end;

procedure TBLGradient.Rotate(const AAngle, AX, AY: Double);
var
  Values: array [0..2] of Double;
begin
  Values[0] := AAngle;
  Values[1] := AX;
  Values[2] := AY;
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.RotatePoint), @Values));
end;

procedure TBLGradient.Rotate(const AAngle: Double; const AOrigin: TBLPoint);
var
  Values: array [0..2] of Double;
begin
  Values[0] := AAngle;
  Values[1] := AOrigin.X;
  Values[2] := AOrigin.Y;
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.RotatePoint), @Values));
end;

procedure TBLGradient.Rotate(const AAngle: Double; const AOrigin: TBLPointI);
var
  Values: array [0..2] of Double;
begin
  Values[0] := AAngle;
  Values[1] := AOrigin.X;
  Values[2] := AOrigin.Y;
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.RotatePoint), @Values));
end;

procedure TBLGradient.Scale(const AXY: Double);
begin
  var P := BLPoint(AXY, AXY);
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.Scale), @P));
end;

procedure TBLGradient.Scale(const AX, AY: Double);
begin
  var P := BLPoint(AX, AY);
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.Scale), @P));
end;

procedure TBLGradient.Scale(const AP: TBLPoint);
begin
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.Scale), @AP));
end;

procedure TBLGradient.Scale(const AP: TBLPointI);
begin
  var P := BLPoint(AP.X, AP.Y);
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.Scale), @P));
end;

procedure TBLGradient.SetAngle(const AValue: Double);
begin
  _BLCheck(_blGradientSetValue(@Self, Ord(TBLGradientValue.ConicAngle), AValue));
end;

procedure TBLGradient.SetConic(const AValue: TBLConicGradientValues);
begin
  SetValues(0, @AValue, SizeOf(AValue) div SizeOf(Double));
end;

procedure TBLGradient.SetConicAngle(const AValue: Double);
begin
  _BLCheck(_blGradientSetValue(@Self, Ord(TBLGradientValue.ConicAngle), AValue));
end;

procedure TBLGradient.SetConicRepeat(const AValue: Double);
begin
  _BLCheck(_blGradientSetValue(@Self, Ord(TBLGradientValue.ConicRepeat), AValue));
end;

procedure TBLGradient.SetExtendMode(const AValue: TBLExtendMode);
begin
  _BLCheck(_blGradientSetExtendMode(@Self, Ord(AValue)));
end;

procedure TBLGradient.SetKind(const AValue: TBLGradientKind);
begin
  _BLCheck(_blGradientSetType(@Self, Ord(AValue)));
end;

procedure TBLGradient.SetLinear(const AValue: TBLLinearGradientValues);
begin
  SetValues(0, @AValue, SizeOf(AValue) div SizeOf(Double));
end;

procedure TBLGradient.SetR0(const AValue: Double);
begin
  _BLCheck(_blGradientSetValue(@Self, Ord(TBLGradientValue.RadialR0), AValue));
end;

procedure TBLGradient.SetR1(const AValue: Double);
begin
  _BLCheck(_blGradientSetValue(@Self, Ord(TBLGradientValue.RadialR1), AValue));
end;

procedure TBLGradient.SetRadial(const AValue: TBLRadialGradientValues);
begin
  SetValues(0, @AValue, SizeOf(AValue) div SizeOf(Double));
end;

procedure TBLGradient.SetTransform(const AValue: TBLMatrix2D);
begin
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.Assign), @AValue));
end;

procedure TBLGradient.SetValue(const AIndex: NativeInt; const AValue: Double);
begin
  Assert(NativeUInt(AIndex) <= NativeUInt(High(TBLGradientValue)));
  _BLCheck(_blGradientSetValue(@Self, AIndex, AValue));
end;

procedure TBLGradient.SetValues(const AValues: TBLLinearGradientValues);
begin
  _BLCheck(_blGradientSetValues(@Self, 0, @AValues, SizeOf(TBLLinearGradientValues) div SizeOf(Double)));
end;

procedure TBLGradient.SetValues(const AValues: TBLRadialGradientValues);
begin
  _BLCheck(_blGradientSetValues(@Self, 0, @AValues, SizeOf(TBLRadialGradientValues) div SizeOf(Double)));
end;

procedure TBLGradient.SetValues(const AValues: TBLConicGradientValues);
begin
  _BLCheck(_blGradientSetValues(@Self, 0, @AValues, SizeOf(TBLConicGradientValues) div SizeOf(Double)));
end;

procedure TBLGradient.SetValues(const AIndex: NativeInt; const AValues: PDouble;
  const ACount: NativeInt);
begin
  _BLCheck(_blGradientSetValues(@Self, AIndex, AValues, ACount));
end;

procedure TBLGradient.SetX0(const AValue: Double);
begin
  _BLCheck(_blGradientSetValue(@Self, Ord(TBLGradientValue.CommonX0), AValue));
end;

procedure TBLGradient.SetX1(const AValue: Double);
begin
  _BLCheck(_blGradientSetValue(@Self, Ord(TBLGradientValue.CommonX1), AValue));
end;

procedure TBLGradient.SetY0(const AValue: Double);
begin
  _BLCheck(_blGradientSetValue(@Self, Ord(TBLGradientValue.CommonY0), AValue));
end;

procedure TBLGradient.SetY1(const AValue: Double);
begin
  _BLCheck(_blGradientSetValue(@Self, Ord(TBLGradientValue.CommonY1), AValue));
end;

procedure TBLGradient.Shrink;
begin
  _BLCheck(_blGradientShrink(@Self));
end;

procedure TBLGradient.Skew(const AP: TBLPoint);
begin
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.Skew), @AP));
end;

procedure TBLGradient.Skew(const AX, AY: Double);
begin
  var P := BLPoint(AX, AY);
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.Skew), @P));
end;

function TBLGradient.StopsView: TBLArrayView<TBLGradientStop>;
begin
  var Impl := PImpl(FBase.FImpl);
  Result.Reset(Pointer(Impl.Stops), Impl.Size);
end;

procedure TBLGradient.SetValues(const AIndex: NativeInt;
  const AValues: TArray<Double>);
begin
  _BLCheck(_blGradientSetValues(@Self, AIndex, PDouble(AValues), Length(AValues)));
end;

procedure TBLGradient.Swap(var AOther: TBLGradient);
begin
  FBase.Swap(AOther.FBase);
end;

procedure TBLGradient.Translate(const AX, AY: Double);
begin
  var P := BLPoint(AX, AY);
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.Translate), @P));
end;

procedure TBLGradient.Translate(const AP: TBLPoint);
begin
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.Translate), @AP));
end;

procedure TBLGradient.Translate(const AP: TBLPointI);
begin
  var P := BLPoint(AP.X, AP.Y);
  _BLCheck(_blGradientApplyTransformOp(@Self, Ord(TBLTransformOp.Translate), @P));
end;
{$ENDREGION 'Styling'}

{$REGION 'Text'}

{ TBLTextMetrics }

procedure TBLTextMetrics.Reset;
begin
  FillChar(Self, SizeOf(Self), 0);
end;

{ TBLGlyphPlacement }

procedure TBLGlyphPlacement.Reset;
begin
  FillChar(Self, SizeOf(Self), 0);
end;

{ TBLGlyphRun }

function TBLGlyphRun.GetCount: NativeInt;
begin
  Result := FCount;
end;

function TBLGlyphRun.GetFlags: TBLGlyphRunFlags;
begin
  Cardinal(Result) := FFlags;
end;

function TBLGlyphRun.GetGlyphDataAsGlyphIds: PBLGlyphId;
begin
  Result := FGlyphData;
end;

function TBLGlyphRun.GetIsEmpty: Boolean;
begin
  Result := (FCount = 0);
end;

function TBLGlyphRun.GetPlacementDataAsGlyphPlacements: PBLGlyphPlacement;
begin
  Result := FPlacementData;
end;

function TBLGlyphRun.GetPlacementDataAsPoints: PBLPoint;
begin
  Result := FPlacementData;
end;

function TBLGlyphRun.GetPlacementType: TBLGlyphPlacementType;
begin
  Result := TBLGlyphPlacementType(FPlacementType);
end;

procedure TBLGlyphRun.Reset;
begin
  FillChar(Self, SizeOf(Self), 0);
end;

procedure TBLGlyphRun.ResetGlyphIdData;
begin
  FGlyphData := nil;
  FGlyphAdvance := 0;
end;

procedure TBLGlyphRun.ResetPlacementData;
begin
  FPlacementData := nil;
  FPlacementAdvance := 0;
end;

procedure TBLGlyphRun.SetGlyphData(const AData: Pointer;
  const AAdvance: ShortInt);
begin
  FGlyphData := AData;
  FGlyphAdvance := AAdvance;
end;

procedure TBLGlyphRun.SetPlacementData(const AData: PBLGlyphPlacement);
begin
  FPlacementData := AData;
  FPlacementAdvance := SizeOf(TBLGlyphPlacement);
end;

procedure TBLGlyphRun.SetPlacementData(const AData: PBLPoint);
begin
  FPlacementData := AData;
  FPlacementAdvance := SizeOf(TBLPoint);
end;

procedure TBLGlyphRun.SetPlacementData(const AData: Pointer;
  const AAdvance: ShortInt);
begin
  FPlacementData := AData;
  FPlacementAdvance := AAdvance;
end;

procedure TBLGlyphRun.SetGlyphData(const AGlyphData: PBLGlyphId);
begin
  FGlyphData := AGlyphData;
  FGlyphAdvance := SizeOf(UInt32);
end;

{ TBLGlyphRunIterator }

procedure TBLGlyphRunIterator.Advance;
begin
  Assert(not AtEnd);
  Inc(FIndex);
  Inc(PByte(FGlyphData), FGlyphAdvance);
  Inc(PByte(FPlacementData), FPlacementAdvance);
end;

function TBLGlyphRunIterator.AtEnd: Boolean;
begin
  Result := (FIndex = FCount);
end;

constructor TBLGlyphRunIterator.Create(const AGlyphRun: TBLGlyphRun);
begin
  Reset(AGlyphRun);
end;

function TBLGlyphRunIterator.GetGlyphId: TBLGlyphId;
begin
  Result := PBLGlyphId(FGlyphData)^;
end;

function TBLGlyphRunIterator.GetHasPlacement: Boolean;
begin
  Result := (FPlacementData <> nil);
end;

function TBLGlyphRunIterator.GetIsEmpty: Boolean;
begin
  Result := (FCount = 0);
end;

function TBLGlyphRunIterator.GetPlacementAsGlyphPlacement: TBLGlyphPlacement;
begin
  Result := PBLGlyphPlacement(FPlacementData)^;
end;

function TBLGlyphRunIterator.GetPlacementAsPoint: TBLPoint;
begin
  Result := PBLPoint(FPlacementData)^;
end;

class operator TBLGlyphRunIterator.Initialize(out ADest: TBLGlyphRunIterator);
begin
  FillChar(ADest, SizeOf(ADest), 0);
end;

function TBLGlyphRunIterator.Placement<T>: T;
type
  P = ^T;
begin
  Result := P(FPlacementData)^;
end;

procedure TBLGlyphRunIterator.Reset(const AGlyphRun: TBLGlyphRun);
begin
  FIndex := 0;
  FCount := AGlyphRun.FCount;
  FGlyphData := AGlyphRun.FGlyphData;
  FPlacementData := AGlyphRun.FPlacementData;
  FGlyphAdvance := AGlyphRun.FGlyphAdvance;
  FPlacementAdvance := AGlyphRun.FPlacementAdvance;
end;

procedure TBLGlyphRunIterator.Reset;
begin
  FillChar(Self, SizeOf(Self), 0);
end;

{ TBLGlyphInfo }

procedure TBLGlyphInfo.Reset;
begin
  FCluster := 0;
  FReserved := 0;
end;

{ TBLGlyphBuffer }

class operator TBLGlyphBuffer.Assign(var ADest: TBLGlyphBuffer;
  const [ref] ASrc: TBLGlyphBuffer);
begin
  raise EBlend2DError.Create(TBLResult.NotPermitted);
end;

procedure TBLGlyphBuffer.Clear;
begin
  _BLCheck(_blGlyphBufferClear(@Self));
end;

class function TBLGlyphBuffer.ConvertSize(const ASize: NativeInt): Size_T;
begin
  if (ASize < 0) then
    Result := Size_T.MaxValue
  else
    Result := ASize;
end;

class operator TBLGlyphBuffer.Equal(const ALeft: TBLGlyphBuffer;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsEmpty) then
    Result := (ARight = nil)
  else
    Result := (ARight <> nil);
end;

class operator TBLGlyphBuffer.Finalize(var ADest: TBLGlyphBuffer);
begin
  _BLCheck(_blGlyphBufferDestroy(@ADest));
end;

function TBLGlyphBuffer.GetContent: PUInt32;
begin
  Result := PImpl(FBase.FImpl).Content;
end;

function TBLGlyphBuffer.GetCount: NativeInt;
begin
  Result := PImpl(FBase.FImpl).Size;
end;

function TBLGlyphBuffer.GetFlags: TBLGlyphRunFlags;
begin
  Cardinal(Result) := PImpl(FBase.FImpl).Flags;
end;

function TBLGlyphBuffer.GetGlyphRun: TBLGlyphRun;
begin
  Result := PImpl(FBase.FImpl).GlyphRun;
end;

function TBLGlyphBuffer.GetHasGlyphs: Boolean;
begin
  Result := not (TBLGlyphRunFlag.Ucs4Content in GetFlags);
end;

function TBLGlyphBuffer.GetHasInvalidChars: Boolean;
begin
  Result := (TBLGlyphRunFlag.InvalidText in GetFlags);
end;

function TBLGlyphBuffer.GetHasInvalidFontData: Boolean;
begin
  Result := (TBLGlyphRunFlag.InvalidFontData in GetFlags);
end;

function TBLGlyphBuffer.GetHasText: Boolean;
begin
  Result := (TBLGlyphRunFlag.Ucs4Content in GetFlags);
end;

function TBLGlyphBuffer.GetHasUndefinedChars: Boolean;
begin
  Result := (TBLGlyphRunFlag.UndefinedGlyphs in GetFlags);
end;

function TBLGlyphBuffer.GetInfoData: PBLGlyphInfo;
begin
  Result := PImpl(FBase.FImpl).InfoData;
end;

function TBLGlyphBuffer.GetIsEmpty: Boolean;
begin
  Result := PImpl(FBase.FImpl).GlyphRun.IsEmpty;
end;

function TBLGlyphBuffer.GetPlacementData: PBLGlyphPlacement;
begin
  Result := PImpl(FBase.FImpl).PlacementData;
end;

function TBLGlyphBuffer.HasFlag(const AFlag: TBLGlyphRunFlag): Boolean;
begin
  Result := (AFlag in GetFlags);
end;

class operator TBLGlyphBuffer.Initialize(out ADest: TBLGlyphBuffer);
begin
  _BLCheck(_blGlyphBufferInit(@ADest));
end;

class operator TBLGlyphBuffer.NotEqual(const ALeft: TBLGlyphBuffer;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsEmpty) then
    Result := (ARight <> nil)
  else
    Result := (ARight = nil);
end;

procedure TBLGlyphBuffer.Reset;
begin
  _BLCheck(_blGlyphBufferReset(@Self));
end;

procedure TBLGlyphBuffer.ResetDebugSink;
begin
  _BLCheck(_blGlyphBufferResetDebugSink(@Self));
end;

procedure TBLGlyphBuffer.SetDebugSink(const ASink: TBLDebugMessageSinkFunc;
  const AUserData: Pointer);
begin
  _BLCheck(_blGlyphBufferSetDebugSink(@Self, ASink, AUserData));
end;

procedure TBLGlyphBuffer.SetGlyphs(const AGlyphData: PUInt32;
  const ACount: NativeInt);
begin
  _BLCheck(_blGlyphBufferSetGlyphs(@Self, AGlyphData, ACount));
end;

procedure TBLGlyphBuffer.SetGlyphsFromRecord(const AGlyphData: Pointer;
  const ACount, AGlyphIdSize, AGlyphAdvance: NativeInt);
begin
  _BLCheck(_blGlyphBufferSetGlyphsFromStruct(@Self, AGlyphData, ACount,
    AGlyphIdSize, AGlyphAdvance));
end;

procedure TBLGlyphBuffer.SetGlyphs(const AGlyphData: TArray<UInt32>);
begin
  _BLCheck(_blGlyphBufferSetGlyphs(@Self, Pointer(AGlyphData), Length(AGlyphData)));
end;

procedure TBLGlyphBuffer.SetLatin1Text(const AText: PAnsiChar;
  const ALength: NativeInt);
begin
  _BLCheck(_blGlyphBufferSetText(@Self, AText, ConvertSize(ALength), Ord(TBLTextEncoding.Latin1)));
end;

procedure TBLGlyphBuffer.SetText(const AText: AnsiString);
begin
  _BLCheck(_blGlyphBufferSetText(@Self, Pointer(AText), Length(AText), Ord(TBLTextEncoding.Latin1)));
end;

procedure TBLGlyphBuffer.SetText(const AText: UTF8String);
begin
  _BLCheck(_blGlyphBufferSetText(@Self, Pointer(AText), Length(AText), Ord(TBLTextEncoding.Utf8)));
end;

procedure TBLGlyphBuffer.SetText(const AText: String);
begin
  _BLCheck(_blGlyphBufferSetText(@Self, Pointer(AText), Length(AText), Ord(TBLTextEncoding.Utf16)));
end;

procedure TBLGlyphBuffer.SetText(const ATextData: Pointer;
  const ASize: NativeInt; const AEncoding: TBLTextEncoding);
begin
  _BLCheck(_blGlyphBufferSetText(@Self, ATextData, ConvertSize(ASize), Ord(AEncoding)));
end;

procedure TBLGlyphBuffer.SetText(const AText: UCS4String);
begin
  _BLCheck(_blGlyphBufferSetText(@Self, Pointer(AText), Length(AText) - 1, Ord(TBLTextEncoding.Utf32)));
end;

procedure TBLGlyphBuffer.SetUtf16Text(const AText: PWideChar;
  const ALength: NativeInt);
begin
  _BLCheck(_blGlyphBufferSetText(@Self, AText, ConvertSize(ALength), Ord(TBLTextEncoding.Utf16)));
end;

procedure TBLGlyphBuffer.SetUtf32Text(const AText: PUCS4Char;
  const ALength: NativeInt);
begin
  _BLCheck(_blGlyphBufferSetText(@Self, AText, ConvertSize(ALength), Ord(TBLTextEncoding.Utf32)));
end;

procedure TBLGlyphBuffer.SetUtf8Text(const AText: PUTF8Char;
  const ALength: NativeInt);
begin
  _BLCheck(_blGlyphBufferSetText(@Self, AText, ConvertSize(ALength), Ord(TBLTextEncoding.Utf8)));
end;

{ TBLGlyphMappingState }

function TBLGlyphMappingState.GetGlyphCount: NativeInt;
begin
  Result := FGlyphCount;
end;

function TBLGlyphMappingState.GetUndefinedCount: NativeInt;
begin
  Result := FUndefinedCount;
end;

function TBLGlyphMappingState.GetUndefinedFirst: NativeInt;
begin
  if (FUndefinedFirst = Size_T.MaxValue) then
    Result := -1
  else
    Result := FUndefinedFirst;
end;

procedure TBLGlyphMappingState.Reset;
begin
  FGlyphCount := 0;
  FUndefinedFirst := 0;
  FUndefinedCount := 0;
end;

{ TBLFontTable }

function TBLFontTable.GetIsEmpty: Boolean;
begin
  Result := (FSize = 0);
end;

function TBLFontTable.GetSize: NativeInt;
begin
  Result := FSize;
end;

procedure TBLFontTable.Reset;
begin
  FData := nil;
  FSize := 0;
end;

procedure TBLFontTable.Reset(const AData: Pointer; const ASize: NativeInt);
begin
  FData := AData;
  FSize := ASize;
end;

{ TBLFontData }

class operator TBLFontData.Assign(var ADest: TBLFontData;
  const [ref] ASrc: TBLFontData);
begin
  _BLCheck(_blFontDataInitWeak(@ADest, @ASrc));
end;

class operator TBLFontData.Equal(const ALeft: TBLFontData;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsEmpty) then
    Result := (ARight = nil)
  else
    Result := (ARight <> nil);
end;

class procedure TBLFontData.DestroyDynArray(impl, externalData,
  userData: Pointer);
begin
  var Data: TBytes;
  Pointer(Data) := userData;
  // Exiting will decrease ref count
end;

class operator TBLFontData.Equal(const ALeft, ARight: TBLFontData): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLFontData.Equals(const AOther: TBLFontData): Boolean;
begin
  Result := _blFontDataEquals(@Self, @AOther);
end;

class operator TBLFontData.Finalize(var ADest: TBLFontData);
begin
  if (ADest.FBase.NeedsCleanup) then
    _BLCheck(_blFontDataDestroy(@ADest));
end;

function TBLFontData.GetFaceCount: Integer;
begin
  Result := PImpl(FBase.FImpl).FaceCount;
end;

function TBLFontData.GetFaceType: TBLFontFaceType;
begin
  Result := TBLFontFaceType(PImpl(FBase.FImpl).FaceType);
end;

function TBLFontData.GetFlags: TBLFontDataFlags;
begin
  Byte(Result) := (PImpl(FBase.FImpl).Flags);
end;

function TBLFontData.GetIsCollection: Boolean;
begin
  Result := (TBLFontDataFlag.Collection in GetFlags);
end;

function TBLFontData.GetIsEmpty: Boolean;
begin
  Result := (PImpl(FBase.FImpl).FaceCount = 0);
end;

function TBLFontData.GetIsValid: Boolean;
begin
  Result := (PImpl(FBase.FImpl).FaceCount <> 0);
end;

function TBLFontData.GetTable(const AFaceIndex: Integer;
  const ATag: TBLTag): TBLFontTable;
begin
  _blFontDataGetTables(@Self, AFaceIndex, @Result, @ATag, 1);
end;

function TBLFontData.GetTables(const AFaceIndex: Integer;
  const ATags: TArray<TBLTag>): TArray<TBLFontTable>;
begin
  var Tables: PBLFontTable := nil;
  var Count := _blFontDataGetTables(@Self, AFaceIndex, Tables, @ATags, Length(ATags));
  SetLength(Result, Count);
  Move(Tables^, Result[0], Count * SizeOf(TBLFontTable));
end;

function TBLFontData.GetTableTags(const AFaceIndex: Integer): TArray<TBLTag>;
begin
  var Dst: TBLArray<TBLTag>;
  _BLCheck(_blFontDataGetTableTags(@Self, AFaceIndex, @Dst));
  Result := Dst.ToArray;
end;

procedure TBLFontData.GetTableTags(const AFaceIndex: Integer;
  const ADst: TBLArray<TBLTag>);
begin
  _BLCheck(_blFontDataGetTableTags(@Self, AFaceIndex, @ADst));
end;

class operator TBLFontData.Initialize(out ADest: TBLFontData);
begin
  _BLCheck(_blFontDataInit(@ADest));
end;

procedure TBLFontData.MakeFromData(const AData: TBLArray<Byte>);
begin
  _BLCheck(_blFontDataCreateFromDataArray(@Self, @AData));
end;

procedure TBLFontData.MakeFromData(const AData: Pointer; const ASize: NativeInt;
  const ADestroyFunc: TBLDestroyExternalDataFunc; const AUserData: Pointer);
begin
  _BLCheck(_blFontDataCreateFromData(@Self, AData, ASize, ADestroyFunc, AUserData));
end;

procedure TBLFontData.MakeFromData(const AData: TBytes);
begin
  var Copy := AData;     // Increase ref count
  var Result := _blFontDataCreateFromData(@Self, Pointer(AData), Length(AData),
    DestroyDynArray, Pointer(AData));
  if (Result = 0) then
    Pointer(Copy) := nil // Does NOT decrease ref count
  else
    _BLCheck(Result);
end;

procedure TBLFontData.MakeFromFile(const AFilename: String;
  const AReadFlags: TBLFileReadFlags);
begin
  _BLCheck(_blFontDataCreateFromFile(@Self, PUTF8Char(UTF8String(AFilename)),
    Byte(AReadFlags)));
end;

class operator TBLFontData.NotEqual(const ALeft: TBLFontData;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsEmpty) then
    Result := (ARight <> nil)
  else
    Result := (ARight = nil);
end;

class operator TBLFontData.NotEqual(const ALeft, ARight: TBLFontData): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLFontData.Reset;
begin
  _BLCheck(_blFontDataReset(@Self));
end;

procedure TBLFontData.Swap(var AOther: TBLFontData);
begin
  FBase.Swap(AOther.FBase);
end;

{ TBLFontFaceInfo }

function TBLFontFaceInfo.GetDiagFlags: TBLFontFaceDiagFlags;
begin
  Byte(Result) := FDiagFlags;
end;

function TBLFontFaceInfo.GetFaceFlags: TBLFontFaceFlags;
begin
  Cardinal(Result) := FFaceFlags;
end;

function TBLFontFaceInfo.GetFaceType: TBLFontFaceType;
begin
  Result := TBLFontFaceType(FFaceType);
end;

function TBLFontFaceInfo.GetOutlineType: TBLFontOutlineType;
begin
  Result := TBLFontOutlineType(FOutlineType);
end;

procedure TBLFontFaceInfo.Reset;
begin
  FillChar(Self, SizeOf(Self), 0);
end;

{ TBLFontDesignMetrics }

procedure TBLFontDesignMetrics.Reset;
begin
  FillChar(Self, SizeOf(Self), 0);
end;

{ TBLFontUnicodeCoverage }

procedure TBLFontUnicodeCoverage.ClearBit(const AIndex: Integer);
begin
  Assert(Cardinal(AIndex) < 128);
  var I := AIndex shr 5;
  FData[I] := FData[I] and not (UInt32(1) shl (AIndex and 31));
end;

class operator TBLFontUnicodeCoverage.Equal(const ALeft,
  ARight: TBLFontUnicodeCoverage): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLFontUnicodeCoverage.Equals(
  const AOther: TBLFontUnicodeCoverage): Boolean;
begin
  Result := (FData[0] = AOther.FData[0])
        and (FData[1] = AOther.FData[1])
        and (FData[2] = AOther.FData[2])
        and (FData[3] = AOther.FData[3]);
end;

function TBLFontUnicodeCoverage.GetIsEmpty: Boolean;
begin
  Result := ((FData[0] or FData[1] or FData[2] or FData[3]) = 0);
end;

function TBLFontUnicodeCoverage.HasBit(const AIndex: Integer): Boolean;
begin
  Assert(Cardinal(AIndex) < 128);
  var I := AIndex shr 5;
  Result := ((FData[I] and (UInt32(1) shl (AIndex and 31))) <> 0);
end;

class operator TBLFontUnicodeCoverage.NotEqual(const ALeft,
  ARight: TBLFontUnicodeCoverage): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLFontUnicodeCoverage.Reset;
begin
  FillChar(Self, SizeOf(Self), 0);
end;

procedure TBLFontUnicodeCoverage.SetBit(const AIndex: Integer);
begin
  Assert(Cardinal(AIndex) < 128);
  var I := AIndex shr 5;
  FData[I] := FData[I] or (UInt32(1) shl (AIndex and 31));
end;

procedure TBLFontUnicodeCoverage.SetBitValue(const AIndex: Integer;
  const AValue: Boolean);
begin
  if (AValue) then
    SetBit(AIndex)
  else
    ClearBit(AIndex);
end;

{ TBLFontPanose }

function TBLFontPanose.GetDecorative: TDecorative;
begin
  Move(FData, Result, SizeOf(Result));
end;

function TBLFontPanose.GetFamilyKind: Byte;
begin
  Result := FData[0];
end;

function TBLFontPanose.GetIsEmpty: Boolean;
begin
  Result := ((FData[0] or FData[1] or FData[2] or FData[3] or FData[4]
           or FData[5] or FData[6] or FData[7] or FData[8] or FData[9]) = 0);
end;

function TBLFontPanose.GetScript: TScript;
begin
  Move(FData, Result, SizeOf(Result));
end;

function TBLFontPanose.GetSymbol: TSymbol;
begin
  Move(FData, Result, SizeOf(Result));
end;

function TBLFontPanose.GetText: TText;
begin
  Move(FData, Result, SizeOf(Result));
end;

procedure TBLFontPanose.Reset;
begin
  FillChar(Self, SizeOf(Self), 0);
end;

{ TBLFontFace }

class operator TBLFontFace.Assign(var ADest: TBLFontFace;
  const [ref] ASrc: TBLFontFace);
begin
  _BLCheck(_blFontFaceInitWeak(@ADest, @ASrc));
end;

class operator TBLFontFace.Equal(const ALeft: TBLFontFace;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsEmpty) then
    Result := (ARight = nil)
  else
    Result := (ARight <> nil);
end;

class operator TBLFontFace.Equal(const ALeft, ARight: TBLFontFace): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLFontFace.Equals(const AOther: TBLFontFace): Boolean;
begin
  Result := _blFontFaceEquals(@Self, @AOther);
end;

class operator TBLFontFace.Finalize(var ADest: TBLFontFace);
begin
  if (ADest.FBase.NeedsCleanup) then
    _BLCheck(_blFontFaceDestroy(@ADest));
end;

function TBLFontFace.GetData: TBLFontData;
begin
  _blFontFaceAssignWeak(@Result, @PImpl(FBase.FImpl).Data);
end;

function TBLFontFace.GetDesignMetrics: PBLFontDesignMetrics;
begin
  Result := @PImpl(FBase.FImpl).DesignMetrics;
end;

function TBLFontFace.GetDiagFlags: TBLFontFaceDiagFlags;
begin
  Result := PImpl(FBase.FImpl).FaceInfo.DiagFlags;
end;

function TBLFontFace.GetFaceFlags: TBLFontFaceFlags;
begin
  Result := PImpl(FBase.FImpl).FaceInfo.FaceFlags;
end;

function TBLFontFace.GetFaceIndex: Integer;
begin
  Result := PImpl(FBase.FImpl).FaceInfo.FFaceIndex;
end;

function TBLFontFace.GetFaceInfo: PBLFontFaceInfo;
begin
  Result := @PImpl(FBase.FImpl).FaceInfo;
end;

function TBLFontFace.GetFaceType: TBLFontFaceType;
begin
  Result := PImpl(FBase.FImpl).FaceInfo.FaceType;
end;

function TBLFontFace.GetFamilyName: TBLString;
begin
  _blStringAssignWeak(@Result, @PImpl(FBase.FImpl).FamilyName);
end;

procedure TBLFontFace.GetFeatureTags(const AOut: TBLArray<TBLTag>);
begin
  _BLCheck(_blFontFaceGetFeatureTags(@Self, @AOut));
end;

function TBLFontFace.GetFeatureTags: TArray<TBLTag>;
begin
  var Tags: TBLArray<TBLTag>;
  _BLCheck(_blFontFaceGetFeatureTags(@Self, @Tags));
  Result := Tags.ToArray;
end;

function TBLFontFace.GetFullName: TBLString;
begin
  _blStringAssignWeak(@Result, @PImpl(FBase.FImpl).FullName);
end;

function TBLFontFace.GetGlyphCount: Integer;
begin
  Result := PImpl(FBase.FImpl).FaceInfo.FGlyphCount;
end;

function TBLFontFace.GetHasBaselineYAt0: Boolean;
begin
  Result := HasFaceFlag(TBLFontFaceFlag.BaselineYEquals0);
end;

function TBLFontFace.GetHasCharToGlyphMapping: Boolean;
begin
  Result := HasFaceFlag(TBLFontFaceFlag.CharToGlyphMapping);
end;

function TBLFontFace.GetHasHorizontalKerning: Boolean;
begin
  Result := HasFaceFlag(TBLFontFaceFlag.HorizontalKerning);
end;

function TBLFontFace.GetHasHorizontalMetrics: Boolean;
begin
  Result := HasFaceFlag(TBLFontFaceFlag.HorizontalMetrics);
end;

function TBLFontFace.GetHasLsbPointXAt0: Boolean;
begin
  Result := HasFaceFlag(TBLFontFaceFlag.LsbPointXEquals0);
end;

function TBLFontFace.GetHasOpenTypeFeatures: Boolean;
begin
  Result := HasFaceFlag(TBLFontFaceFlag.OpenTypeFeatures);
end;

function TBLFontFace.GetHasOpenTypeVariations: Boolean;
begin
  Result := HasFaceFlag(TBLFontFaceFlag.OpenTypeVariations);
end;

function TBLFontFace.GetHasPanoseData: Boolean;
begin
  Result := HasFaceFlag(TBLFontFaceFlag.PanoseData);
end;

function TBLFontFace.GetHasTypographicMetrics: Boolean;
begin
  Result := HasFaceFlag(TBLFontFaceFlag.TypographicMetrics);
end;

function TBLFontFace.GetHasTypographicNames: Boolean;
begin
  Result := HasFaceFlag(TBLFontFaceFlag.TypographicNames);
end;

function TBLFontFace.GetHasUnicodeCoverage: Boolean;
begin
  Result := HasFaceFlag(TBLFontFaceFlag.UnicodeCoverage);
end;

function TBLFontFace.GetHasVariationSequences: Boolean;
begin
  Result := HasFaceFlag(TBLFontFaceFlag.VariationSequences);
end;

function TBLFontFace.GetHasVerticalKerning: Boolean;
begin
  Result := HasFaceFlag(TBLFontFaceFlag.VerticalKerning);
end;

function TBLFontFace.GetHasVerticalMetrics: Boolean;
begin
  Result := HasFaceFlag(TBLFontFaceFlag.VerticalMetrics);
end;

function TBLFontFace.GetIsEmpty: Boolean;
begin
  Result := not GetIsValid;
end;

function TBLFontFace.GetIsLastResortFont: Boolean;
begin
  Result := HasFaceFlag(TBLFontFaceFlag.LastResortFont);
end;

function TBLFontFace.GetIsSymbolFont: Boolean;
begin
  Result := HasFaceFlag(TBLFontFaceFlag.SymbolFont);
end;

function TBLFontFace.GetIsValid: Boolean;
begin
  Result := (PImpl(FBase.FImpl).FaceInfo.FFaceType <> 0);
end;

function TBLFontFace.GetOutlineType: TBLFontOutlineType;
begin
  Result := PImpl(FBase.FImpl).FaceInfo.OutlineType;
end;

function TBLFontFace.GetPanose: PBLFontPanose;
begin
  Result := @PImpl(FBase.FImpl).Panose;
end;

function TBLFontFace.GetPostScriptName: TBLString;
begin
  _blStringAssignWeak(@Result, @PImpl(FBase.FImpl).PostscriptName);
end;

procedure TBLFontFace.GetScriptTags(const AOut: TBLArray<TBLTag>);
begin
  _BLCheck(_blFontFaceGetScriptTags(@Self, @AOut));
end;

function TBLFontFace.GetScriptTags: TArray<TBLTag>;
begin
  var Tags: TBLArray<TBLTag>;
  _BLCheck(_blFontFaceGetScriptTags(@Self, @Tags));
  Result := Tags.ToArray;
end;

function TBLFontFace.GetStretch: TBLFontStretch;
begin
  Result := TBLFontStretch(PImpl(FBase.FImpl).Stretch);
end;

function TBLFontFace.GetStyle: TBLFontStyle;
begin
  Result := TBLFontStyle(PImpl(FBase.FImpl).Style);
end;

function TBLFontFace.GetSubfamilyName: TBLString;
begin
  _blStringAssignWeak(@Result, @PImpl(FBase.FImpl).SubfamilyName);
end;

function TBLFontFace.GetUnicodeCoverage: PBLFontUnicodeCoverage;
begin
  Result := @PImpl(FBase.FImpl).UnicodeCoverage;
end;

function TBLFontFace.GetUniqueId: TBLUniqueId;
begin
  Result := PImpl(FBase.FImpl).UniqueId;
end;

function TBLFontFace.GetUnitsPerEm: Integer;
begin
  Result := PImpl(FBase.FImpl).DesignMetrics.FUnitsPerEm;
end;

procedure TBLFontFace.GetVariationTags(const AOut: TBLArray<TBLTag>);
begin
  _BLCheck(_blFontFaceGetVariationTags(@Self, @AOut));
end;

function TBLFontFace.GetVariationTags: TArray<TBLTag>;
begin
  var Tags: TBLArray<TBLTag>;
  _BLCheck(_blFontFaceGetVariationTags(@Self, @Tags));
  Result := Tags.ToArray;
end;

function TBLFontFace.GetWeight: TBLFontWeight;
begin
  Result := TBLFontWeight(PImpl(FBase.FImpl).Weight);
end;

function TBLFontFace.HasFaceFlag(const AFlag: TBLFontFaceFlag): Boolean;
begin
  Result := (AFlag in GetFaceFlags);
end;

function TBLFontFace.HasFeatureTag(const AFeatureTag: TBLTag): Boolean;
begin
  Result := _blFontFaceHasFeatureTag(@Self, AFeatureTag);
end;

function TBLFontFace.HasScriptTag(const AScriptTag: TBLTag): Boolean;
begin
  Result := _blFontFaceHasScriptTag(@Self, AScriptTag);
end;

function TBLFontFace.HasVariationTag(const AVariationTag: TBLTag): Boolean;
begin
  Result := _blFontFaceHasVariationTag(@Self, AVariationTag);
end;

class operator TBLFontFace.Initialize(out ADest: TBLFontFace);
begin
  _BLCheck(_blFontFaceInit(@ADest));
end;

procedure TBLFontFace.MakeFromData(const AFontData: TBLFontData;
  const AFaceIndex: Integer);
begin
  _BLCheck(_blFontFaceCreateFromData(@Self, @AFontData, AFaceIndex));
end;

procedure TBLFontFace.MakeFromFile(const AFilename: String;
  const AReadFlags: TBLFileReadFlags);
begin
  _BLCheck(_blFontFaceCreateFromFile(@Self, PUTF8Char(UTF8String(AFilename)), Byte(AReadFlags)));
end;

class operator TBLFontFace.NotEqual(const ALeft: TBLFontFace;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsEmpty) then
    Result := (ARight <> nil)
  else
    Result := (ARight = nil);
end;

class operator TBLFontFace.NotEqual(const ALeft, ARight: TBLFontFace): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLFontFace.Reset;
begin
  _BLCheck(_blFontFaceReset(@Self));
end;

procedure TBLFontFace.Swap(var AOther: TBLFontFace);
begin
  FBase.Swap(AOther.FBase);
end;

{ TBLFontMatrix }

class function TBLFontMatrix.Create: TBLFontMatrix;
begin
  Result.Reset;
end;

constructor TBLFontMatrix.Create(const AM00, AM01, AM10, AM11: Double);
begin
  M[0] := AM00;
  M[1] := AM01;
  M[2] := AM10;
  M[3] := AM11;
end;

procedure TBLFontMatrix.Reset;
begin
  M[0] := 1;
  M[1] := 0;
  M[2] := 0;
  M[3] := 1;
end;

procedure TBLFontMatrix.Reset(const AM00, AM01, AM10, AM11: Double);
begin
  M[0] := AM00;
  M[1] := AM01;
  M[2] := AM10;
  M[3] := AM11;
end;

{ TBLFontMetrics }

procedure TBLFontMetrics.Reset;
begin
  FillChar(Self, SizeOf(Self), 0);
end;

{ TBLFontFeatureItem }

procedure TBLFontFeatureItem.Reset;
begin
  FTag := 0;
  FValue := 0;
end;

{ TBLFontFeatureSettingsView }

function TBLFontFeatureSettingsView.GetCount: NativeInt;
begin
  Result := FCount;
end;

function TBLFontFeatureSettingsView.GetIsEmpty: Boolean;
begin
  Result := (FCount = 0);
end;

function TBLFontFeatureSettingsView.GetItem(
  const AIndex: NativeInt): TBLFontFeatureItem;
begin
  Assert(NativeUInt(AIndex) < NativeUInt(FCount));
  Result := FData[AIndex];
end;

{ TBLFontFeatureSettings }

class operator TBLFontFeatureSettings.Assign(var ADest: TBLFontFeatureSettings;
  const [ref] ASrc: TBLFontFeatureSettings);
begin
  _BLCheck(_blFontFeatureSettingsInitWeak(@ADest, @ASrc));
end;

class operator TBLFontFeatureSettings.Equal(const ALeft: TBLFontFeatureSettings;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsEmpty) then
    Result := (ARight = nil)
  else
    Result := (ARight <> nil);
end;

procedure TBLFontFeatureSettings.Clear;
begin
  _BLCheck(_blFontFeatureSettingsClear(@Self));
end;

class operator TBLFontFeatureSettings.Equal(const ALeft,
  ARight: TBLFontFeatureSettings): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLFontFeatureSettings.Equals(
  const AOther: TBLFontFeatureSettings): Boolean;
begin
  Result := _blFontFeatureSettingsEquals(@Self, @AOther);
end;

class operator TBLFontFeatureSettings.Finalize(
  var ADest: TBLFontFeatureSettings);
begin
  if (ADest.FBase.NeedsCleanup) then
    _BLCheck(_blFontFeatureSettingsDestroy(@ADest));
end;

function TBLFontFeatureSettings.GetCapacity: NativeInt;
begin
  Result := _blFontFeatureSettingsGetCapacity(@Self);
end;

function TBLFontFeatureSettings.GetCount: NativeInt;
begin
  Result := _blFontFeatureSettingsGetSize(@Self);
end;

function TBLFontFeatureSettings.GetIsEmpty: Boolean;
begin
  Result := (Count = 0);
end;

function TBLFontFeatureSettings.GetValue(const AFeatureTag: TBLTag): Integer;
begin
  Result := Integer(_blFontFeatureSettingsGetValue(@Self, AFeatureTag));
end;

function TBLFontFeatureSettings.HasValue(const AFeatureTag: TBLTag): Boolean;
begin
  Result := _blFontFeatureSettingsHasValue(@Self, AFeatureTag);
end;

class operator TBLFontFeatureSettings.Initialize(
  out ADest: TBLFontFeatureSettings);
begin
  _BLCheck(_blFontFeatureSettingsInit(@ADest));
end;

class operator TBLFontFeatureSettings.NotEqual(
  const ALeft: TBLFontFeatureSettings; const ARight: Pointer): Boolean;
begin
  if (ALeft.IsEmpty) then
    Result := (ARight <> nil)
  else
    Result := (ARight = nil);
end;

class operator TBLFontFeatureSettings.NotEqual(const ALeft,
  ARight: TBLFontFeatureSettings): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLFontFeatureSettings.RemoveValue(const AFeatureTag: TBLTag);
begin
  _BLCheck(_blFontFeatureSettingsRemoveValue(@Self, AFeatureTag));
end;

procedure TBLFontFeatureSettings.Reset;
begin
  _BLCheck(_blFontFeatureSettingsReset(@Self));
end;

procedure TBLFontFeatureSettings.SetValue(const ATag: TBLTag;
  const AValue: Integer);
begin
  _BLCheck(_blFontFeatureSettingsSetValue(@Self, ATag, UInt32(AValue)));
end;

procedure TBLFontFeatureSettings.Swap(var AOther: TBLFontFeatureSettings);
begin
  FBase.Swap(AOther.FBase);
end;

function TBLFontFeatureSettings.View: TBLFontFeatureSettingsView;
begin
  _BLCheck(_blFontFeatureSettingsGetView(@Self, @Result));
end;

{ TBLFontVariationItem }

procedure TBLFontVariationItem.Reset;
begin
  FTag := 0;
  FValue := 0;
end;

{ TBLFontVariationSettingsView }

function TBLFontVariationSettingsView.GetCount: NativeInt;
begin
  Result := FCount;
end;

function TBLFontVariationSettingsView.GetIsEmpty: Boolean;
begin
  Result := (FCount = 0);
end;

function TBLFontVariationSettingsView.GetItem(
  const AIndex: NativeInt): TBLFontVariationItem;
begin
  Assert(NativeUInt(AIndex) < NativeUInt(FCount));
  Result := FData[AIndex];
end;

{ TBLFontVariationSettings }

class operator TBLFontVariationSettings.Assign(
  var ADest: TBLFontVariationSettings;
  const [ref] ASrc: TBLFontVariationSettings);
begin
  _BLCheck(_blFontVariationSettingsInitWeak(@ADest, @ASrc));
end;

procedure TBLFontVariationSettings.Clear;
begin
  _BLCheck(_blFontVariationSettingsClear(@Self));
end;

class operator TBLFontVariationSettings.Equal(const ALeft,
  ARight: TBLFontVariationSettings): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLFontVariationSettings.Equal(
  const ALeft: TBLFontVariationSettings; const ARight: Pointer): Boolean;
begin
  if (ALeft.IsEmpty) then
    Result := (ARight = nil)
  else
    Result := (ARight <> nil);
end;

function TBLFontVariationSettings.Equals(
  const AOther: TBLFontVariationSettings): Boolean;
begin
  Result := _blFontVariationSettingsEquals(@Self, @AOther);
end;

class operator TBLFontVariationSettings.Finalize(
  var ADest: TBLFontVariationSettings);
begin
  if (ADest.FBase.NeedsCleanup) then
    _BLCheck(_blFontVariationSettingsDestroy(@ADest));
end;

function TBLFontVariationSettings.GetCapacity: NativeInt;
begin
  Result := _blFontVariationSettingsGetCapacity(@Self);
end;

function TBLFontVariationSettings.GetCount: NativeInt;
begin
  Result := _blFontVariationSettingsGetSize(@Self);
end;

function TBLFontVariationSettings.GetIsEmpty: Boolean;
begin
  Result := (Count = 0);
end;

function TBLFontVariationSettings.GetValue(const AVariationTag: TBLTag): Single;
begin
  Result := _blFontVariationSettingsGetValue(@Self, AVariationTag);
end;

function TBLFontVariationSettings.HasValue(
  const AVariationTag: TBLTag): Boolean;
begin
  Result := _blFontVariationSettingsHasValue(@Self, AVariationTag);
end;

class operator TBLFontVariationSettings.Initialize(
  out ADest: TBLFontVariationSettings);
begin
  _BLCheck(_blFontVariationSettingsInit(@ADest));
end;

class operator TBLFontVariationSettings.NotEqual(const ALeft,
  ARight: TBLFontVariationSettings): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLFontVariationSettings.NotEqual(
  const ALeft: TBLFontVariationSettings; const ARight: Pointer): Boolean;
begin
  if (ALeft.IsEmpty) then
    Result := (ARight <> nil)
  else
    Result := (ARight = nil);
end;

procedure TBLFontVariationSettings.RemoveValue(const AVariationTag: TBLTag);
begin
  _BLCheck(_blFontVariationSettingsRemoveValue(@Self, AVariationTag));
end;

procedure TBLFontVariationSettings.Reset;
begin
  _BLCheck(_blFontVariationSettingsReset(@Self));
end;

procedure TBLFontVariationSettings.SetValue(const ATag: TBLTag;
  const AValue: Single);
begin
  _BLCheck(_blFontVariationSettingsSetValue(@Self, ATag, AValue));
end;

procedure TBLFontVariationSettings.Swap(var AOther: TBLFontVariationSettings);
begin
  FBase.Swap(AOther.FBase);
end;

function TBLFontVariationSettings.View: TBLFontVariationSettingsView;
begin
  _BLCheck(_blFontVariationSettingsGetView(@Self, @Result));
end;

{ TBLFont }

procedure TBLFont.ApplyGPos(const AGB: TBLGlyphBuffer;
  const ALookups: TBLBitArray);
begin
  _BLCheck(_blFontApplyGPos(@Self, @AGB, @ALookups));
end;

procedure TBLFont.ApplyGSub(const AGB: TBLGlyphBuffer;
  const ALookups: TBLBitArray);
begin
  _BLCheck(_blFontApplyGSub(@Self, @AGB, @ALookups));
end;

procedure TBLFont.ApplyKerning(const AGB: TBLGlyphBuffer);
begin
  _BLCheck(_blFontApplyKerning(@Self, @AGB));
end;

class operator TBLFont.Assign(var ADest: TBLFont; const [ref] ASrc: TBLFont);
begin
  _BLCheck(_blFontInitWeak(@ADest, @ASrc));
end;

class operator TBLFont.Equal(const ALeft: TBLFont;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsEmpty) then
    Result := (ARight = nil)
  else
    Result := (ARight <> nil);
end;

class operator TBLFont.Equal(const ALeft, ARight: TBLFont): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLFont.Equals(const AOther: TBLFont): Boolean;
begin
  Result := _blFontEquals(@Self, @AOther);
end;

class operator TBLFont.Finalize(var ADest: TBLFont);
begin
  if (ADest.FBase.NeedsCleanup) then
    _BLCheck(_blFontDestroy(@ADest));
end;

function TBLFont.GetDesignMetrics: PBLFontDesignMetrics;
begin
  Result := GetFace.DesignMetrics;
end;

function TBLFont.GetFace: TBLFontFace;
begin
  _blFontFaceAssignWeak(@Result, @PImpl(FBase.FImpl).Face);
end;

function TBLFont.GetFaceFlags: TBLFontFaceFlags;
begin
  Result := GetFace.FaceFlags;
end;

function TBLFont.GetFaceType: TBLFontFaceType;
begin
  Result := GetFace.FaceType;
end;

function TBLFont.GetFeatureSettings: TBLFontFeatureSettings;
begin
  _blFontFeatureSettingsAssignWeak(@Result, @PImpl(FBase.FImpl).FeatureSettings);
end;

function TBLFont.GetGlyphAdvances(const AGlyphData: PUInt32;
  const AGlyphAdvance, ACount: NativeInt): TArray<TBLGlyphPlacement>;
begin
  SetLength(Result, ACount);
  _BLCheck(_blFontGetGlyphAdvances(@Self, AGlyphData, AGlyphAdvance, Result, ACount));
end;

procedure TBLFont.GetGlyphAdvances(const AGlyphData: PUInt32;
  const AGlyphAdvance, ACount: NativeInt; out APlacements: PBLGlyphPlacement);
begin
  _BLCheck(_blFontGetGlyphAdvances(@Self, AGlyphData, AGlyphAdvance, APlacements, ACount));
end;

function TBLFont.GetGlyphBounds(const AGlyphData: PUInt32;
  const AGlyphAdvance, ACount: NativeInt): TArray<TBLBoxI>;
begin
  SetLength(Result, ACount);
  _BLCheck(_blFontGetGlyphBounds(@Self, AGlyphData, AGlyphAdvance, Result, ACount));
end;

procedure TBLFont.GetGlyphOutlines(const AGlyphId: TBLGlyphId;
  const AUserTransform: TBLMatrix2D; const AOut: TBLPath;
  const ASink: TBLPathSinkFunc; const AUserData: Pointer);
begin
  _BLCheck(_blFontGetGlyphOutlines(@Self, AGlyphId, @AUserTransform, @AOut, ASink, AUserData));
end;

procedure TBLFont.GetGlyphRunOutlines(const AGlyphRun: TBLGlyphRun;
  const AUserTransform: TBLMatrix2D; const AOut: TBLPath;
  const ASink: TBLPathSinkFunc; const AUserData: Pointer);
begin
  _BLCheck(_blFontGetGlyphRunOutlines(@Self, @AGlyphRun, @AUserTransform, @AOut, ASink, AUserData));
end;

procedure TBLFont.GetGlyphRunOutlines(const AGlyphRun: TBLGlyphRun;
  const AOut: TBLPath; const ASink: TBLPathSinkFunc; const AUserData: Pointer);
begin
  _BLCheck(_blFontGetGlyphRunOutlines(@Self, @AGlyphRun, nil, @AOut, ASink, AUserData));
end;

procedure TBLFont.GetGlyphOutlines(const AGlyphId: TBLGlyphId;
  const AOut: TBLPath; const ASink: TBLPathSinkFunc; const AUserData: Pointer);
begin
  _BLCheck(_blFontGetGlyphOutlines(@Self, AGlyphId, nil, @AOut, ASink, AUserData));
end;

procedure TBLFont.GetGlyphBounds(const AGlyphData: PUInt32;
  const AGlyphAdvance, ACount: NativeInt; out ABounds: PBLBoxI);
begin
  _BLCheck(_blFontGetGlyphBounds(@Self, AGlyphData, AGlyphAdvance, ABounds, ACount));
end;

function TBLFont.GetIsEmpty: Boolean;
begin
  Result := not IsValid;
end;

function TBLFont.GetIsValid: Boolean;
begin
  Result := GetFace.IsValid;
end;

function TBLFont.GetMatrix: TBLFontMatrix;
begin
  Result := PImpl(FBase.FImpl).Matrix;
end;

function TBLFont.GetMetrics: PBLFontMetrics;
begin
  Result := @PImpl(FBase.FImpl).Metrics;
end;

function TBLFont.GetSize: Single;
begin
  Result := PImpl(FBase.FImpl).Metrics.Size;
end;

function TBLFont.GetStretch: TBLFontStretch;
begin
  Result := TBLFontStretch(PImpl(FBase.FImpl).Stretch);
end;

function TBLFont.GetStyle: TBLFontStyle;
begin
  Result := TBLFontStyle(PImpl(FBase.FImpl).Style);
end;

procedure TBLFont.GetTextMetrics(const AGB: TBLGlyphBuffer;
  out AMetrics: TBLTextMetrics);
begin
  _BLCheck(_blFontGetTextMetrics(@Self, @AGB, @AMetrics));
end;

function TBLFont.GetUnitsPerEm: Integer;
begin
  Result := GetFace.UnitsPerEm;
end;

function TBLFont.GetVariationSettings: TBLFontVariationSettings;
begin
  _blFontFeatureSettingsAssignWeak(@Result, @PImpl(FBase.FImpl).VariationSettings);
end;

function TBLFont.GetWeight: TBLFontWeight;
begin
  Result := TBLFontWeight(PImpl(FBase.FImpl).Weight);
end;

class operator TBLFont.Initialize(out ADest: TBLFont);
begin
  _BLCheck(_blFontInit(@ADest));
end;

procedure TBLFont.MakeFromFace(const AFace: TBLFontFace; const ASize: Single;
  const AFeatureSettings: TBLFontFeatureSettings;
  const AVariationSettings: TBLFontVariationSettings);
begin
  _BLCheck(_blFontCreateFromFaceWithSettings(@Self, @AFace, ASize,
    @AFeatureSettings, @AVariationSettings));
end;

procedure TBLFont.MapTextToGlyphs(const AGB: TBLGlyphBuffer;
  out AStateOut: TBLGlyphMappingState);
begin
  _BLCheck(_blFontMapTextToGlyphs(@Self, @AGB, @AStateOut));
end;

procedure TBLFont.MapTextToGlyphs(const AGB: TBLGlyphBuffer);
begin
  _BLCheck(_blFontMapTextToGlyphs(@Self, @AGB, nil));
end;

procedure TBLFont.MakeFromFace(const AFace: TBLFontFace; const ASize: Single;
  const AFeatureSettings: TBLFontFeatureSettings);
begin
  _BLCheck(_blFontCreateFromFaceWithSettings(@Self, @AFace, ASize, @AFeatureSettings, nil));
end;

procedure TBLFont.MakeFromFace(const AFace: TBLFontFace; const ASize: Single);
begin
  _BLCheck(_blFontCreateFromFace(@Self, @AFace, ASize));
end;

class operator TBLFont.NotEqual(const ALeft: TBLFont;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsEmpty) then
    Result := (ARight <> nil)
  else
    Result := (ARight = nil);
end;

class operator TBLFont.NotEqual(const ALeft, ARight: TBLFont): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLFont.PositionGlyphs(const AGB: TBLGlyphBuffer);
begin
  _BLCheck(_blFontPositionGlyphs(@Self, @AGB));
end;

procedure TBLFont.Reset;
begin
  _blFontReset(@Self);
end;

procedure TBLFont.ResetFeatureSettings;
begin
  _BLCheck(_blFontResetFeatureSettings(@Self));
end;

procedure TBLFont.ResetVariationSettings;
begin
  _BLCheck(_blFontResetVariationSettings(@Self));
end;

procedure TBLFont.SetFeatureSettings(const AValue: TBLFontFeatureSettings);
begin
  _BLCheck(_blFontSetFeatureSettings(@Self, @AValue));
end;

procedure TBLFont.SetSize(const AValue: Single);
begin
  _BLCheck(_blFontSetSize(@Self, AValue));
end;

procedure TBLFont.SetVariationSettings(const AValue: TBLFontVariationSettings);
begin
  _BLCheck(_blFontSetVariationSettings(@Self, @AValue));
end;

procedure TBLFont.Shape(const AGB: TBLGlyphBuffer);
begin
  _BLCheck(_blFontShape(@Self, @AGB));
end;

procedure TBLFont.Swap(var AOther: TBLFont);
begin
  FBase.Swap(AOther.FBase);
end;

{ TBLFontQueryProperties }

procedure TBLFontQueryProperties.Reset;
begin
  Style := TBLFontStyle.Normal;
  Weight := TBLFontWeight.Normal;
  Stretch := TBLFontStretch.Normal;
end;

{ TBLFontManager }

procedure TBLFontManager.AddFace(const AFace: TBLFontFace);
begin
  _BLCheck(_blFontManagerAddFace(@Self, @AFace));
end;

class operator TBLFontManager.Assign(var ADest: TBLFontManager;
  const [ref] ASrc: TBLFontManager);
begin
  _BLCheck(_blFontManagerInitWeak(@ADest, @ASrc));
end;

class operator TBLFontManager.Equal(const ALeft,
  ARight: TBLFontManager): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLFontManager.Equal(const ALeft: TBLFontManager;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsValid) then
    Result := (ARight <> nil)
  else
    Result := (ARight = nil);
end;

function TBLFontManager.Equals(const AOther: TBLFontManager): Boolean;
begin
  Result := _blFontManagerEquals(@Self, @AOther);
end;

class operator TBLFontManager.Finalize(var ADest: TBLFontManager);
begin
  _BLCheck(_blFontManagerDestroy(@ADest));
end;

function TBLFontManager.GetFaceCount: NativeInt;
begin
  Result := _blFontManagerGetFaceCount(@Self);
end;

function TBLFontManager.GetFamilyCount: NativeInt;
begin
  Result := _blFontManagerGetFamilyCount(@Self);
end;

function TBLFontManager.GetIsValid: Boolean;
begin
  Result := (FBase.AField = 0);
end;

function TBLFontManager.HasFace(const AFace: TBLFontFace): Boolean;
begin
  Result := _blFontManagerHasFace(@Self, @AFace);
end;

class operator TBLFontManager.Initialize(out ADest: TBLFontManager);
begin
  _BLCheck(_blFontManagerInit(@ADest));
end;

procedure TBLFontManager.Make;
begin
  _BLCheck(_blFontManagerCreate(@Self));
end;

class operator TBLFontManager.NotEqual(const ALeft,
  ARight: TBLFontManager): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

function TBLFontManager.QueryFace(const AName: String): TBLFontFace;
begin
  var Name := UTF8String(AName);
  _BLCheck(_blFontManagerQueryFace(@Self, PUTF8Char(Name), Length(Name),
    nil, @Result));
end;

function TBLFontManager.QueryFace(const AName: TBLStringView): TBLFontFace;
begin
  _BLCheck(_blFontManagerQueryFace(@Self, Pointer(AName.FData), AName.FCount,
    nil, @Result));
end;

function TBLFontManager.QueryFace(const AName: String;
  const AProperties: TBLFontQueryProperties): TBLFontFace;
begin
  var Name := UTF8String(AName);
  _BLCheck(_blFontManagerQueryFace(@Self, PUTF8Char(Name), Length(Name),
    @AProperties, @Result));
end;

function TBLFontManager.QueryFace(const AName: TBLStringView;
  const AProperties: TBLFontQueryProperties): TBLFontFace;
begin
  _BLCheck(_blFontManagerQueryFace(@Self, Pointer(AName.FData), AName.FCount,
    @AProperties, @Result));
end;

function TBLFontManager.QueryFacesByFamilyName(
  const AName: String): TArray<TBLFontFace>;
begin
  var Faces: TBLArray<TBLFontFace>;
  var Name := UTF8String(AName);
  _BLCheck(_blFontManagerQueryFacesByFamilyName(@Self, PUTF8Char(Name),
    Length(AName), @Faces));
  Result := Faces.ToArray;
end;

procedure TBLFontManager.QueryFacesByFamilyName(const AName: String;
  const AOut: TBLArray<TBLFontFace>);
begin
  var Name := UTF8String(AName);
  _BLCheck(_blFontManagerQueryFacesByFamilyName(@Self, PUTF8Char(Name),
    Length(AName), @AOut));
end;

function TBLFontManager.QueryFacesByFamilyName(
  const AName: TBLStringView): TArray<TBLFontFace>;
begin
  var Faces: TBLArray<TBLFontFace>;
  _BLCheck(_blFontManagerQueryFacesByFamilyName(@Self, Pointer(AName.FData),
    AName.FCount, @Faces));
  Result := Faces.ToArray;
end;

procedure TBLFontManager.QueryFacesByFamilyName(const AName: TBLStringView;
  const AOut: TBLArray<TBLFontFace>);
begin
  _BLCheck(_blFontManagerQueryFacesByFamilyName(@Self, Pointer(AName.FData),
    AName.FCount, @AOut));
end;

class operator TBLFontManager.NotEqual(const ALeft: TBLFontManager;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsValid) then
    Result := (ARight = nil)
  else
    Result := (ARight <> nil);
end;

procedure TBLFontManager.Reset;
begin
  _BLCheck(_blFontManagerReset(@Self));
end;

procedure TBLFontManager.Swap(var AOther: TBLFontManager);
begin
  FBase.Swap(AOther.FBase);
end;

{$ENDREGION 'Text'}

{$REGION 'Imaging'}

{ TBLFormatInfo }

procedure TBLFormatInfo.AddFlags(const AFlags: TBLFormatFlags);
begin
  FFlags := FFlags + AFlags;
end;

procedure TBLFormatInfo.ClearFlags(const AFlags: TBLFormatFlags);
begin
  FFlags := FFlags - AFlags;
end;

class operator TBLFormatInfo.Equal(const ALeft, ARight: TBLFormatInfo): Boolean;
begin
  Result := CompareMem(@ALeft, @ARight, SizeOf(TBLFormatInfo));
end;

function TBLFormatInfo.GetPalette: PBLRgba32;
type
  PPBLRgba32 = ^PBLRgba32;
begin
  var P := PPBLRgba32(@FSizes);
  Result := P^;
end;

function TBLFormatInfo.GetShift(const AIndex: Integer): Byte;
begin
  Assert(Cardinal(AIndex) < 4);
  Result := FSizes[AIndex];
end;

function TBLFormatInfo.GetSize(const AIndex: Integer): Byte;
begin
  Assert(Cardinal(AIndex) < 4);
  Result := FSizes[AIndex];
end;

function TBLFormatInfo.HasFlag(const AFlag: TBLFormatFlag): Boolean;
begin
  Result := (AFlag in FFlags);
end;

procedure TBLFormatInfo.Init(const ADepth: Integer;
  const AFlags: TBLFormatFlags; const ASizes, AShifts: TBLFourBytes);
begin
  FDepth := ADepth;
  FFlags := AFlags;
  FSizes := ASizes;
  FShifts := AShifts;
end;

class operator TBLFormatInfo.NotEqual(const ALeft,
  ARight: TBLFormatInfo): Boolean;
begin
  Result := not CompareMem(@ALeft, @ARight, SizeOf(TBLFormatInfo));
end;

procedure TBLFormatInfo.Query(const AFormat: TBLFormat);
begin
  _BLCheck(_blFormatInfoQuery(@Self, Ord(AFormat)));
end;

procedure TBLFormatInfo.Reset;
begin
  FillChar(Self, SizeOf(Self), 0);
end;

procedure TBLFormatInfo.Sanitize;
begin
  _BLCheck(_blFormatInfoSanitize(@Self));
end;

procedure TBLFormatInfo.SetShift(const AIndex: Integer; const AValue: Byte);
begin
  Assert(Cardinal(AIndex) < 4);
  FShifts[AIndex] := AValue;
end;

procedure TBLFormatInfo.SetShifts(const AR, AG, AB, AA: Byte);
begin
  FShifts[0] := AR;
  FShifts[1] := AG;
  FShifts[2] := AB;
  FShifts[3] := AA;
end;

procedure TBLFormatInfo.SetSize(const AIndex: Integer; const AValue: Byte);
begin
  Assert(Cardinal(AIndex) < 4);
  FSizes[AIndex] := AValue;
end;

procedure TBLFormatInfo.SetSizes(const AR, AG, AB, AA: Byte);
begin
  FSizes[0] := AR;
  FSizes[1] := AG;
  FSizes[2] := AB;
  FSizes[3] := AA;
end;

{ _TBLFormatHelper }

function _TBLFormatHelper.Info: TBLFormatInfo;
begin
  _BLCheck(_blFormatInfoQuery(@Result, Ord(Self)));
end;

{ TBLPixelConverter }

class operator TBLPixelConverter.Assign(var ADest: TBLPixelConverter;
  const [ref] ASrc: TBLPixelConverter);
begin
  _BLCheck(_blPixelConverterInitWeak(@ADest, @ASrc));
end;

procedure TBLPixelConverter.ConvertRect(const ADstData: Pointer;
  const ADstStride: NativeInt; const ASrcData: Pointer;
  const ASrcStride: NativeInt; const AWidth, AHeight: Integer;
  const AOptions: TBLPixelConverterOptions);
begin
  _BLCheck(_blPixelConverterConvert(@Self, ADstData, ADstStride, ASrcData,
    ASrcStride, AWidth, AHeight, @AOptions));
end;

procedure TBLPixelConverter.ConvertRect(const ADstData: Pointer;
  const ADstStride: NativeInt; const ASrcData: Pointer;
  const ASrcStride: NativeInt; const AWidth, AHeight: Integer);
begin
  _BLCheck(_blPixelConverterConvert(@Self, ADstData, ADstStride, ASrcData,
    ASrcStride, AWidth, AHeight, nil));
end;

procedure TBLPixelConverter.ConvertSpan(const ADstData, ASrcData: Pointer;
  const AWidth: Integer; const AOptions: TBLPixelConverterOptions);
begin
  _BLCheck(_blPixelConverterConvert(@Self, ADstData, 0, ASrcData, 0, AWidth, 1, @AOptions));
end;

procedure TBLPixelConverter.ConvertSpan(const ADstData, ASrcData: Pointer;
  const AWidth: Integer);
begin
  _BLCheck(_blPixelConverterConvert(@Self, ADstData, 0, ASrcData, 0, AWidth, 1, nil));
end;

class operator TBLPixelConverter.Finalize(var ADest: TBLPixelConverter);
begin
  _BLCheck(_blPixelConverterDestroy(@ADest));
end;

function TBLPixelConverter.GetIsInitialized: Boolean;
begin
  Result := (FCore.InternalFlags <> 0);
end;

class operator TBLPixelConverter.Initialize(out ADest: TBLPixelConverter);
begin
  _BLCheck(_blPixelConverterInit(@ADest));
end;

procedure TBLPixelConverter.Make(const ADstInfo, ASrcInfo: TBLFormatInfo;
  const ACreateFlags: TBLPixelConverterCreateFlags);
begin
  _BLCheck(_blPixelConverterCreate(@Self, @ADstInfo, @ASrcInfo, Byte(ACreateFlags)));
end;

procedure TBLPixelConverter.MakePlatformConverter(const AFormat: TBLFormat);
begin
  var SrcInfo, DstInfo: TBLFormatInfo;

  SrcInfo.Reset;
  SrcInfo.Query(AFormat);
  DstInfo := SrcInfo;

  {$IFNDEF MSWINDOWS}
  DstInfo.RShift := SrcInfo.BShift;
  DstInfo.BShift := SrcInfo.RShift;
  {$ENDIF}

  var Flags: TBLPixelConverterCreateFlags := [TBLPixelConverterCreateFlag.NoMultiStep];
  _BLCheck(_blPixelConverterCreate(@Self, @DstInfo, @SrcInfo, Byte(Flags)));
end;

procedure TBLPixelConverter.Reset;
begin
  _BLCheck(_blPixelConverterReset(@Self));
end;

{ TBLImageInfo }

function TBLImageInfo.GetCompression: String;
begin
  Result := String(UTF8String(PUTF8Char(@FCompression)));
end;

function TBLImageInfo.GetFlags: TBLImageInfoFlags;
begin
  Byte(Result) := FFlags;
end;

function TBLImageInfo.GetFormat: String;
begin
  Result := String(UTF8String(PUTF8Char(@FFormat)));
end;

procedure TBLImageInfo.Reset;
begin
  FillChar(Self, SizeOf(Self), 0);
end;

{ TBLImageDecoder }

class operator TBLImageDecoder.Assign(var ADest: TBLImageDecoder;
  const [ref] ASrc: TBLImageDecoder);
begin
  _BLCheck(_blImageDecoderInitWeak(@ADest, @ASrc));
end;

class operator TBLImageDecoder.Equal(const ALeft: TBLImageDecoder;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsValid) then
    Result := (ARight <> nil)
  else
    Result := (ARight = nil);
end;

class operator TBLImageDecoder.Equal(const ALeft,
  ARight: TBLImageDecoder): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLImageDecoder.Equals(const AOther: TBLImageDecoder): Boolean;
begin
  Result := (FBase.FImpl = AOther.FBase.FImpl);
end;

class operator TBLImageDecoder.Finalize(var ADest: TBLImageDecoder);
begin
  if (ADest.FBase.NeedsCleanup) then
    _BLCheck(_blImageDecoderDestroy(@ADest));
end;

function TBLImageDecoder.GetBufferIndex: NativeInt;
begin
  Result := PImpl(FBase.FImpl).BufferIndex;
end;

function TBLImageDecoder.GetFrameIndex: Int64;
begin
  Result := PImpl(FBase.FImpl).FrameIndex;
end;

function TBLImageDecoder.GetIsValid: Boolean;
begin
  Result := (LastResult <> TBLResult.NotInitialized);
end;

function TBLImageDecoder.GetLastResult: TBLResult;
begin
  Result := TBLResult(PImpl(FBase.FImpl).LastResult);
end;

class operator TBLImageDecoder.Initialize(out ADest: TBLImageDecoder);
begin
  _BLCheck(_blImageDecoderInit(@ADest));
end;

class operator TBLImageDecoder.NotEqual(const ALeft: TBLImageDecoder;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsValid) then
    Result := (ARight = nil)
  else
    Result := (ARight <> nil);
end;

class operator TBLImageDecoder.NotEqual(const ALeft,
  ARight: TBLImageDecoder): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLImageDecoder.ReadInfo(out ADst: TBLImageInfo;
  const ABuffer: TBLArray<Byte>);
begin
  _BLCheck(_blImageDecoderReadInfo(@Self, @ADst, ABuffer.Data, ABuffer.Count));
end;

procedure TBLImageDecoder.ReadInfo(out ADst: TBLImageInfo;
  const ABuffer: TBytes);
begin
  _BLCheck(_blImageDecoderReadInfo(@Self, @ADst, ABuffer, Length(ABuffer)));
end;

procedure TBLImageDecoder.ReadInfo(out ADst: TBLImageInfo;
  const AView: TBLArrayView<Byte>);
begin
  _BLCheck(_blImageDecoderReadInfo(@Self, @ADst, AView.FData, AView.FCount));
end;

procedure TBLImageDecoder.ReadInfo(out ADst: TBLImageInfo; const AData: Pointer;
  const ASize: NativeInt);
begin
  _BLCheck(_blImageDecoderReadInfo(@Self, @ADst, AData, ASize));
end;

procedure TBLImageDecoder.Reset;
begin
  _BLCheck(_blImageDecoderReset(@Self));
end;

procedure TBLImageDecoder.Restart;
begin
  _BLCheck(_blImageDecoderRestart(@Self));
end;

procedure TBLImageDecoder.Swap(var AOther: TBLImageDecoder);
begin
  FBase.Swap(AOther.FBase);
end;

{ _TBLImageDecoderHelper }

function _TBLImageDecoderHelper.GetCodec: TBLImageCodec;
begin
  _blImageCodecAssignWeak(@Result, @PImpl(FBase.FImpl).Codec);
end;

procedure _TBLImageDecoderHelper.ReadFrame(out ADst: TBLImage;
  const ABuffer: TBLArray<Byte>);
begin
  _BLCheck(_blImageDecoderReadFrame(@Self, @ADst, ABuffer.Data, ABuffer.Count));
end;

procedure _TBLImageDecoderHelper.ReadFrame(out ADst: TBLImage;
  const ABuffer: TBytes);
begin
  _BLCheck(_blImageDecoderReadFrame(@Self, @ADst, ABuffer, Length(ABuffer)));
end;

procedure _TBLImageDecoderHelper.ReadFrame(out ADst: TBLImage;
  const AView: TBLArrayView<Byte>);
begin
  _BLCheck(_blImageDecoderReadFrame(@Self, @ADst, AView.FData, AView.FCount));
end;

procedure _TBLImageDecoderHelper.ReadFrame(out ADst: TBLImage;
  const AData: Pointer; const ASize: NativeInt);
begin
  _BLCheck(_blImageDecoderReadFrame(@Self, @ADst, AData, ASize));
end;

{ TBLImageEncoder }

class operator TBLImageEncoder.Assign(var ADest: TBLImageEncoder;
  const [ref] ASrc: TBLImageEncoder);
begin
  _BLCheck(_blImageEncoderInitWeak(@ADest, @ASrc));
end;

class operator TBLImageEncoder.Equal(const ALeft: TBLImageEncoder;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsValid) then
    Result := (ARight <> nil)
  else
    Result := (ARight = nil);
end;

class operator TBLImageEncoder.Equal(const ALeft,
  ARight: TBLImageEncoder): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLImageEncoder.Equals(const AOther: TBLImageEncoder): Boolean;
begin
  Result := (FBase.FImpl = AOther.FBase.FImpl);
end;

class operator TBLImageEncoder.Finalize(var ADest: TBLImageEncoder);
begin
  if (ADest.FBase.NeedsCleanup) then
    _BLCheck(_blImageEncoderDestroy(@ADest));
end;

function TBLImageEncoder.GetBufferIndex: NativeInt;
begin
  Result := PImpl(FBase.FImpl).BufferIndex;
end;

function TBLImageEncoder.GetFrameIndex: Int64;
begin
  Result := PImpl(FBase.FImpl).FrameIndex;
end;

function TBLImageEncoder.GetIsValid: Boolean;
begin
  Result := (LastResult <> TBLResult.NotInitialized);
end;

function TBLImageEncoder.GetLastResult: TBLResult;
begin
  Result := TBLResult(PImpl(FBase.FImpl).LastResult);
end;

class operator TBLImageEncoder.Initialize(out ADest: TBLImageEncoder);
begin
  _BLCheck(_blImageEncoderInit(@ADest));
end;

class operator TBLImageEncoder.NotEqual(const ALeft: TBLImageEncoder;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsValid) then
    Result := (ARight = nil)
  else
    Result := (ARight <> nil);
end;

class operator TBLImageEncoder.NotEqual(const ALeft,
  ARight: TBLImageEncoder): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLImageEncoder.Reset;
begin
  _BLCheck(_blImageEncoderReset(@Self));
end;

procedure TBLImageEncoder.Restart;
begin
  _BLCheck(_blImageEncoderRestart(@Self));
end;

procedure TBLImageEncoder.Swap(var AOther: TBLImageEncoder);
begin
  FBase.Swap(AOther.FBase);
end;

{ _TBLImageEncoderHelper }

function _TBLImageEncoderHelper.GetCodec: TBLImageCodec;
begin
  _blImageCodecAssignWeak(@Result, @PImpl(FBase.FImpl).Codec);
end;

procedure _TBLImageEncoderHelper.WriteFrame(const ADst: TBLArray<Byte>;
  const AImage: TBLImage);
begin
  _BLCheck(_blImageEncoderWriteFrame(@Self, @ADst, @AImage));
end;

function _TBLImageEncoderHelper.WriteFrame(const AImage: TBLImage): TBytes;
begin
  var Dst: TBLArray<Byte>;
  _BLCheck(_blImageEncoderWriteFrame(@Self, @Dst, @AImage));
  SetLength(Result, Dst.Count);
  Move(Dst.Data^, Result[0], Dst.Count);
end;

{ TBLImageCodec }

class procedure TBLImageCodec.AddToBuiltIn(const ACodec: TBLImageCodec);
begin
  _BLCheck(_blImageCodecAddToBuiltIn(@ACodec));
end;

class operator TBLImageCodec.Assign(var ADest: TBLImageCodec;
  const [ref] ASrc: TBLImageCodec);
begin
  _BLCheck(_blImageCodecInitWeak(@ADest, @ASrc));
end;

class operator TBLImageCodec.Equal(const ALeft: TBLImageCodec;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsValid) then
    Result := (ARight <> nil)
  else
    Result := (ARight = nil);
end;

function TBLImageCodec.CreateDecoder: TBLImageDecoder;
begin
  _BLCheck(_blImageCodecCreateDecoder(@Self, @Result));
end;

function TBLImageCodec.CreateEncoder: TBLImageEncoder;
begin
  _BLCheck(_blImageCodecCreateEncoder(@Self, @Result));
end;

class operator TBLImageCodec.Equal(const ALeft, ARight: TBLImageCodec): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLImageCodec.Equals(const AOther: TBLImageCodec): Boolean;
begin
  Result := (FBase.FImpl = AOther.FBase.FImpl);
end;

class operator TBLImageCodec.Finalize(var ADest: TBLImageCodec);
begin
  if (ADest.FBase.NeedsCleanup) then
    _BLCheck(_blImageCodecDestroy(@ADest));
end;

procedure TBLImageCodec.FindByData(const AView: TBLArrayView<Byte>;
  const ACodecs: TBLArray<TBLImageCodec>);
begin
  _BLCheck(_blImageCodecFindByData(@Self, AView.FData, AView.FCount, @ACodecs));
end;

procedure TBLImageCodec.FindByData(const AView: TBLArrayView<Byte>);
begin
  _BLCheck(_blImageCodecFindByData(@Self, AView.FData, AView.FCount, nil));
end;

procedure TBLImageCodec.FindByData(const AData: Pointer; const ASize: NativeInt;
  const ACodecs: TBLArray<TBLImageCodec>);
begin
  _BLCheck(_blImageCodecFindByData(@Self, AData, ASize, @ACodecs));
end;

procedure TBLImageCodec.FindByData(const AData: Pointer;
  const ASize: NativeInt);
begin
  _BLCheck(_blImageCodecFindByData(@Self, AData, ASize, nil));
end;

procedure TBLImageCodec.FindByData(const ABuffer: TBytes;
  const ACodecs: TBLArray<TBLImageCodec>);
begin
  _BLCheck(_blImageCodecFindByData(@Self, Pointer(ABuffer), Length(ABuffer), @ACodecs));
end;

procedure TBLImageCodec.FindByData(const ABuffer: TBytes);
begin
  _BLCheck(_blImageCodecFindByData(@Self, Pointer(ABuffer), Length(ABuffer), nil));
end;

procedure TBLImageCodec.FindByData(const ABuffer: TBLArray<Byte>;
  const ACodecs: TBLArray<TBLImageCodec>);
begin
  _BLCheck(_blImageCodecFindByData(@Self, ABuffer.Data, ABuffer.Count, @ACodecs));
end;

procedure TBLImageCodec.FindByData(const ABuffer: TBLArray<Byte>);
begin
  _BLCheck(_blImageCodecFindByData(@Self, ABuffer.Data, ABuffer.Count, nil));
end;

procedure TBLImageCodec.FindByExtension(const AExt: String;
  const ACodecs: TBLArray<TBLImageCodec>);
begin
  var Name := UTF8String(AExt);
  _BLCheck(_blImageCodecFindByExtension(@Self, PUTF8Char(Name), Length(Name), @ACodecs));
end;

procedure TBLImageCodec.FindByExtension(const AExt: String);
begin
  var Name := UTF8String(AExt);
  _BLCheck(_blImageCodecFindByExtension(@Self, PUTF8Char(Name), Length(Name), nil));
end;

procedure TBLImageCodec.FindByExtension(const AExt: TBLStringView;
  const ACodecs: TBLArray<TBLImageCodec>);
begin
  _BLCheck(_blImageCodecFindByExtension(@Self, Pointer(AExt.FData), AExt.FCount, @ACodecs));
end;

procedure TBLImageCodec.FindByExtension(const AExt: TBLStringView);
begin
  _BLCheck(_blImageCodecFindByExtension(@Self, Pointer(AExt.FData), AExt.FCount, nil));
end;

procedure TBLImageCodec.FindByName(const AName: String;
  const ACodecs: TBLArray<TBLImageCodec>);
begin
  var Name := UTF8String(AName);
  _BLCheck(_blImageCodecFindByName(@Self, PUTF8Char(Name), Length(Name), @ACodecs));
end;

procedure TBLImageCodec.FindByName(const AName: String);
begin
  var Name := UTF8String(AName);
  _BLCheck(_blImageCodecFindByName(@Self, PUTF8Char(Name), Length(Name), nil));
end;

procedure TBLImageCodec.FindByName(const AName: TBLStringView;
  const ACodecs: TBLArray<TBLImageCodec>);
begin
  _BLCheck(_blImageCodecFindByName(@Self, Pointer(AName.FData), AName.FCount, @ACodecs));
end;

procedure TBLImageCodec.FindByName(const AName: TBLStringView);
begin
  _BLCheck(_blImageCodecFindByName(@Self, Pointer(AName.FData), AName.FCount, nil));
end;

class function TBLImageCodec.GetBuiltInCodecs: TBLArray<TBLImageCodec>;
begin
  _BLCheck(_blImageCodecArrayInitBuiltInCodecs(@Result));
end;

function TBLImageCodec.GetExtensions: TBLString;
begin
  _blStringAssignWeak(@Result, @PImpl(FBase.FImpl).Extensions);
end;

function TBLImageCodec.GetFeatures: TBLImageCodecFeatures;
begin
  Cardinal(Result) := PImpl(FBase.FImpl).Features;
end;

function TBLImageCodec.GetIsValid: Boolean;
begin
  var Features := TBLImageCodecFeatures(PImpl(FBase.FImpl).Features);
  Result := ((Features * [TBLImageCodecFeature.Read, TBLImageCodecFeature.Write]) <> []);
end;

function TBLImageCodec.GetMimeType: TBLString;
begin
  _blStringAssignWeak(@Result, @PImpl(FBase.FImpl).MimeType);
end;

function TBLImageCodec.GetName: TBLString;
begin
  _blStringAssignWeak(@Result, @PImpl(FBase.FImpl).Name);
end;

function TBLImageCodec.GetVendor: TBLString;
begin
  _blStringAssignWeak(@Result, @PImpl(FBase.FImpl).Vendor);
end;

function TBLImageCodec.HasFeature(
  const AFeature: TBLImageCodecFeature): Boolean;
begin
  var Features := TBLImageCodecFeatures(PImpl(FBase.FImpl).Features);
  Result := (AFeature in Features);
end;

class operator TBLImageCodec.Initialize(out ADest: TBLImageCodec);
begin
  _BLCheck(_blImageCodecInit(@ADest));
end;

function TBLImageCodec.InspectData(const ABuffer: TBLArray<Byte>): Cardinal;
begin
  Result := _blImageCodecInspectData(@Self, ABuffer.Data, ABuffer.Count);
end;

function TBLImageCodec.InspectData(const ABuffer: TBytes): Cardinal;
begin
  Result := _blImageCodecInspectData(@Self, ABuffer, Length(ABuffer));
end;

function TBLImageCodec.InspectData(const AView: TBLArrayView<Byte>): Cardinal;
begin
  Result := _blImageCodecInspectData(@Self, AView.FData, AView.FCount);
end;

function TBLImageCodec.InspectData(const AData: Pointer;
  const ASize: NativeInt): Cardinal;
begin
  Result := _blImageCodecInspectData(@Self, AData, ASize);
end;

class operator TBLImageCodec.NotEqual(const ALeft,
  ARight: TBLImageCodec): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class procedure TBLImageCodec.RemoveFromBuiltIn(const ACodec: TBLImageCodec);
begin
  _BLCheck(_blImageCodecRemoveFromBuiltIn(@ACodec));
end;

procedure TBLImageCodec.Reset;
begin
  _BLCheck(_blImageCodecReset(@Self));
end;

procedure TBLImageCodec.Swap(var AOther: TBLImageCodec);
begin
  FBase.Swap(AOther.FBase);
end;

class operator TBLImageCodec.NotEqual(const ALeft: TBLImageCodec;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsValid) then
    Result := (ARight = nil)
  else
    Result := (ARight <> nil);
end;

{ TBLImageData }

procedure TBLImageData.Reset;
begin
  FillChar(Self, SizeOf(Self), 0);
end;

{ TBLImage }

class operator TBLImage.Assign(var ADest: TBLImage; const [ref] ASrc: TBLImage);
begin
  _BLCheck(_blImageInitWeak(@ADest, @ASrc));
end;

procedure TBLImage.AssignDeep(const AOther: TBLImage);
begin
  _BLCheck(_blImageAssignDeep(@Self, @AOther));
end;

procedure TBLImage.AssignShallow(const AOther: TBLImage);
begin
  _BLCheck(_blImageAssignWeak(@Self, @AOther));
end;

procedure TBLImage.Convert(const AFormat: TBLFormat);
begin
  _BLCheck(_blImageConvert(@Self, Ord(AFormat)));
end;

constructor TBLImage.Create(const AWidth, AHeight: Integer;
  const AFormat: TBLFormat);
begin
  _BLCheck(_blImageInitAs(@Self, AWidth, AHeight, Ord(AFormat)));
end;

class operator TBLImage.Equal(const ALeft, ARight: TBLImage): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLImage.Equals(const AOther: TBLImage): Boolean;
begin
  Result := _blImageEquals(@Self, @AOther);
end;

class operator TBLImage.Equal(const ALeft: TBLImage;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.Format = TBLFormat.None) then
    Result := (ARight = nil)
  else
    Result := (ARight <> nil);
end;

class operator TBLImage.Finalize(var ADest: TBLImage);
begin
  if (ADest.FBase.NeedsCleanup) then
    _BLCheck(_blImageDestroy(@ADest));
end;

procedure TBLImage.GetData(out ADataOut: TBLImageData);
begin
  _BLCheck(_blImageGetData(@Self, @ADataOut));
end;

function TBLImage.GetDepth: Integer;
begin
  Result := PImpl(FBase.FImpl).Depth;
end;

function TBLImage.GetFormat: TBLFormat;
begin
  Result := TBLFormat(PImpl(FBase.FImpl).Format);
end;

function TBLImage.GetHeight: Integer;
begin
  Result := PImpl(FBase.FImpl).Size.H;
end;

function TBLImage.GetIsEmpty: Boolean;
begin
  Result := (Format = TBLFormat.None);
end;

function TBLImage.GetSize: TBLSizeI;
begin
  Result := PImpl(FBase.FImpl).Size;
end;

function TBLImage.GetWidth: Integer;
begin
  Result := PImpl(FBase.FImpl).Size.W;
end;

class operator TBLImage.Initialize(out ADest: TBLImage);
begin
  _BLCheck(_blImageInit(@ADest));
end;

procedure TBLImage.Make(const AWidth, AHeight: Integer;
  const AFormat: TBLFormat);
begin
  _BLCheck(_blImageCreate(@Self, AWidth, AHeight, Ord(AFormat)));
end;

procedure TBLImage.MakeFromData(const AWidth, AHeight: Integer;
  const AFormat: TBLFormat; const APixelData: Pointer; const AStride: IntPtr;
  const AAccessFlags: TBLDataAccessFlags;
  const ADestroyFunc: TBLDestroyExternalDataFunc; const AUserData: Pointer);
begin
  _BLCheck(_blImageCreateFromData(@Self, AWidth, AHeight, Ord(AFormat),
    APixelData, AStride, Byte(AAccessFlags), ADestroyFunc, AUserData));
end;

procedure TBLImage.MakeMutable(out ADataOut: TBLImageData);
begin
  _BLCheck(_blImageMakeMutable(@Self, @ADataOut));
end;

class operator TBLImage.NotEqual(const ALeft, ARight: TBLImage): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLImage.ReadFromData(const AArray: TBLArray<Byte>;
  const ACodecs: TBLArray<TBLImageCodec>);
begin
  _BLCheck(_blImageReadFromData(@Self, AArray.Data, AArray.Count, @ACodecs));
end;

procedure TBLImage.ReadFromData(const AArray: TBLArray<Byte>);
begin
  _BLCheck(_blImageReadFromData(@Self, AArray.Data, AArray.Count, nil));
end;

procedure TBLImage.ReadFromData(const AData: Pointer; const ASize: NativeInt;
  const ACodecs: TBLArray<TBLImageCodec>);
begin
  _BLCheck(_blImageReadFromData(@Self, AData, ASize, @ACodecs));
end;

procedure TBLImage.ReadFromData(const AData: Pointer; const ASize: NativeInt);
begin
  _BLCheck(_blImageReadFromData(@Self, AData, ASize, nil));
end;

procedure TBLImage.ReadFromData(const AView: TBLArrayView<Byte>;
  const ACodecs: TBLArray<TBLImageCodec>);
begin
  _BLCheck(_blImageReadFromData(@Self, AView.FData, AView.FCount, @ACodecs));
end;

procedure TBLImage.ReadFromData(const AView: TBLArrayView<Byte>);
begin
  _BLCheck(_blImageReadFromData(@Self, AView.FData, AView.FCount, nil));
end;

procedure TBLImage.ReadFromData(const AArray: TBytes;
  const ACodecs: TBLArray<TBLImageCodec>);
begin
  _BLCheck(_blImageReadFromData(@Self, AArray, Length(AArray), @ACodecs));
end;

procedure TBLImage.ReadFromData(const AArray: TBytes);
begin
  _BLCheck(_blImageReadFromData(@Self, AArray, Length(AArray), nil));
end;

procedure TBLImage.ReadFromFile(const AFilename: String);
begin
  _BLCheck(_blImageReadFromFile(@Self, PUTF8Char(UTF8String(AFilename)), nil));
end;

procedure TBLImage.ReadFromFile(const AFilename: String;
  const ACodecs: TBLArray<TBLImageCodec>);
begin
  _BLCheck(_blImageReadFromFile(@Self, PUTF8Char(UTF8String(AFilename)), @ACodecs));
end;

procedure TBLImage.Reset;
begin
  _BLCheck(_blImageReset(@Self));
end;

class procedure TBLImage.Scale(const ADst, ASrc: TBLImage;
  const ASize: TBLSizeI; const AFilter: TBLImageScaleFilter);
begin
  _BLCheck(_blImageScale(@ADst, @ASrc, @ASize, Ord(AFilter)));
end;

procedure TBLImage.Swap(var AOther: TBLImage);
begin
  FBase.Swap(AOther.FBase);
end;

function TBLImage.WriteToData(const ACodec: TBLImageCodec): TBytes;
begin
  var Dst: TBLArray<Byte>;
  _BLCheck(_blImageWriteToData(@Self, @Dst, @ACodec));
  SetLength(Result, Dst.Count);
  Move(Dst.Data^, Result[0], Dst.Count);
end;

procedure TBLImage.WriteToData(const ADst: TBLArray<Byte>;
  const ACodec: TBLImageCodec);
begin
  _BLCheck(_blImageWriteToData(@Self, @ADst, @ACodec));
end;

procedure TBLImage.WriteToFile(const AFilename: String;
  const ACodec: TBLImageCodec);
begin
  _BLCheck(_blImageWriteToFile(@Self, PUTF8Char(UTF8String(AFilename)), @ACodec));
end;

procedure TBLImage.WriteToFile(const AFilename: String);
begin
  _BLCheck(_blImageWriteToFile(@Self, PUTF8Char(UTF8String(AFilename)), nil));
end;

class operator TBLImage.NotEqual(const ALeft: TBLImage;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.Format = TBLFormat.None) then
    Result := (ARight <> nil)
  else
    Result := (ARight = nil);
end;

{$ENDREGION 'Imaging'}

{$REGION 'Variant'}
{ TBLVar }

class operator TBLVar.Assign(var ADest: TBLVar; const [ref] ASrc: TBLVar);
begin
  _BLCheck(_blVarInitWeak(@ADest, @ASrc));
end;

class operator TBLVar.Equal(const ALeft, ARight: TBLVar): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLVar.Equal(const ALeft: TBLVar; const ARight: Int64): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLVar.Equal(const ALeft: TBLVar;
  const ARight: Cardinal): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLVar.Equal(const ALeft: TBLVar;
  const ARight: Integer): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLVar.Equal(const ALeft: TBLVar;
  const ARight: Boolean): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLVar.Equal(const ALeft: TBLVar; const ARight: UInt64): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLVar.Equal(const ALeft: TBLVar;
  const ARight: TBLRgba64): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLVar.Equal(const ALeft: TBLVar;
  const ARight: TBLRgba32): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLVar.Equal(const ALeft: TBLVar;
  const ARight: TBLRgba): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLVar.Equal(const ALeft: TBLVar; const ARight: Double): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLVar.Equal(const ALeft: TBLVar;
  const ARight: TBLFontFace): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLVar.Equal(const ALeft: TBLVar;
  const ARight: TBLFontManager): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLVar.Equal(const ALeft: TBLVar;
  const ARight: TBLGradient): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLVar.Equal(const ALeft: TBLVar;
  const ARight: TBLBitArray): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLVar.Equal(const ALeft: TBLVar;
  const ARight: TBLFont): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLVar.Equal(const ALeft: TBLVar;
  const ARight: TBLFontData): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLVar.Equal(const ALeft: TBLVar;
  const ARight: TBLImage): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLVar.Equal(const ALeft: TBLVar;
  const ARight: TBLPath): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLVar.Equal(const ALeft: TBLVar;
  const ARight: TBLPattern): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLVar.Equal(const ALeft: TBLVar;
  const ARight: TBLString): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLVar.Equal(const ALeft: TBLVar;
  const ARight: TBLImageCodec): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLVar.Equal(const ALeft: TBLVar;
  const ARight: TBLImageDecoder): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

class operator TBLVar.Equal(const ALeft: TBLVar;
  const ARight: TBLImageEncoder): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLVar.Equals(const AOther: Int64): Boolean;
begin
  Result := _blVarEqualsInt64(@Self, AOther);
end;

function TBLVar.Equals(const AOther: Cardinal): Boolean;
begin
  Result := _blVarEqualsUInt64(@Self, AOther);
end;

function TBLVar.Equals(const AOther: Integer): Boolean;
begin
  Result := _blVarEqualsInt64(@Self, AOther);
end;

function TBLVar.Equals(const AOther: Boolean): Boolean;
begin
  Result := _blVarEqualsBool(@Self, AOther);
end;

function TBLVar.Equals(const AOther: UInt64): Boolean;
begin
  Result := _blVarEqualsUInt64(@Self, AOther);
end;

function TBLVar.Equals(const AOther: TBLRgba64): Boolean;
begin
  Result := _blVarEqualsRgba64(@Self, AOther.Value);
end;

function TBLVar.Equals(const AOther: TBLRgba32): Boolean;
begin
  Result := _blVarEqualsRgba32(@Self, AOther.Value);
end;

function TBLVar.Equals(const AOther: TBLRgba): Boolean;
begin
  Result := _blVarEqualsRgba(@Self, @AOther);
end;

function TBLVar.Equals(const AOther: Double): Boolean;
begin
  Result := _blVarEqualsDouble(@Self, AOther);
end;

function TBLVar.Equals(const AOther: TBLVar): Boolean;
begin
  Result := _blVarEquals(@Self, @AOther);
end;

function TBLVar.Equals(const AOther: TBLFontFace): Boolean;
begin
  Result := _blVarEquals(@Self, @AOther);
end;

function TBLVar.Equals(const AOther: TBLFontManager): Boolean;
begin
  Result := _blVarEquals(@Self, @AOther);
end;

function TBLVar.Equals(const AOther: TBLGradient): Boolean;
begin
  Result := _blVarEquals(@Self, @AOther);
end;

function TBLVar.Equals(const AOther: TBLBitArray): Boolean;
begin
  Result := _blVarEquals(@Self, @AOther);
end;

function TBLVar.Equals(const AOther: TBLFont): Boolean;
begin
  Result := _blVarEquals(@Self, @AOther);
end;

function TBLVar.Equals(const AOther: TBLFontData): Boolean;
begin
  Result := _blVarEquals(@Self, @AOther);
end;

function TBLVar.Equals(const AOther: TBLImage): Boolean;
begin
  Result := _blVarEquals(@Self, @AOther);
end;

function TBLVar.Equals(const AOther: TBLPath): Boolean;
begin
  Result := _blVarEquals(@Self, @AOther);
end;

function TBLVar.Equals(const AOther: TBLPattern): Boolean;
begin
  Result := _blVarEquals(@Self, @AOther);
end;

function TBLVar.Equals(const AOther: TBLString): Boolean;
begin
  Result := _blVarEquals(@Self, @AOther);
end;

function TBLVar.Equals(const AOther: TBLImageCodec): Boolean;
begin
  Result := _blVarEquals(@Self, @AOther);
end;

function TBLVar.Equals(const AOther: TBLImageDecoder): Boolean;
begin
  Result := _blVarEquals(@Self, @AOther);
end;

function TBLVar.Equals(const AOther: TBLImageEncoder): Boolean;
begin
  Result := _blVarEquals(@Self, @AOther);
end;

class operator TBLVar.Finalize(var ADest: TBLVar);
begin
  if (ADest.FBase.NeedsCleanup) then
    _BLCheck(_blVarDestroy(@ADest));
end;

function TBLVar.GetIsArray: Boolean;
begin
  var ObjType := GetObjectType;
  Result := (ObjType >= TBLObjectType.MinArray) and (ObjType <= TBLObjectType.MaxArray);
end;

function TBLVar.GetIsBitArray: Boolean;
begin
  Result := (GetObjectType = TBLObjectType.BitArray);
end;

function TBLVar.GetIsBoolean: Boolean;
begin
  Result := (GetObjectType = TBLObjectType.Bool);
end;

function TBLVar.GetIsContext: Boolean;
begin
  Result := (GetObjectType = TBLObjectType.Context);
end;

function TBLVar.GetIsDouble: Boolean;
begin
  Result := (GetObjectType = TBLObjectType.Double);
end;

function TBLVar.GetIsFont: Boolean;
begin
  Result := (GetObjectType = TBLObjectType.Font);
end;

function TBLVar.GetIsFontData: Boolean;
begin
  Result := (GetObjectType = TBLObjectType.FontData);
end;

function TBLVar.GetIsFontFace: Boolean;
begin
  Result := (GetObjectType = TBLObjectType.FontFace);
end;

function TBLVar.GetIsFontManager: Boolean;
begin
  Result := (GetObjectType = TBLObjectType.FontManager);
end;

function TBLVar.GetIsGradient: Boolean;
begin
  Result := (GetObjectType = TBLObjectType.Gradient);
end;

function TBLVar.GetIsImage: Boolean;
begin
  Result := (GetObjectType = TBLObjectType.Image);
end;

function TBLVar.GetIsImageCodec: Boolean;
begin
  Result := (GetObjectType = TBLObjectType.ImageCodec);
end;

function TBLVar.GetIsImageDecoder: Boolean;
begin
  Result := (GetObjectType = TBLObjectType.ImageDecoder);
end;

function TBLVar.GetIsImageEncoder: Boolean;
begin
  Result := (GetObjectType = TBLObjectType.ImageEncoder);
end;

function TBLVar.GetIsInt64: Boolean;
begin
  Result := (GetObjectType = TBLObjectType.Int64);
end;

function TBLVar.GetIsNull: Boolean;
begin
  Result := (GetObjectType = TBLObjectType.Null);
end;

function TBLVar.GetIsPath: Boolean;
begin
  Result := (GetObjectType = TBLObjectType.Path);
end;

function TBLVar.GetIsPattern: Boolean;
begin
  Result := (GetObjectType = TBLObjectType.Pattern);
end;

function TBLVar.GetIsRgba: Boolean;
begin
  Result := (GetObjectType = TBLObjectType.Rgba);
end;

function TBLVar.GetIsRgba32: Boolean;
begin
  Result := (GetObjectType = TBLObjectType.Rgba32);
end;

function TBLVar.GetIsRgba64: Boolean;
begin
  Result := (GetObjectType = TBLObjectType.Rgba64);
end;

function TBLVar.GetIsString: Boolean;
begin
  Result := (GetObjectType = TBLObjectType.String);
end;

function TBLVar.GetIsStyle: Boolean;
begin
  var ObjType := GetObjectType;
  Result := (ObjType >= TBLObjectType.MinStyle) and (ObjType <= TBLObjectType.MaxStyle);
end;

function TBLVar.GetIsUInt64: Boolean;
begin
  Result := (GetObjectType = TBLObjectType.UInt64);
end;

class function TBLVar.GetNull: TBLVar;
begin
  { Uses Initialize operator }
end;

function TBLVar.GetObjectType: TBLObjectType;
begin
  Result := TBLObjectType(_blVarGetType(@Self));
end;

class operator TBLVar.Implicit(const AValue: Int64): TBLVar;
begin
  _BLCheck(_blVarAssignInt64(@Result, AValue));
end;

class operator TBLVar.Implicit(const AValue: Cardinal): TBLVar;
begin
  _BLCheck(_blVarAssignUInt32(@Result, AValue));
end;

class operator TBLVar.Implicit(const AValue: Integer): TBLVar;
begin
  _BLCheck(_blVarAssignInt32(@Result, AValue));
end;

class operator TBLVar.Implicit(const AValue: Boolean): TBLVar;
begin
  _BLCheck(_blVarAssignBool(@Result, AValue));
end;

class operator TBLVar.Implicit(const AValue: UInt64): TBLVar;
begin
  _BLCheck(_blVarAssignUInt64(@Result, AValue));
end;

class operator TBLVar.Implicit(const AValue: TBLRgba64): TBLVar;
begin
  _BLCheck(_blVarAssignRgba64(@Result, AValue.Value));
end;

class operator TBLVar.Implicit(const AValue: TBLRgba32): TBLVar;
begin
  _BLCheck(_blVarAssignRgba32(@Result, AValue.Value));
end;

class operator TBLVar.Implicit(const AValue: TBLRgba): TBLVar;
begin
  _BLCheck(_blVarAssignRgba(@Result, @AValue));
end;

class operator TBLVar.Implicit(const AValue: Double): TBLVar;
begin
  _BLCheck(_blVarAssignDouble(@Result, AValue));
end;

class operator TBLVar.Implicit(const AValue: TBLFontFace): TBLVar;
begin
  _BLCheck(_blVarAssignWeak(@Result, @AValue));
end;

class operator TBLVar.Implicit(const AValue: TBLFontManager): TBLVar;
begin
  _BLCheck(_blVarAssignWeak(@Result, @AValue));
end;

class operator TBLVar.Implicit(const AValue: TBLGradient): TBLVar;
begin
  _BLCheck(_blVarAssignWeak(@Result, @AValue));
end;

class operator TBLVar.Implicit(const AValue: TBLBitArray): TBLVar;
begin
  _BLCheck(_blVarAssignWeak(@Result, @AValue));
end;

class operator TBLVar.Implicit(const AValue: TBLFont): TBLVar;
begin
  _BLCheck(_blVarAssignWeak(@Result, @AValue));
end;

class operator TBLVar.Implicit(const AValue: TBLFontData): TBLVar;
begin
  _BLCheck(_blVarAssignWeak(@Result, @AValue));
end;

class operator TBLVar.Implicit(const AValue: TBLImage): TBLVar;
begin
  _BLCheck(_blVarAssignWeak(@Result, @AValue));
end;

class operator TBLVar.Implicit(const AValue: TBLPath): TBLVar;
begin
  _BLCheck(_blVarAssignWeak(@Result, @AValue));
end;

class operator TBLVar.Implicit(const AValue: TBLPattern): TBLVar;
begin
  _BLCheck(_blVarAssignWeak(@Result, @AValue));
end;

class operator TBLVar.Implicit(const AValue: TBLString): TBLVar;
begin
  _BLCheck(_blVarAssignWeak(@Result, @AValue));
end;

class operator TBLVar.Implicit(const AValue: TBLImageCodec): TBLVar;
begin
  _BLCheck(_blVarAssignWeak(@Result, @AValue));
end;

class operator TBLVar.Implicit(const AValue: TBLImageDecoder): TBLVar;
begin
  _BLCheck(_blVarAssignWeak(@Result, @AValue));
end;

class operator TBLVar.Implicit(const AValue: TBLImageEncoder): TBLVar;
begin
  _BLCheck(_blVarAssignWeak(@Result, @AValue));
end;

class operator TBLVar.Initialize(out ADest: TBLVar);
begin
  _BLCheck(_blVarInitNull(@ADest));
end;

class operator TBLVar.NotEqual(const ALeft: TBLVar;
  const ARight: Int64): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLVar.NotEqual(const ALeft: TBLVar;
  const ARight: Cardinal): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLVar.NotEqual(const ALeft: TBLVar;
  const ARight: Integer): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLVar.NotEqual(const ALeft: TBLVar;
  const ARight: Boolean): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLVar.NotEqual(const ALeft: TBLVar;
  const ARight: UInt64): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLVar.NotEqual(const ALeft: TBLVar;
  const ARight: TBLRgba64): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLVar.NotEqual(const ALeft: TBLVar;
  const ARight: TBLRgba32): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLVar.NotEqual(const ALeft: TBLVar;
  const ARight: TBLRgba): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLVar.NotEqual(const ALeft: TBLVar;
  const ARight: Double): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLVar.NotEqual(const ALeft, ARight: TBLVar): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLVar.NotEqual(const ALeft: TBLVar;
  const ARight: TBLFontFace): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLVar.NotEqual(const ALeft: TBLVar;
  const ARight: TBLFontManager): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLVar.NotEqual(const ALeft: TBLVar;
  const ARight: TBLGradient): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLVar.NotEqual(const ALeft: TBLVar;
  const ARight: TBLBitArray): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLVar.NotEqual(const ALeft: TBLVar;
  const ARight: TBLFont): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLVar.NotEqual(const ALeft: TBLVar;
  const ARight: TBLFontData): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLVar.NotEqual(const ALeft: TBLVar;
  const ARight: TBLImage): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLVar.NotEqual(const ALeft: TBLVar;
  const ARight: TBLPath): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLVar.NotEqual(const ALeft: TBLVar;
  const ARight: TBLPattern): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLVar.NotEqual(const ALeft: TBLVar;
  const ARight: TBLString): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLVar.NotEqual(const ALeft: TBLVar;
  const ARight: TBLImageCodec): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLVar.NotEqual(const ALeft: TBLVar;
  const ARight: TBLImageDecoder): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

class operator TBLVar.NotEqual(const ALeft: TBLVar;
  const ARight: TBLImageEncoder): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLVar.Reset;
begin
  _BLCheck(_blVarReset(@Self));
end;

function TBLVar.StrictEquals(const AOther: TBLVar): Boolean;
begin
  Result := _blVarStrictEquals(@Self, @AOther);
end;

procedure TBLVar.Swap(var AOther: TBLVar);
begin
  FBase.Swap(AOther.FBase);
end;

function TBLVar.ToBoolean: Boolean;
begin
  _BLCheck(_blVarToBool(@Self, @Result));
end;

function TBLVar.ToCardinal: Cardinal;
begin
  _BLCheck(_blVarToUInt32(@Self, @Result));
end;

function TBLVar.ToDouble: Double;
begin
  _BLCheck(_blVarToDouble(@Self, @Result));
end;

function TBLVar.ToInt64: Int64;
begin
  _BLCheck(_blVarToInt64(@Self, @Result));
end;

function TBLVar.ToInteger: Integer;
begin
  _BLCheck(_blVarToInt32(@Self, @Result));
end;

function TBLVar.ToRgba: TBLRgba;
begin
  _BLCheck(_blVarToRgba(@Self, @Result));
end;

function TBLVar.ToRgba32: TBLRgba32;
begin
  _BLCheck(_blVarToRgba32(@Self, @Result));
end;

function TBLVar.ToRgba64: TBLRgba64;
begin
  _BLCheck(_blVarToRgba64(@Self, @Result));
end;

function TBLVar.ToUInt64: UInt64;
begin
  _BLCheck(_blVarToUInt64(@Self, @Result));
end;

{$ENDREGION 'Variant'}

{$REGION 'Rendering'}

{ TBLContextCreateInfo }

procedure TBLContextCreateInfo.Reset;
begin
  FillChar(Self, SizeOf(Self), 0);
end;

{ TBLContextCookie }

class operator TBLContextCookie.Equal(const ALeft,
  ARight: TBLContextCookie): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLContextCookie.Equals(const AOther: TBLContextCookie): Boolean;
begin
  Result := (FData[0] = AOther.FData[0]) and (FData[1] = AOther.FData[1]);
end;

function TBLContextCookie.GetIsEmpty: Boolean;
begin
  Result := (FData[0] = 0) and (FData[1] = 0);
end;

class operator TBLContextCookie.NotEqual(const ALeft,
  ARight: TBLContextCookie): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLContextCookie.Reset(const AData0, AData1: UInt64);
begin
  FData[0] := AData0;
  FData[1] := AData1;
end;

procedure TBLContextCookie.Reset;
begin
  FData[0] := 0;
  FData[1] := 0;
end;

procedure TBLContextCookie.Reset(const AOther: TBLContextCookie);
begin
  FData[0] := AOther.FData[0];
  FData[1] := AOther.FData[1];
end;

{ TBLContextHints }

function TBLContextHints.GetGradientQuality: TBLGradientQuality;
begin
  Result := TBLGradientQuality(Hints[TBLContextHint.GradientQuality])
end;

function TBLContextHints.GetPatternQuality: TBLPatternQuality;
begin
  Result := TBLPatternQuality(Hints[TBLContextHint.PatternQuality])
end;

function TBLContextHints.GetRenderingQuality: TBLRenderingQuality;
begin
  Result := TBLRenderingQuality(Hints[TBLContextHint.RenderingQuality])
end;

procedure TBLContextHints.Reset;
begin
  FillChar(Self, SizeOf(Self), 0);
end;

{ TBLContext }

procedure TBLContext.ApplyTransform(const ATransform: TBLMatrix2D);
begin
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.Transform), @ATransform));
end;

class operator TBLContext.Assign(var ADest: TBLContext; const [ref] ASrc: TBLContext);
begin
  _BLCheck(_blContextInitWeak(@ADest, @ASrc));
end;

procedure TBLContext.BlitImage(const AOrigin: TBLPoint; const ASrc: TBLImage;
  const ASrcArea: TBLRect);
begin
  _BLCheck(_blContextBlitImageD(@Self, @AOrigin, @ASrc, @ASrcArea));
end;

procedure TBLContext.BlitImage(const AOrigin: TBLPoint; const ASrc: TBLImage);
begin
  _BLCheck(_blContextBlitImageD(@Self, @AOrigin, @ASrc, nil));
end;

procedure TBLContext.BlitImage(const AOrigin: TBLPointI; const ASrc: TBLImage;
  const ASrcArea: TBLRectI);
begin
  _BLCheck(_blContextBlitImageI(@Self, @AOrigin, @ASrc, @ASrcArea));
end;

procedure TBLContext.BlitImage(const AOrigin: TBLPointI; const ASrc: TBLImage);
begin
  _BLCheck(_blContextBlitImageI(@Self, @AOrigin, @ASrc, nil));
end;

procedure TBLContext.BlitImage(const ARect: TBLRect; const ASrc: TBLImage;
  const ASrcArea: TBLRect);
begin
  _BLCheck(_blContextBlitScaledImageD(@Self, @ARect, @ASrc, @ASrcArea));
end;

procedure TBLContext.BlitImage(const ARect: TBLRect; const ASrc: TBLImage);
begin
  _BLCheck(_blContextBlitScaledImageD(@Self, @ARect, @ASrc, nil));
end;

procedure TBLContext.BlitImage(const ARect: TBLRectI; const ASrc: TBLImage;
  const ASrcArea: TBLRectI);
begin
  _BLCheck(_blContextBlitScaledImageI(@Self, @ARect, @ASrc, @ASrcArea));
end;

procedure TBLContext.BlitImage(const ARect: TBLRectI; const ASrc: TBLImage);
begin
  _BLCheck(_blContextBlitScaledImageI(@Self, @ARect, @ASrc, nil));
end;

procedure TBLContext.ClearAll;
begin
  _BLCheck(_blContextClearAll(@Self));
end;

procedure TBLContext.ClearRect(const ARect: TBLRectI);
begin
  _BLCheck(_blContextClearRectI(@Self, @ARect));
end;

procedure TBLContext.ClearRect(const ARect: TBLRect);
begin
  _BLCheck(_blContextClearRectD(@Self, @ARect));
end;

procedure TBLContext.ClearRect(const AX, AY, AW, AH: Double);
begin
  var R := BLRect(AX, AY, AW, AH);
  _BLCheck(_blContextClearRectD(@Self, @R));
end;

procedure TBLContext.ClipToRect(const ARect: TBLRectI);
begin
  _BLCheck(_blContextClipToRectI(@Self, @ARect));
end;

procedure TBLContext.ClipToRect(const ARect: TBLRect);
begin
  _BLCheck(_blContextClipToRectD(@Self, @ARect));
end;

procedure TBLContext.ClipToRect(const AX, AY, AW, AH: Double);
begin
  var R := BLRect(AX, AY, AW, AH);
  _BLCheck(_blContextClipToRectD(@Self, @R));
end;

constructor TBLContext.Create(const ATarget: TBLImage;
  const ACreateInfo: TBLContextCreateInfo);
begin
  _BLCheck(_blContextInitAs(@Self, @ATarget, @ACreateInfo));
end;

procedure TBLContext.DisableFillStyle;
begin
  _BLCheck(_blContextDisableFillStyle(@Self));
end;

procedure TBLContext.DisableStrokeStyle;
begin
  _BLCheck(_blContextDisableStrokeStyle(@Self));
end;

procedure TBLContext.DisableStyle(const ASlot: TBLContextStyleSlot);
begin
  if (ASlot = TBLContextStyleSlot.Fill) then
    _BLCheck(_blContextDisableFillStyle(@Self))
  else
    _BLCheck(_blContextDisableStrokeStyle(@Self));
end;

class operator TBLContext.Equal(const ALeft: TBLContext;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsValid) then
    Result := (ARight <> nil)
  else
    Result := (ARight = nil);
end;

class operator TBLContext.Equal(const ALeft, ARight: TBLContext): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLContext.Equals(const AOther: TBLContext): Boolean;
begin
  Result := (FBase.FImpl = AOther.FBase.FImpl);
end;

constructor TBLContext.Create(const ATarget: TBLImage);
begin
  _BLCheck(_blContextInitAs(@Self, @ATarget, nil));
end;

procedure TBLContext.FillAll(const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillAllRgba64(@Self, AStyle.Value));
end;

procedure TBLContext.FillAll(const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillAllRgba32(@Self, AStyle.Value));
end;

procedure TBLContext.FillAll(const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillAllExt(@Self, @Style));
end;

procedure TBLContext.FillAll;
begin
  _BLCheck(_blContextFillAll(@Self));
end;

procedure TBLContext.FillAll(const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillAllExt(@Self, @AStyle));
end;

procedure TBLContext.FillAll(const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillAllExt(@Self, @AStyle));
end;

procedure TBLContext.FillAll(const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillAllExt(@Self, @AStyle));
end;

procedure TBLContext.FillAll(const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillAllRgba32(@Self, AStyle));
end;

procedure TBLContext.FillBox(const ABox: TBLBox; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillGeometryRgba64(@Self, Ord(TBLGeometryType.BoxD), @ABox, AStyle.Value));
end;

procedure TBLContext.FillBox(const ABox: TBLBox; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.BoxD), @ABox, AStyle.Value));
end;

procedure TBLContext.FillBox(const ABox: TBLBox; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.BoxD), @ABox, @Style));
end;

procedure TBLContext.FillBox(const ABox: TBLBox);
begin
  _BLCheck(_blContextFillGeometry(@Self, Ord(TBLGeometryType.BoxD), @ABox));
end;

procedure TBLContext.FillBox(const ABox: TBLBox; const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.BoxD), @ABox, @AStyle));
end;

procedure TBLContext.FillBox(const ABox: TBLBox; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.BoxD), @ABox, @AStyle));
end;

procedure TBLContext.FillBox(const ABox: TBLBox; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.BoxD), @ABox, @AStyle));
end;

procedure TBLContext.FillBox(const ABox: TBLBox; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.BoxD), @ABox, AStyle));
end;

procedure TBLContext.FillBox(const ABox: TBLBoxI; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillGeometryRgba64(@Self, Ord(TBLGeometryType.BoxI), @ABox, AStyle.Value));
end;

procedure TBLContext.FillBox(const ABox: TBLBoxI; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.BoxI), @ABox, AStyle.Value));
end;

procedure TBLContext.FillBox(const ABox: TBLBoxI; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.BoxI), @ABox, @Style));
end;

procedure TBLContext.FillBox(const ABox: TBLBoxI);
begin
  _BLCheck(_blContextFillGeometry(@Self, Ord(TBLGeometryType.BoxI), @ABox));
end;

procedure TBLContext.FillBox(const ABox: TBLBoxI; const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.BoxI), @ABox, @AStyle));
end;

procedure TBLContext.FillBox(const ABox: TBLBoxI; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.BoxI), @ABox, @AStyle));
end;

procedure TBLContext.FillBox(const ABox: TBLBoxI; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.BoxI), @ABox, @AStyle));
end;

procedure TBLContext.FillBox(const ABox: TBLBoxI; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.BoxI), @ABox, AStyle));
end;

procedure TBLContext.FillBox(const AX0, AY0, AX1, AY1: Double;
  const AStyle: TBLRgba64);
begin
  FillBox(BLBox(AX0, AY0, AX1, AY1), AStyle);
end;

procedure TBLContext.FillBox(const AX0, AY0, AX1, AY1: Double;
  const AStyle: TBLRgba32);
begin
  FillBox(BLBox(AX0, AY0, AX1, AY1), AStyle);
end;

procedure TBLContext.FillBox(const AX0, AY0, AX1, AY1: Double;
  const AStyle: TBLRgba);
begin
  FillBox(BLBox(AX0, AY0, AX1, AY1), AStyle);
end;

procedure TBLContext.FillBox(const AX0, AY0, AX1, AY1: Double);
begin
  FillBox(BLBox(AX0, AY0, AX1, AY1));
end;

procedure TBLContext.FillBox(const AX0, AY0, AX1, AY1: Double;
  const AStyle: TBLVar);
begin
  FillBox(BLBox(AX0, AY0, AX1, AY1), AStyle);
end;

procedure TBLContext.FillBox(const AX0, AY0, AX1, AY1: Double;
  const AStyle: TBLGradient);
begin
  FillBox(BLBox(AX0, AY0, AX1, AY1), AStyle);
end;

procedure TBLContext.FillBox(const AX0, AY0, AX1, AY1: Double;
  const AStyle: TBLPattern);
begin
  FillBox(BLBox(AX0, AY0, AX1, AY1), AStyle);
end;

procedure TBLContext.FillBox(const AX0, AY0, AX1, AY1: Double;
  const AStyle: TAlphaColor);
begin
  FillBox(BLBox(AX0, AY0, AX1, AY1), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: TBLArrayView<TBLBox>;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillGeometryRgba64(@Self, Ord(TBLGeometryType.ArrayViewBoxD), @AArray, AStyle.Value));
end;

procedure TBLContext.FillBoxArray(const AArray: TBLArrayView<TBLBox>;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.ArrayViewBoxD), @AArray, AStyle.Value));
end;

procedure TBLContext.FillBoxArray(const AArray: TBLArrayView<TBLBox>;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewBoxD), @AArray, @Style));
end;

procedure TBLContext.FillBoxArray(const AArray: TBLArrayView<TBLBox>);
begin
  _BLCheck(_blContextFillGeometry(@Self, Ord(TBLGeometryType.ArrayViewBoxD), @AArray));
end;

procedure TBLContext.FillBoxArray(const AArray: TBLArrayView<TBLBox>;
  const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewBoxD), @AArray, @AStyle));
end;

procedure TBLContext.FillBoxArray(const AArray: TBLArrayView<TBLBox>;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewBoxD), @AArray, @AStyle));
end;

procedure TBLContext.FillBoxArray(const AArray: TBLArrayView<TBLBox>;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewBoxD), @AArray, @AStyle));
end;

procedure TBLContext.FillBoxArray(const AArray: TBLArrayView<TBLBox>;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.ArrayViewBoxD), @AArray, AStyle));
end;

procedure TBLContext.FillBoxArray(const AArray: TArray<TBLBox>;
  const AStyle: TBLRgba64);
begin
  FillBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: TArray<TBLBox>;
  const AStyle: TBLRgba32);
begin
  FillBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: TArray<TBLBox>;
  const AStyle: TBLRgba);
begin
  FillBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: TArray<TBLBox>);
begin
  FillBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), Length(AArray)));
end;

procedure TBLContext.FillBoxArray(const AArray: TArray<TBLBox>;
  const AStyle: TBLVar);
begin
  FillBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: TArray<TBLBox>;
  const AStyle: TBLGradient);
begin
  FillBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: TArray<TBLBox>;
  const AStyle: TBLPattern);
begin
  FillBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: TArray<TBLBox>;
  const AStyle: TAlphaColor);
begin
  FillBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: PBLBox; const ACount: NativeInt;
  const AStyle: TBLRgba64);
begin
  FillBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: PBLBox; const ACount: NativeInt;
  const AStyle: TBLRgba32);
begin
  FillBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: PBLBox; const ACount: NativeInt;
  const AStyle: TBLRgba);
begin
  FillBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: PBLBox;
  const ACount: NativeInt);
begin
  FillBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), ACount));
end;

procedure TBLContext.FillBoxArray(const AArray: PBLBox; const ACount: NativeInt;
  const AStyle: TBLVar);
begin
  FillBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: PBLBox; const ACount: NativeInt;
  const AStyle: TBLGradient);
begin
  FillBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: PBLBox; const ACount: NativeInt;
  const AStyle: TBLPattern);
begin
  FillBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: PBLBox; const ACount: NativeInt;
  const AStyle: TAlphaColor);
begin
  FillBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: TBLArrayView<TBLBoxI>;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillGeometryRgba64(@Self, Ord(TBLGeometryType.ArrayViewBoxI), @AArray, AStyle.Value));
end;

procedure TBLContext.FillBoxArray(const AArray: TBLArrayView<TBLBoxI>;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.ArrayViewBoxI), @AArray, AStyle.Value));
end;

procedure TBLContext.FillBoxArray(const AArray: TBLArrayView<TBLBoxI>;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewBoxI), @AArray, @Style));
end;

procedure TBLContext.FillBoxArray(const AArray: TBLArrayView<TBLBoxI>);
begin
  _BLCheck(_blContextFillGeometry(@Self, Ord(TBLGeometryType.ArrayViewBoxI), @AArray));
end;

procedure TBLContext.FillBoxArray(const AArray: TBLArrayView<TBLBoxI>;
  const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewBoxI), @AArray, @AStyle));
end;

procedure TBLContext.FillBoxArray(const AArray: TBLArrayView<TBLBoxI>;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewBoxI), @AArray, @AStyle));
end;

procedure TBLContext.FillBoxArray(const AArray: TBLArrayView<TBLBoxI>;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewBoxI), @AArray, @AStyle));
end;

procedure TBLContext.FillBoxArray(const AArray: TBLArrayView<TBLBoxI>;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.ArrayViewBoxI), @AArray, AStyle));
end;

procedure TBLContext.FillBoxArray(const AArray: TArray<TBLBoxI>;
  const AStyle: TBLRgba64);
begin
  FillBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: TArray<TBLBoxI>;
  const AStyle: TBLRgba32);
begin
  FillBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: TArray<TBLBoxI>;
  const AStyle: TBLRgba);
begin
  FillBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: TArray<TBLBoxI>);
begin
  FillBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), Length(AArray)));
end;

procedure TBLContext.FillBoxArray(const AArray: TArray<TBLBoxI>;
  const AStyle: TBLVar);
begin
  FillBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: TArray<TBLBoxI>;
  const AStyle: TBLGradient);
begin
  FillBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: TArray<TBLBoxI>;
  const AStyle: TBLPattern);
begin
  FillBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: TArray<TBLBoxI>;
  const AStyle: TAlphaColor);
begin
  FillBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: PBLBoxI; const ACount: NativeInt;
  const AStyle: TBLRgba64);
begin
  FillBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: PBLBoxI; const ACount: NativeInt;
  const AStyle: TBLRgba32);
begin
  FillBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: PBLBoxI; const ACount: NativeInt;
  const AStyle: TBLRgba);
begin
  FillBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: PBLBoxI;
  const ACount: NativeInt);
begin
  FillBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), ACount));
end;

procedure TBLContext.FillBoxArray(const AArray: PBLBoxI; const ACount: NativeInt;
  const AStyle: TBLVar);
begin
  FillBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: PBLBoxI; const ACount: NativeInt;
  const AStyle: TBLGradient);
begin
  FillBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: PBLBoxI; const ACount: NativeInt;
  const AStyle: TBLPattern);
begin
  FillBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillBoxArray(const AArray: PBLBoxI; const ACount: NativeInt;
  const AStyle: TAlphaColor);
begin
  FillBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillCircle(const ACircle: TBLCircle;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillGeometryRgba64(@Self, Ord(TBLGeometryType.Circle), @ACircle, AStyle.Value));
end;

procedure TBLContext.FillCircle(const ACircle: TBLCircle;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.Circle), @ACircle, AStyle.Value));
end;

procedure TBLContext.FillCircle(const ACircle: TBLCircle;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.Circle), @ACircle, @Style));
end;

procedure TBLContext.FillCircle(const ACircle: TBLCircle);
begin
  _BLCheck(_blContextFillGeometry(@Self, Ord(TBLGeometryType.Circle), @ACircle));
end;

procedure TBLContext.FillCircle(const ACircle: TBLCircle; const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.Circle), @ACircle, @AStyle));
end;

procedure TBLContext.FillCircle(const ACircle: TBLCircle;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.Circle), @ACircle, @AStyle));
end;

procedure TBLContext.FillCircle(const ACircle: TBLCircle;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.Circle), @ACircle, @AStyle));
end;

procedure TBLContext.FillCircle(const ACircle: TBLCircle;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.Circle), @ACircle, AStyle));
end;

procedure TBLContext.FillCircle(const ACX, ACY, AR: Double;
  const AStyle: TBLRgba64);
begin
  FillCircle(BLCircle(ACX, ACY, AR), AStyle);
end;

procedure TBLContext.FillCircle(const ACX, ACY, AR: Double;
  const AStyle: TBLRgba32);
begin
  FillCircle(BLCircle(ACX, ACY, AR), AStyle);
end;

procedure TBLContext.FillCircle(const ACX, ACY, AR: Double;
  const AStyle: TBLRgba);
begin
  FillCircle(BLCircle(ACX, ACY, AR), AStyle);
end;

procedure TBLContext.FillCircle(const ACX, ACY, AR: Double);
begin
  FillCircle(BLCircle(ACX, ACY, AR));
end;

procedure TBLContext.FillCircle(const ACX, ACY, AR: Double;
  const AStyle: TBLVar);
begin
  FillCircle(BLCircle(ACX, ACY, AR), AStyle);
end;

procedure TBLContext.FillCircle(const ACX, ACY, AR: Double;
  const AStyle: TBLGradient);
begin
  FillCircle(BLCircle(ACX, ACY, AR), AStyle);
end;

procedure TBLContext.FillCircle(const ACX, ACY, AR: Double;
  const AStyle: TBLPattern);
begin
  FillCircle(BLCircle(ACX, ACY, AR), AStyle);
end;

procedure TBLContext.FillCircle(const ACX, ACY, AR: Double;
  const AStyle: TAlphaColor);
begin
  FillCircle(BLCircle(ACX, ACY, AR), AStyle);
end;

procedure TBLContext.FillChord(const AChord: TBLArc; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillGeometryRgba64(@Self, Ord(TBLGeometryType.Chord), @AChord, AStyle.Value));
end;

procedure TBLContext.FillChord(const AChord: TBLArc; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.Chord), @AChord, AStyle.Value));
end;

procedure TBLContext.FillChord(const AChord: TBLArc; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.Chord), @AChord, @Style));
end;

procedure TBLContext.FillChord(const AChord: TBLArc);
begin
  _BLCheck(_blContextFillGeometry(@Self, Ord(TBLGeometryType.Chord), @AChord));
end;

procedure TBLContext.FillChord(const AChord: TBLArc; const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.Chord), @AChord, @AStyle));
end;

procedure TBLContext.FillChord(const AChord: TBLArc; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.Chord), @AChord, @AStyle));
end;

procedure TBLContext.FillChord(const AChord: TBLArc; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.Chord), @AChord, @AStyle));
end;

procedure TBLContext.FillChord(const AChord: TBLArc; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.Chord), @AChord, AStyle));
end;

procedure TBLContext.FillChord(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLRgba64);
begin
  FillChord(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillChord(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLRgba32);
begin
  FillChord(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillChord(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLRgba);
begin
  FillChord(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillChord(const ACX, ACY, AR, AStart, ASweep: Double);
begin
  FillChord(BLArc(ACX, ACY, AR, AR, AStart, ASweep));
end;

procedure TBLContext.FillChord(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLVar);
begin
  FillChord(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillChord(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLGradient);
begin
  FillChord(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillChord(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLPattern);
begin
  FillChord(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillChord(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TAlphaColor);
begin
  FillChord(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLRgba64);
begin
  FillChord(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLRgba32);
begin
  FillChord(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLRgba);
begin
  FillChord(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillChord(const ACX, ACY, ARX, ARY, AStart,
  ASweep: Double);
begin
  FillChord(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep));
end;

procedure TBLContext.FillChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLVar);
begin
  FillChord(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLGradient);
begin
  FillChord(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLPattern);
begin
  FillChord(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TAlphaColor);
begin
  FillChord(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillEllipse(const AEllipse: TBLEllipse;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillGeometryRgba64(@Self, Ord(TBLGeometryType.Ellipse), @AEllipse, AStyle.Value));
end;

procedure TBLContext.FillEllipse(const AEllipse: TBLEllipse;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.Ellipse), @AEllipse, AStyle.Value));
end;

procedure TBLContext.FillEllipse(const AEllipse: TBLEllipse;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.Ellipse), @AEllipse, @Style));
end;

procedure TBLContext.FillEllipse(const AEllipse: TBLEllipse);
begin
  _BLCheck(_blContextFillGeometry(@Self, Ord(TBLGeometryType.Ellipse), @AEllipse));
end;

procedure TBLContext.FillEllipse(const AEllipse: TBLEllipse;
  const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.Ellipse), @AEllipse, @AStyle));
end;

procedure TBLContext.FillEllipse(const AEllipse: TBLEllipse;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.Ellipse), @AEllipse, @AStyle));
end;

procedure TBLContext.FillEllipse(const AEllipse: TBLEllipse;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.Ellipse), @AEllipse, @AStyle));
end;

procedure TBLContext.FillEllipse(const AEllipse: TBLEllipse;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.Ellipse), @AEllipse, AStyle));
end;

procedure TBLContext.FillEllipse(const ACX, ACY, ARX, ARY: Double;
  const AStyle: TBLRgba64);
begin
  FillEllipse(BLEllipse(ACX, ACY, ARX, ARY), AStyle);
end;

procedure TBLContext.FillEllipse(const ACX, ACY, ARX, ARY: Double;
  const AStyle: TBLRgba32);
begin
  FillEllipse(BLEllipse(ACX, ACY, ARX, ARY), AStyle);
end;

procedure TBLContext.FillEllipse(const ACX, ACY, ARX, ARY: Double;
  const AStyle: TBLRgba);
begin
  FillEllipse(BLEllipse(ACX, ACY, ARX, ARY), AStyle);
end;

procedure TBLContext.FillEllipse(const ACX, ACY, ARX, ARY: Double);
begin
  FillEllipse(BLEllipse(ACX, ACY, ARX, ARY));
end;

procedure TBLContext.FillEllipse(const ACX, ACY, ARX, ARY: Double;
  const AStyle: TBLVar);
begin
  FillEllipse(BLEllipse(ACX, ACY, ARX, ARY), AStyle);
end;

procedure TBLContext.FillEllipse(const ACX, ACY, ARX, ARY: Double;
  const AStyle: TBLGradient);
begin
  FillEllipse(BLEllipse(ACX, ACY, ARX, ARY), AStyle);
end;

procedure TBLContext.FillEllipse(const ACX, ACY, ARX, ARY: Double;
  const AStyle: TBLPattern);
begin
  FillEllipse(BLEllipse(ACX, ACY, ARX, ARY), AStyle);
end;

procedure TBLContext.FillEllipse(const ACX, ACY, ARX, ARY: Double;
  const AStyle: TAlphaColor);
begin
  FillEllipse(BLEllipse(ACX, ACY, ARX, ARY), AStyle);
end;

procedure TBLContext.FillGeometry(const AType: TBLGeometryType;
  const AData: Pointer; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillGeometryRgba64(@Self, Ord(AType), AData, AStyle.Value));
end;

procedure TBLContext.FillGeometry(const AType: TBLGeometryType;
  const AData: Pointer; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(AType), AData, AStyle.Value));
end;

procedure TBLContext.FillGeometry(const AType: TBLGeometryType;
  const AData: Pointer; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(AType), AData, @Style));
end;

procedure TBLContext.FillGeometry(const AType: TBLGeometryType;
  const AData: Pointer);
begin
  _BLCheck(_blContextFillGeometry(@Self, Ord(AType), AData));
end;

procedure TBLContext.FillGeometry(const AType: TBLGeometryType;
  const AData: Pointer; const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(AType), AData, @AStyle));
end;

procedure TBLContext.FillGeometry(const AType: TBLGeometryType;
  const AData: Pointer; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(AType), AData, @AStyle));
end;

procedure TBLContext.FillGeometry(const AType: TBLGeometryType;
  const AData: Pointer; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(AType), AData, @AStyle));
end;

procedure TBLContext.FillGeometry(const AType: TBLGeometryType;
  const AData: Pointer; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(AType), AData, AStyle));
end;

procedure TBLContext.FillGlyphRun(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillGlyphRunIRgba64(@Self, @AOrigin, @AFont, @AGlyphRun, AStyle.Value));
end;

procedure TBLContext.FillGlyphRun(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillGlyphRunIRgba32(@Self, @AOrigin, @AFont, @AGlyphRun, AStyle.Value));
end;

procedure TBLContext.FillGlyphRun(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillGlyphRunIExt(@Self, @AOrigin, @AFont, @AGlyphRun, @Style));
end;

procedure TBLContext.FillGlyphRun(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun);
begin
  _BLCheck(_blContextFillGlyphRunI(@Self, @AOrigin, @AFont, @AGlyphRun));
end;

procedure TBLContext.FillGlyphRun(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun; const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillGlyphRunIExt(@Self, @AOrigin, @AFont, @AGlyphRun, @AStyle));
end;

procedure TBLContext.FillGlyphRun(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillGlyphRunIExt(@Self, @AOrigin, @AFont, @AGlyphRun, @AStyle));
end;

procedure TBLContext.FillGlyphRun(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillGlyphRunIExt(@Self, @AOrigin, @AFont, @AGlyphRun, @AStyle));
end;

procedure TBLContext.FillGlyphRun(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillGlyphRunIRgba32(@Self, @AOrigin, @AFont, @AGlyphRun, AStyle));
end;

procedure TBLContext.FillGlyphRun(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillGlyphRunDRgba64(@Self, @AOrigin, @AFont, @AGlyphRun, AStyle.Value));
end;

procedure TBLContext.FillGlyphRun(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillGlyphRunDRgba32(@Self, @AOrigin, @AFont, @AGlyphRun, AStyle.Value));
end;

procedure TBLContext.FillGlyphRun(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillGlyphRunDExt(@Self, @AOrigin, @AFont, @AGlyphRun, @Style));
end;

procedure TBLContext.FillGlyphRun(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun);
begin
  _BLCheck(_blContextFillGlyphRunD(@Self, @AOrigin, @AFont, @AGlyphRun));
end;

procedure TBLContext.FillGlyphRun(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun; const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillGlyphRunDExt(@Self, @AOrigin, @AFont, @AGlyphRun, @AStyle));
end;

procedure TBLContext.FillGlyphRun(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillGlyphRunDExt(@Self, @AOrigin, @AFont, @AGlyphRun, @AStyle));
end;

procedure TBLContext.FillGlyphRun(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillGlyphRunDExt(@Self, @AOrigin, @AFont, @AGlyphRun, @AStyle));
end;

procedure TBLContext.FillGlyphRun(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillGlyphRunDRgba32(@Self, @AOrigin, @AFont, @AGlyphRun, AStyle));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPointI; const AMask: TBLImage;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillMaskIRgba64(@Self, @AOrigin, @AMask, nil, AStyle.Value));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPointI; const AMask: TBLImage;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillMaskIRgba32(@Self, @AOrigin, @AMask, nil, AStyle.Value));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPointI; const AMask: TBLImage;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillMaskIExt(@Self, @AOrigin, @AMask, nil, @Style));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPointI; const AMask: TBLImage);
begin
  _BLCheck(_blContextFillMaskI(@Self, @AOrigin, @AMask, nil));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPointI; const AMask: TBLImage;
  const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillMaskIExt(@Self, @AOrigin, @AMask, nil, @AStyle));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPointI; const AMask: TBLImage;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillMaskIExt(@Self, @AOrigin, @AMask, nil, @AStyle));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPointI; const AMask: TBLImage;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillMaskIExt(@Self, @AOrigin, @AMask, nil, @AStyle));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPointI; const AMask: TBLImage;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillMaskIRgba32(@Self, @AOrigin, @AMask, nil, AStyle));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPointI; const AMask,
  AMaskArea: TBLImage; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillMaskIRgba64(@Self, @AOrigin, @AMask, @AMaskArea, AStyle.Value));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPointI; const AMask,
  AMaskArea: TBLImage; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillMaskIRgba32(@Self, @AOrigin, @AMask, @AMaskArea, AStyle.Value));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPointI; const AMask,
  AMaskArea: TBLImage; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillMaskIExt(@Self, @AOrigin, @AMask, @AMaskArea, @Style));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPointI; const AMask,
  AMaskArea: TBLImage);
begin
  _BLCheck(_blContextFillMaskI(@Self, @AOrigin, @AMask, @AMaskArea));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPointI; const AMask,
  AMaskArea: TBLImage; const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillMaskIExt(@Self, @AOrigin, @AMask, @AMaskArea, @AStyle));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPointI; const AMask,
  AMaskArea: TBLImage; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillMaskIExt(@Self, @AOrigin, @AMask, @AMaskArea, @AStyle));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPointI; const AMask,
  AMaskArea: TBLImage; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillMaskIExt(@Self, @AOrigin, @AMask, @AMaskArea, @AStyle));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPointI; const AMask,
  AMaskArea: TBLImage; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillMaskIRgba32(@Self, @AOrigin, @AMask, @AMaskArea, AStyle));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPoint; const AMask: TBLImage;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillMaskDRgba64(@Self, @AOrigin, @AMask, nil, AStyle.Value));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPoint; const AMask: TBLImage;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillMaskDRgba32(@Self, @AOrigin, @AMask, nil, AStyle.Value));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPoint; const AMask: TBLImage;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillMaskDExt(@Self, @AOrigin, @AMask, nil, @Style));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPoint; const AMask: TBLImage);
begin
  _BLCheck(_blContextFillMaskD(@Self, @AOrigin, @AMask, nil));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPoint; const AMask: TBLImage;
  const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillMaskDExt(@Self, @AOrigin, @AMask, nil, @AStyle));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPoint; const AMask: TBLImage;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillMaskDExt(@Self, @AOrigin, @AMask, nil, @AStyle));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPoint; const AMask: TBLImage;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillMaskDExt(@Self, @AOrigin, @AMask, nil, @AStyle));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPoint; const AMask: TBLImage;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillMaskDRgba32(@Self, @AOrigin, @AMask, nil, AStyle));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPoint; const AMask,
  AMaskArea: TBLImage; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillMaskDRgba64(@Self, @AOrigin, @AMask, @AMaskArea, AStyle.Value));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPoint; const AMask,
  AMaskArea: TBLImage; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillMaskDRgba32(@Self, @AOrigin, @AMask, @AMaskArea, AStyle.Value));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPoint; const AMask,
  AMaskArea: TBLImage; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillMaskDExt(@Self, @AOrigin, @AMask, @AMaskArea, @Style));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPoint; const AMask,
  AMaskArea: TBLImage);
begin
  _BLCheck(_blContextFillMaskD(@Self, @AOrigin, @AMask, @AMaskArea));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPoint; const AMask,
  AMaskArea: TBLImage; const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillMaskDExt(@Self, @AOrigin, @AMask, @AMaskArea, @AStyle));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPoint; const AMask,
  AMaskArea: TBLImage; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillMaskDExt(@Self, @AOrigin, @AMask, @AMaskArea, @AStyle));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPoint; const AMask,
  AMaskArea: TBLImage; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillMaskDExt(@Self, @AOrigin, @AMask, @AMaskArea, @AStyle));
end;

procedure TBLContext.FillMask(const AOrigin: TBLPoint; const AMask,
  AMaskArea: TBLImage; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillMaskDRgba32(@Self, @AOrigin, @AMask, @AMaskArea, AStyle));
end;

procedure TBLContext.FillPath(const APath: TBLPath; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillPathDRgba32(@Self, @TBLPoint.Empty, @APath, AStyle.Value));
end;

procedure TBLContext.FillPath(const APath: TBLPath; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillPathDRgba64(@Self, @TBLPoint.Empty, @APath, AStyle.Value));
end;

procedure TBLContext.FillPath(const APath: TBLPath; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillPathDExt(@Self, @TBLPoint.Empty, @APath, @Style));
end;

procedure TBLContext.FillPath(const APath: TBLPath);
begin
  _BLCheck(_blContextFillPathD(@Self, @TBLPoint.Empty, @APath));
end;

procedure TBLContext.FillPath(const APath: TBLPath; const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillPathDExt(@Self, @TBLPoint.Empty, @APath, @AStyle));
end;

procedure TBLContext.FillPath(const APath: TBLPath; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillPathDExt(@Self, @TBLPoint.Empty, @APath, @AStyle));
end;

procedure TBLContext.FillPath(const APath: TBLPath; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillPathDExt(@Self, @TBLPoint.Empty, @APath, @AStyle));
end;

procedure TBLContext.FillPath(const APath: TBLPath; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillPathDRgba32(@Self, @TBLPoint.Empty, @APath, AStyle));
end;

procedure TBLContext.FillPath(const AOrigin: TBLPoint; const APath: TBLPath;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillPathDRgba64(@Self, @AOrigin, @APath, AStyle));
end;

procedure TBLContext.FillPath(const AOrigin: TBLPoint; const APath: TBLPath;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillPathDRgba32(@Self, @AOrigin, @APath, AStyle));
end;

procedure TBLContext.FillPath(const AOrigin: TBLPoint; const APath: TBLPath;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillPathDExt(@Self, @AOrigin, @APath, @Style));
end;

procedure TBLContext.FillPath(const AOrigin: TBLPoint; const APath: TBLPath);
begin
  _BLCheck(_blContextFillPathD(@Self, @AOrigin, @APath));
end;

procedure TBLContext.FillPath(const AOrigin: TBLPoint; const APath: TBLPath;
  const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillPathDExt(@Self, @AOrigin, @APath, @AStyle));
end;

procedure TBLContext.FillPath(const AOrigin: TBLPoint; const APath: TBLPath;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillPathDExt(@Self, @AOrigin, @APath, @AStyle));
end;

procedure TBLContext.FillPath(const AOrigin: TBLPoint; const APath: TBLPath;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillPathDExt(@Self, @AOrigin, @APath, @AStyle));
end;

procedure TBLContext.FillPath(const AOrigin: TBLPoint; const APath: TBLPath;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillPathDRgba32(@Self, @AOrigin, @APath, AStyle));
end;

procedure TBLContext.FillPie(const APie: TBLArc; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillGeometryRgba64(@Self, Ord(TBLGeometryType.Pie), @APie, AStyle.Value));
end;

procedure TBLContext.FillPie(const APie: TBLArc; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.Pie), @APie, AStyle.Value));
end;

procedure TBLContext.FillPie(const APie: TBLArc; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.Pie), @APie, @Style));
end;

procedure TBLContext.FillPie(const APie: TBLArc);
begin
  _BLCheck(_blContextFillGeometry(@Self, Ord(TBLGeometryType.Pie), @APie));
end;

procedure TBLContext.FillPie(const APie: TBLArc; const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.Pie), @APie, @AStyle));
end;

procedure TBLContext.FillPie(const APie: TBLArc; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.Pie), @APie, @AStyle));
end;

procedure TBLContext.FillPie(const APie: TBLArc; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.Pie), @APie, @AStyle));
end;

procedure TBLContext.FillPie(const APie: TBLArc; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.Pie), @APie, AStyle));
end;

procedure TBLContext.FillPie(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLRgba64);
begin
  FillPie(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillPie(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLRgba32);
begin
  FillPie(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillPie(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLRgba);
begin
  FillPie(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillPie(const ACX, ACY, AR, AStart, ASweep: Double);
begin
  FillPie(BLArc(ACX, ACY, AR, AR, AStart, ASweep));
end;

procedure TBLContext.FillPie(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLVar);
begin
  FillPie(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillPie(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLGradient);
begin
  FillPie(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillPie(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLPattern);
begin
  FillPie(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillPie(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TAlphaColor);
begin
  FillPie(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillPie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLRgba64);
begin
  FillPie(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillPie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLRgba32);
begin
  FillPie(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillPie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLRgba);
begin
  FillPie(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillPie(const ACX, ACY, ARX, ARY, AStart,
  ASweep: Double);
begin
  FillPie(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep));
end;

procedure TBLContext.FillPie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLVar);
begin
  FillPie(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillPie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLGradient);
begin
  FillPie(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillPie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLPattern);
begin
  FillPie(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillPie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TAlphaColor);
begin
  FillPie(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: TBLArrayView<TBLPoint>;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillGeometryRgba64(@Self, Ord(TBLGeometryType.PolygonD), @APoly, AStyle.Value));
end;

procedure TBLContext.FillPolygon(const APoly: TBLArrayView<TBLPoint>;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.PolygonD), @APoly, AStyle.Value));
end;

procedure TBLContext.FillPolygon(const APoly: TBLArrayView<TBLPoint>;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.PolygonD), @APoly, @Style));
end;

procedure TBLContext.FillPolygon(const APoly: TBLArrayView<TBLPoint>);
begin
  _BLCheck(_blContextFillGeometry(@Self, Ord(TBLGeometryType.PolygonD), @APoly));
end;

procedure TBLContext.FillPolygon(const APoly: TBLArrayView<TBLPoint>;
  const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.PolygonD), @APoly, @AStyle));
end;

procedure TBLContext.FillPolygon(const APoly: TBLArrayView<TBLPoint>;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.PolygonD), @APoly, @AStyle));
end;

procedure TBLContext.FillPolygon(const APoly: TBLArrayView<TBLPoint>;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.PolygonD), @APoly, @AStyle));
end;

procedure TBLContext.FillPolygon(const APoly: TBLArrayView<TBLPoint>;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.PolygonD), @APoly, AStyle));
end;

procedure TBLContext.FillPolygon(const APoly: TArray<TBLPoint>;
  const AStyle: TBLRgba64);
begin
  FillPolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: TArray<TBLPoint>;
  const AStyle: TBLRgba32);
begin
  FillPolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: TArray<TBLPoint>;
  const AStyle: TBLRgba);
begin
  FillPolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: TArray<TBLPoint>);
begin
  FillPolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), Length(APoly)));
end;

procedure TBLContext.FillPolygon(const APoly: TArray<TBLPoint>;
  const AStyle: TBLVar);
begin
  FillPolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: TArray<TBLPoint>;
  const AStyle: TBLGradient);
begin
  FillPolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: TArray<TBLPoint>;
  const AStyle: TBLPattern);
begin
  FillPolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: TArray<TBLPoint>;
  const AStyle: TAlphaColor);
begin
  FillPolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: PBLPoint; const ACount: NativeInt;
  const AStyle: TBLRgba64);
begin
  FillPolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: PBLPoint; const ACount: NativeInt;
  const AStyle: TBLRgba32);
begin
  FillPolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: PBLPoint; const ACount: NativeInt;
  const AStyle: TBLRgba);
begin
  FillPolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: PBLPoint; const ACount: NativeInt);
begin
  FillPolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), ACount));
end;

procedure TBLContext.FillPolygon(const APoly: PBLPoint; const ACount: NativeInt;
  const AStyle: TBLVar);
begin
  FillPolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: PBLPoint; const ACount: NativeInt;
  const AStyle: TBLGradient);
begin
  FillPolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: PBLPoint; const ACount: NativeInt;
  const AStyle: TBLPattern);
begin
  FillPolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: PBLPoint; const ACount: NativeInt;
  const AStyle: TAlphaColor);
begin
  FillPolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: TBLArrayView<TBLPointI>;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillGeometryRgba64(@Self, Ord(TBLGeometryType.PolygonI), @APoly, AStyle.Value));
end;

procedure TBLContext.FillPolygon(const APoly: TBLArrayView<TBLPointI>;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.PolygonI), @APoly, AStyle.Value));
end;

procedure TBLContext.FillPolygon(const APoly: TBLArrayView<TBLPointI>;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.PolygonI), @APoly, @Style));
end;

procedure TBLContext.FillPolygon(const APoly: TBLArrayView<TBLPointI>);
begin
  _BLCheck(_blContextFillGeometry(@Self, Ord(TBLGeometryType.PolygonI), @APoly));
end;

procedure TBLContext.FillPolygon(const APoly: TBLArrayView<TBLPointI>;
  const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.PolygonI), @APoly, @AStyle));
end;

procedure TBLContext.FillPolygon(const APoly: TBLArrayView<TBLPointI>;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.PolygonI), @APoly, @AStyle));
end;

procedure TBLContext.FillPolygon(const APoly: TBLArrayView<TBLPointI>;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.PolygonI), @APoly, @AStyle));
end;

procedure TBLContext.FillPolygon(const APoly: TBLArrayView<TBLPointI>;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.PolygonI), @APoly, AStyle));
end;

procedure TBLContext.FillPolygon(const APoly: TArray<TBLPointI>;
  const AStyle: TBLRgba64);
begin
  FillPolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: TArray<TBLPointI>;
  const AStyle: TBLRgba32);
begin
  FillPolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: TArray<TBLPointI>;
  const AStyle: TBLRgba);
begin
  FillPolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: TArray<TBLPointI>);
begin
  FillPolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), Length(APoly)));
end;

procedure TBLContext.FillPolygon(const APoly: TArray<TBLPointI>;
  const AStyle: TBLVar);
begin
  FillPolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: TArray<TBLPointI>;
  const AStyle: TBLGradient);
begin
  FillPolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: TArray<TBLPointI>;
  const AStyle: TBLPattern);
begin
  FillPolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: TArray<TBLPointI>;
  const AStyle: TAlphaColor);
begin
  FillPolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: PBLPointI; const ACount: NativeInt;
  const AStyle: TBLRgba64);
begin
  FillPolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: PBLPointI; const ACount: NativeInt;
  const AStyle: TBLRgba32);
begin
  FillPolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: PBLPointI; const ACount: NativeInt;
  const AStyle: TBLRgba);
begin
  FillPolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: PBLPointI; const ACount: NativeInt);
begin
  FillPolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), ACount));
end;

procedure TBLContext.FillPolygon(const APoly: PBLPointI; const ACount: NativeInt;
  const AStyle: TBLVar);
begin
  FillPolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: PBLPointI; const ACount: NativeInt;
  const AStyle: TBLGradient);
begin
  FillPolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: PBLPointI; const ACount: NativeInt;
  const AStyle: TBLPattern);
begin
  FillPolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.FillPolygon(const APoly: PBLPointI; const ACount: NativeInt;
  const AStyle: TAlphaColor);
begin
  FillPolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.FillRect(const ARect: TBLRectI; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillRectIRgba64(@Self, @ARect, AStyle.Value));
end;

procedure TBLContext.FillRect(const ARect: TBLRectI; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillRectIRgba32(@Self, @ARect, AStyle.Value));
end;

procedure TBLContext.FillRect(const ARect: TBLRectI; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillRectIExt(@Self, @ARect, @Style));
end;

procedure TBLContext.FillRect(const ARect: TBLRectI);
begin
  _BLCheck(_blContextFillRectI(@Self, @ARect));
end;

procedure TBLContext.FillRect(const ARect: TBLRectI; const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillRectIExt(@Self, @ARect, @AStyle));
end;

procedure TBLContext.FillRect(const ARect: TBLRectI; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillRectIExt(@Self, @ARect, @AStyle));
end;

procedure TBLContext.FillRect(const ARect: TBLRectI; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillRectIExt(@Self, @ARect, @AStyle));
end;

procedure TBLContext.FillRect(const ARect: TBLRectI; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillRectIRgba32(@Self, @ARect, AStyle));
end;

procedure TBLContext.FillRect(const ARect: TBLRect; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillRectDRgba64(@Self, @ARect, AStyle.Value));
end;

procedure TBLContext.FillRect(const ARect: TBLRect; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillRectDRgba32(@Self, @ARect, AStyle.Value));
end;

procedure TBLContext.FillRect(const ARect: TBLRect; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillRectDExt(@Self, @ARect, @Style));
end;

procedure TBLContext.FillRect(const ARect: TBLRect);
begin
  _BLCheck(_blContextFillRectD(@Self, @ARect));
end;

procedure TBLContext.FillRect(const ARect: TBLRect; const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillRectDExt(@Self, @ARect, @AStyle));
end;

procedure TBLContext.FillRect(const ARect: TBLRect; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillRectDExt(@Self, @ARect, @AStyle));
end;

procedure TBLContext.FillRect(const ARect: TBLRect; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillRectDExt(@Self, @ARect, @AStyle));
end;

procedure TBLContext.FillRect(const ARect: TBLRect; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillRectDRgba32(@Self, @ARect, AStyle));
end;

procedure TBLContext.FillRect(const AX, AY, AW, AH: Double;
  const AStyle: TBLRgba64);
begin
  FillRect(BLRect(AX, AY, AW, AH), AStyle);
end;

procedure TBLContext.FillRect(const AX, AY, AW, AH: Double;
  const AStyle: TBLRgba32);
begin
  FillRect(BLRect(AX, AY, AW, AH), AStyle);
end;

procedure TBLContext.FillRect(const AX, AY, AW, AH: Double;
  const AStyle: TBLRgba);
begin
  FillRect(BLRect(AX, AY, AW, AH), AStyle);
end;

procedure TBLContext.FillRect(const AX, AY, AW, AH: Double);
begin
  FillRect(BLRect(AX, AY, AW, AH));
end;

procedure TBLContext.FillRect(const AX, AY, AW, AH: Double;
  const AStyle: TBLVar);
begin
  FillRect(BLRect(AX, AY, AW, AH), AStyle);
end;

procedure TBLContext.FillRect(const AX, AY, AW, AH: Double;
  const AStyle: TBLGradient);
begin
  FillRect(BLRect(AX, AY, AW, AH), AStyle);
end;

procedure TBLContext.FillRect(const AX, AY, AW, AH: Double;
  const AStyle: TBLPattern);
begin
  FillRect(BLRect(AX, AY, AW, AH), AStyle);
end;

procedure TBLContext.FillRect(const AX, AY, AW, AH: Double;
  const AStyle: TAlphaColor);
begin
  FillRect(BLRect(AX, AY, AW, AH), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: TBLArrayView<TBLRect>;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillGeometryRgba64(@Self, Ord(TBLGeometryType.ArrayViewRectD), @AArray, AStyle.Value));
end;

procedure TBLContext.FillRectArray(const AArray: TBLArrayView<TBLRect>;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.ArrayViewRectD), @AArray, AStyle.Value));
end;

procedure TBLContext.FillRectArray(const AArray: TBLArrayView<TBLRect>;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewRectD), @AArray, @Style));
end;

procedure TBLContext.FillRectArray(const AArray: TBLArrayView<TBLRect>);
begin
  _BLCheck(_blContextFillGeometry(@Self, Ord(TBLGeometryType.ArrayViewRectD), @AArray));
end;

procedure TBLContext.FillRectArray(const AArray: TBLArrayView<TBLRect>;
  const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewRectD), @AArray, @AStyle));
end;

procedure TBLContext.FillRectArray(const AArray: TBLArrayView<TBLRect>;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewRectD), @AArray, @AStyle));
end;

procedure TBLContext.FillRectArray(const AArray: TBLArrayView<TBLRect>;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewRectD), @AArray, @AStyle));
end;

procedure TBLContext.FillRectArray(const AArray: TBLArrayView<TBLRect>;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.ArrayViewRectD), @AArray, AStyle));
end;

procedure TBLContext.FillRectArray(const AArray: TArray<TBLRect>;
  const AStyle: TBLRgba64);
begin
  FillRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: TArray<TBLRect>;
  const AStyle: TBLRgba32);
begin
  FillRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: TArray<TBLRect>;
  const AStyle: TBLRgba);
begin
  FillRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: TArray<TBLRect>);
begin
  FillRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), Length(AArray)));
end;

procedure TBLContext.FillRectArray(const AArray: TArray<TBLRect>;
  const AStyle: TBLVar);
begin
  FillRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: TArray<TBLRect>;
  const AStyle: TBLGradient);
begin
  FillRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: TArray<TBLRect>;
  const AStyle: TBLPattern);
begin
  FillRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: TArray<TBLRect>;
  const AStyle: TAlphaColor);
begin
  FillRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: PBLRect; const ACount: NativeInt;
  const AStyle: TBLRgba64);
begin
  FillRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: PBLRect; const ACount: NativeInt;
  const AStyle: TBLRgba32);
begin
  FillRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: PBLRect; const ACount: NativeInt;
  const AStyle: TBLRgba);
begin
  FillRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: PBLRect;
  const ACount: NativeInt);
begin
  FillRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), ACount));
end;

procedure TBLContext.FillRectArray(const AArray: PBLRect; const ACount: NativeInt;
  const AStyle: TBLVar);
begin
  FillRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: PBLRect; const ACount: NativeInt;
  const AStyle: TBLGradient);
begin
  FillRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: PBLRect; const ACount: NativeInt;
  const AStyle: TBLPattern);
begin
  FillRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: PBLRect; const ACount: NativeInt;
  const AStyle: TAlphaColor);
begin
  FillRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: TBLArrayView<TBLRectI>;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillGeometryRgba64(@Self, Ord(TBLGeometryType.ArrayViewRectI), @AArray, AStyle.Value));
end;

procedure TBLContext.FillRectArray(const AArray: TBLArrayView<TBLRectI>;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.ArrayViewRectI), @AArray, AStyle.Value));
end;

procedure TBLContext.FillRectArray(const AArray: TBLArrayView<TBLRectI>;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewRectI), @AArray, @Style));
end;

procedure TBLContext.FillRectArray(const AArray: TBLArrayView<TBLRectI>);
begin
  _BLCheck(_blContextFillGeometry(@Self, Ord(TBLGeometryType.ArrayViewRectI), @AArray));
end;

procedure TBLContext.FillRectArray(const AArray: TBLArrayView<TBLRectI>;
  const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewRectI), @AArray, @AStyle));
end;

procedure TBLContext.FillRectArray(const AArray: TBLArrayView<TBLRectI>;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewRectI), @AArray, @AStyle));
end;

procedure TBLContext.FillRectArray(const AArray: TBLArrayView<TBLRectI>;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewRectI), @AArray, @AStyle));
end;

procedure TBLContext.FillRectArray(const AArray: TBLArrayView<TBLRectI>;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.ArrayViewRectI), @AArray, AStyle));
end;

procedure TBLContext.FillRectArray(const AArray: TArray<TBLRectI>;
  const AStyle: TBLRgba64);
begin
  FillRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: TArray<TBLRectI>;
  const AStyle: TBLRgba32);
begin
  FillRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: TArray<TBLRectI>;
  const AStyle: TBLRgba);
begin
  FillRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: TArray<TBLRectI>);
begin
  FillRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), Length(AArray)));
end;

procedure TBLContext.FillRectArray(const AArray: TArray<TBLRectI>;
  const AStyle: TBLVar);
begin
  FillRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: TArray<TBLRectI>;
  const AStyle: TBLGradient);
begin
  FillRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: TArray<TBLRectI>;
  const AStyle: TBLPattern);
begin
  FillRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: TArray<TBLRectI>;
  const AStyle: TAlphaColor);
begin
  FillRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: PBLRectI; const ACount: NativeInt;
  const AStyle: TBLRgba64);
begin
  FillRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: PBLRectI; const ACount: NativeInt;
  const AStyle: TBLRgba32);
begin
  FillRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: PBLRectI; const ACount: NativeInt;
  const AStyle: TBLRgba);
begin
  FillRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: PBLRectI;
  const ACount: NativeInt);
begin
  FillRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), ACount));
end;

procedure TBLContext.FillRectArray(const AArray: PBLRectI; const ACount: NativeInt;
  const AStyle: TBLVar);
begin
  FillRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: PBLRectI; const ACount: NativeInt;
  const AStyle: TBLGradient);
begin
  FillRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: PBLRectI; const ACount: NativeInt;
  const AStyle: TBLPattern);
begin
  FillRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillRectArray(const AArray: PBLRectI; const ACount: NativeInt;
  const AStyle: TAlphaColor);
begin
  FillRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.FillRoundRect(const ARR: TBLRoundRect;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillGeometryRgba64(@Self, Ord(TBLGeometryType.RoundRect), @ARR, AStyle.Value));
end;

procedure TBLContext.FillRoundRect(const ARR: TBLRoundRect;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.RoundRect), @ARR, AStyle.Value));
end;

procedure TBLContext.FillRoundRect(const ARR: TBLRoundRect;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.RoundRect), @ARR, @Style));
end;

procedure TBLContext.FillRoundRect(const ARR: TBLRoundRect);
begin
  _BLCheck(_blContextFillGeometry(@Self, Ord(TBLGeometryType.RoundRect), @ARR));
end;

procedure TBLContext.FillRoundRect(const ARR: TBLRoundRect;
  const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.RoundRect), @ARR, @AStyle));
end;

procedure TBLContext.FillRoundRect(const ARR: TBLRoundRect;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.RoundRect), @ARR, @AStyle));
end;

procedure TBLContext.FillRoundRect(const ARR: TBLRoundRect;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.RoundRect), @ARR, @AStyle));
end;

procedure TBLContext.FillRoundRect(const ARR: TBLRoundRect;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.RoundRect), @ARR, AStyle));
end;

procedure TBLContext.FillRoundRect(const ARect: TBLRect; const AR: Double;
  const AStyle: TBLRgba64);
begin
  FillRoundRect(BLRoundRect(ARect, AR), AStyle);
end;

procedure TBLContext.FillRoundRect(const ARect: TBLRect; const AR: Double;
  const AStyle: TBLRgba32);
begin
  FillRoundRect(BLRoundRect(ARect, AR), AStyle);
end;

procedure TBLContext.FillRoundRect(const ARect: TBLRect; const AR: Double;
  const AStyle: TBLRgba);
begin
  FillRoundRect(BLRoundRect(ARect, AR), AStyle);
end;

procedure TBLContext.FillRoundRect(const ARect: TBLRect; const AR: Double);
begin
  FillRoundRect(BLRoundRect(ARect, AR));
end;

procedure TBLContext.FillRoundRect(const ARect: TBLRect; const AR: Double;
  const AStyle: TBLVar);
begin
  FillRoundRect(BLRoundRect(ARect, AR), AStyle);
end;

procedure TBLContext.FillRoundRect(const ARect: TBLRect; const AR: Double;
  const AStyle: TBLGradient);
begin
  FillRoundRect(BLRoundRect(ARect, AR), AStyle);
end;

procedure TBLContext.FillRoundRect(const ARect: TBLRect; const AR: Double;
  const AStyle: TBLPattern);
begin
  FillRoundRect(BLRoundRect(ARect, AR), AStyle);
end;

procedure TBLContext.FillRoundRect(const ARect: TBLRect; const AR: Double;
  const AStyle: TAlphaColor);
begin
  FillRoundRect(BLRoundRect(ARect, AR), AStyle);
end;

procedure TBLContext.FillRoundRect(const ARect: TBLRect; const ARX, ARY: Double;
  const AStyle: TBLRgba64);
begin
  FillRoundRect(BLRoundRect(ARect, ARX, ARY), AStyle);
end;

procedure TBLContext.FillRoundRect(const ARect: TBLRect; const ARX, ARY: Double;
  const AStyle: TBLRgba32);
begin
  FillRoundRect(BLRoundRect(ARect, ARX, ARY), AStyle);
end;

procedure TBLContext.FillRoundRect(const ARect: TBLRect; const ARX, ARY: Double;
  const AStyle: TBLRgba);
begin
  FillRoundRect(BLRoundRect(ARect, ARX, ARY), AStyle);
end;

procedure TBLContext.FillRoundRect(const ARect: TBLRect; const ARX,
  ARY: Double);
begin
  FillRoundRect(BLRoundRect(ARect, ARX, ARY));
end;

procedure TBLContext.FillRoundRect(const ARect: TBLRect; const ARX, ARY: Double;
  const AStyle: TBLVar);
begin
  FillRoundRect(BLRoundRect(ARect, ARX, ARY), AStyle);
end;

procedure TBLContext.FillRoundRect(const ARect: TBLRect; const ARX, ARY: Double;
  const AStyle: TBLGradient);
begin
  FillRoundRect(BLRoundRect(ARect, ARX, ARY), AStyle);
end;

procedure TBLContext.FillRoundRect(const ARect: TBLRect; const ARX, ARY: Double;
  const AStyle: TBLPattern);
begin
  FillRoundRect(BLRoundRect(ARect, ARX, ARY), AStyle);
end;

procedure TBLContext.FillRoundRect(const ARect: TBLRect; const ARX, ARY: Double;
  const AStyle: TAlphaColor);
begin
  FillRoundRect(BLRoundRect(ARect, ARX, ARY), AStyle);
end;

procedure TBLContext.FillRoundRect(const AX, AY, AW, AH, AR: Double;
  const AStyle: TBLRgba64);
begin
  FillRoundRect(BLRoundRect(AX, AY, AW, AH, AR), AStyle);
end;

procedure TBLContext.FillRoundRect(const AX, AY, AW, AH, AR: Double;
  const AStyle: TBLRgba32);
begin
  FillRoundRect(BLRoundRect(AX, AY, AW, AH, AR), AStyle);
end;

procedure TBLContext.FillRoundRect(const AX, AY, AW, AH, AR: Double;
  const AStyle: TBLRgba);
begin
  FillRoundRect(BLRoundRect(AX, AY, AW, AH, AR), AStyle);
end;

procedure TBLContext.FillRoundRect(const AX, AY, AW, AH, AR: Double);
begin
  FillRoundRect(BLRoundRect(AX, AY, AW, AH, AR));
end;

procedure TBLContext.FillRoundRect(const AX, AY, AW, AH, AR: Double;
  const AStyle: TBLVar);
begin
  FillRoundRect(BLRoundRect(AX, AY, AW, AH, AR), AStyle);
end;

procedure TBLContext.FillRoundRect(const AX, AY, AW, AH, AR: Double;
  const AStyle: TBLGradient);
begin
  FillRoundRect(BLRoundRect(AX, AY, AW, AH, AR), AStyle);
end;

procedure TBLContext.FillRoundRect(const AX, AY, AW, AH, AR: Double;
  const AStyle: TBLPattern);
begin
  FillRoundRect(BLRoundRect(AX, AY, AW, AH, AR), AStyle);
end;

procedure TBLContext.FillRoundRect(const AX, AY, AW, AH, AR: Double;
  const AStyle: TAlphaColor);
begin
  FillRoundRect(BLRoundRect(AX, AY, AW, AH, AR), AStyle);
end;

procedure TBLContext.FillRoundRect(const AX, AY, AW, AH, ARX, ARY: Double;
  const AStyle: TBLRgba64);
begin
  FillRoundRect(BLRoundRect(AX, AY, AW, AH, ARX, ARY), AStyle);
end;

procedure TBLContext.FillRoundRect(const AX, AY, AW, AH, ARX, ARY: Double;
  const AStyle: TBLRgba32);
begin
  FillRoundRect(BLRoundRect(AX, AY, AW, AH, ARX, ARY), AStyle);
end;

procedure TBLContext.FillRoundRect(const AX, AY, AW, AH, ARX, ARY: Double;
  const AStyle: TBLRgba);
begin
  FillRoundRect(BLRoundRect(AX, AY, AW, AH, ARX, ARY), AStyle);
end;

procedure TBLContext.FillRoundRect(const AX, AY, AW, AH, ARX, ARY: Double);
begin
  FillRoundRect(BLRoundRect(AX, AY, AW, AH, ARX, ARY));
end;

procedure TBLContext.FillRoundRect(const AX, AY, AW, AH, ARX, ARY: Double;
  const AStyle: TBLVar);
begin
  FillRoundRect(BLRoundRect(AX, AY, AW, AH, ARX, ARY), AStyle);
end;

procedure TBLContext.FillRoundRect(const AX, AY, AW, AH, ARX, ARY: Double;
  const AStyle: TBLGradient);
begin
  FillRoundRect(BLRoundRect(AX, AY, AW, AH, ARX, ARY), AStyle);
end;

procedure TBLContext.FillRoundRect(const AX, AY, AW, AH, ARX, ARY: Double;
  const AStyle: TBLPattern);
begin
  FillRoundRect(BLRoundRect(AX, AY, AW, AH, ARX, ARY), AStyle);
end;

procedure TBLContext.FillRoundRect(const AX, AY, AW, AH, ARX, ARY: Double;
  const AStyle: TAlphaColor);
begin
  FillRoundRect(BLRoundRect(AX, AY, AW, AH, ARX, ARY), AStyle);
end;

procedure TBLContext.FillText(const AOrigin: TBLPointI; const AFont: TBLFont;
  const AText: String; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillUtf16TextIRgba64(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), AStyle.Value));
end;

procedure TBLContext.FillText(const AOrigin: TBLPointI; const AFont: TBLFont;
  const AText: String; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillUtf16TextIRgba32(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), AStyle.Value));
end;

procedure TBLContext.FillText(const AOrigin: TBLPointI; const AFont: TBLFont;
  const AText: String; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillUtf16TextIExt(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), @Style));
end;

procedure TBLContext.FillText(const AOrigin: TBLPointI; const AFont: TBLFont;
  const AText: String);
begin
  _BLCheck(_blContextFillUtf16TextI(@Self, @AOrigin, @AFont, PChar(AText), Length(AText)));
end;

procedure TBLContext.FillText(const AOrigin: TBLPointI; const AFont: TBLFont;
  const AText: String; const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillUtf16TextIExt(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), @AStyle));
end;

procedure TBLContext.FillText(const AOrigin: TBLPointI; const AFont: TBLFont;
  const AText: String; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillUtf16TextIExt(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), @AStyle));
end;

procedure TBLContext.FillText(const AOrigin: TBLPointI; const AFont: TBLFont;
  const AText: String; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillUtf16TextIExt(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), @AStyle));
end;

procedure TBLContext.FillText(const AOrigin: TBLPointI; const AFont: TBLFont;
  const AText: String; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillUtf16TextIRgba32(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), AStyle));
end;

procedure TBLContext.FillText(const AOrigin: TBLPoint; const AFont: TBLFont;
  const AText: String; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillUtf16TextDRgba64(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), AStyle.Value));
end;

procedure TBLContext.FillText(const AOrigin: TBLPoint; const AFont: TBLFont;
  const AText: String; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillUtf16TextDRgba32(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), AStyle.Value));
end;

procedure TBLContext.FillText(const AOrigin: TBLPoint; const AFont: TBLFont;
  const AText: String; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillUtf16TextDExt(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), @Style));
end;

procedure TBLContext.FillText(const AOrigin: TBLPoint; const AFont: TBLFont;
  const AText: String);
begin
  _BLCheck(_blContextFillUtf16TextD(@Self, @AOrigin, @AFont, PChar(AText), Length(AText)));
end;

procedure TBLContext.FillText(const AOrigin: TBLPoint; const AFont: TBLFont;
  const AText: String; const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillUtf16TextDExt(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), @AStyle));
end;

procedure TBLContext.FillText(const AOrigin: TBLPoint; const AFont: TBLFont;
  const AText: String; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillUtf16TextDExt(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), @AStyle));
end;

procedure TBLContext.FillText(const AOrigin: TBLPoint; const AFont: TBLFont;
  const AText: String; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillUtf16TextDExt(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), @AStyle));
end;

procedure TBLContext.FillText(const AOrigin: TBLPoint; const AFont: TBLFont;
  const AText: String; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillUtf16TextDRgba32(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), AStyle));
end;

procedure TBLContext.FillTriangle(const ATriangle: TBLTriangle;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillGeometryRgba64(@Self, Ord(TBLGeometryType.Triangle), @ATriangle, AStyle.Value));
end;

procedure TBLContext.FillTriangle(const ATriangle: TBLTriangle;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.Triangle), @ATriangle, AStyle.Value));
end;

procedure TBLContext.FillTriangle(const ATriangle: TBLTriangle;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.Triangle), @ATriangle, @Style));
end;

procedure TBLContext.FillTriangle(const ATriangle: TBLTriangle);
begin
  _BLCheck(_blContextFillGeometry(@Self, Ord(TBLGeometryType.Triangle), @ATriangle));
end;

procedure TBLContext.FillTriangle(const ATriangle: TBLTriangle;
  const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.Triangle), @ATriangle, @AStyle));
end;

procedure TBLContext.FillTriangle(const ATriangle: TBLTriangle;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.Triangle), @ATriangle, @AStyle));
end;

procedure TBLContext.FillTriangle(const ATriangle: TBLTriangle;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillGeometryExt(@Self, Ord(TBLGeometryType.Triangle), @ATriangle, @AStyle));
end;

procedure TBLContext.FillTriangle(const ATriangle: TBLTriangle;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillGeometryRgba32(@Self, Ord(TBLGeometryType.Triangle), @ATriangle, AStyle));
end;

procedure TBLContext.FillTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double;
  const AStyle: TBLRgba64);
begin
  FillTriangle(BLTriangle(AX0, AY0, AX1, AY1, AX2, AY2), AStyle);
end;

procedure TBLContext.FillTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double;
  const AStyle: TBLRgba32);
begin
  FillTriangle(BLTriangle(AX0, AY0, AX1, AY1, AX2, AY2), AStyle);
end;

procedure TBLContext.FillTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double;
  const AStyle: TBLRgba);
begin
  FillTriangle(BLTriangle(AX0, AY0, AX1, AY1, AX2, AY2), AStyle);
end;

procedure TBLContext.FillTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double);
begin
  FillTriangle(BLTriangle(AX0, AY0, AX1, AY1, AX2, AY2));
end;

procedure TBLContext.FillTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double;
  const AStyle: TBLVar);
begin
  FillTriangle(BLTriangle(AX0, AY0, AX1, AY1, AX2, AY2), AStyle);
end;

procedure TBLContext.FillTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double;
  const AStyle: TBLGradient);
begin
  FillTriangle(BLTriangle(AX0, AY0, AX1, AY1, AX2, AY2), AStyle);
end;

procedure TBLContext.FillTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double;
  const AStyle: TBLPattern);
begin
  FillTriangle(BLTriangle(AX0, AY0, AX1, AY1, AX2, AY2), AStyle);
end;

procedure TBLContext.FillTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double;
  const AStyle: TAlphaColor);
begin
  FillTriangle(BLTriangle(AX0, AY0, AX1, AY1, AX2, AY2), AStyle);
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillUtf8TextIRgba64(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), AStyle.Value));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillUtf8TextIRgba32(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), AStyle.Value));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillUtf8TextIExt(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), @Style));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AText: UTF8String);
begin
  _BLCheck(_blContextFillUtf8TextI(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText)));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillUtf8TextIExt(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), @AStyle));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillUtf8TextIExt(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), @AStyle));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillUtf8TextIExt(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), @AStyle));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillUtf8TextIRgba32(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), AStyle));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillUtf8TextIRgba64(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, AStyle.Value));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillUtf8TextIRgba32(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, AStyle.Value));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillUtf8TextIExt(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, @Style));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AView: TBLStringView);
begin
  _BLCheck(_blContextFillUtf8TextI(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillUtf8TextIExt(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, @AStyle));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillUtf8TextIExt(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, @AStyle));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillUtf8TextIExt(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, @AStyle));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillUtf8TextIRgba32(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, AStyle));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillUtf8TextDRgba64(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), AStyle.Value));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillUtf8TextDRgba32(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), AStyle.Value));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillUtf8TextDExt(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), @Style));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AText: UTF8String);
begin
  _BLCheck(_blContextFillUtf8TextD(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText)));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillUtf8TextDExt(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), @AStyle));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillUtf8TextDExt(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), @AStyle));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillUtf8TextDExt(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), @AStyle));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillUtf8TextDRgba32(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), AStyle));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillUtf8TextDRgba64(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, AStyle.Value));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillUtf8TextDRgba32(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, AStyle.Value));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillUtf8TextDExt(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, @Style));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AView: TBLStringView);
begin
  _BLCheck(_blContextFillUtf8TextD(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillUtf8TextDExt(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, @AStyle));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillUtf8TextDExt(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, @AStyle));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillUtf8TextDExt(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, @AStyle));
end;

procedure TBLContext.FillUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillUtf8TextDRgba32(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, AStyle));
end;

class operator TBLContext.Finalize(var ADest: TBLContext);
begin
  if (ADest.FBase.NeedsCleanup) then
    _BLCheck(_blContextDestroy(@ADest));
end;

procedure TBLContext.Finish;
begin
  _BLCheck(_blContextEnd(@Self));
end;

procedure TBLContext.Flush(const AFlags: TBLContextFlushFlags);
begin
  _BLCheck(_blContextFlush(@Self, Cardinal(AFlags)));
end;

function TBLContext.GetAccumulatedErrorFlags: TBLContextErrorFlags;
begin
  _BLCheck(_blObjectGetPropertyUInt32(@Self, 'accumulatedErrorFlags', 21, @Result));
end;

function TBLContext.GetApproximationOptions: TBLApproximationOptions;
begin
  Result := State.ApproximationOptions;
end;

function TBLContext.GetCompOp: TBLCompOp;
begin
  Result := TBLCompOp(State.CompOp);
end;

function TBLContext.GetContextType: TBLContextType;
begin
  Result := TBLContextType(Impl.ContextType);
end;

function TBLContext.GetFillAlpha: Double;
begin
  Result := State.StyleAlpha[Ord(TBLContextStyleSlot.Fill)];
end;

function TBLContext.GetFillRule: TBLFillRule;
begin
  Result := TBLFillRule(State.FillRule);
end;

function TBLContext.GetFillStyle: TBLVar;
begin
  _BLCheck(_blContextGetFillStyle(@Self, @Result))
end;

function TBLContext.GetFillStyleType: TBLObjectType;
begin
  Result := TBLObjectType(State.StyleType[Ord(TBLContextStyleSlot.Fill)]);
end;

function TBLContext.GetFinalTransform: TBLMatrix2D;
begin
  Result := State.FinalTransform;
end;

function TBLContext.GetFlattenMode: TBLFlattenMode;
begin
  Result := State.ApproximationOptions.FlattenMode;
end;

function TBLContext.GetFlattenTolerance: Double;
begin
  Result := State.ApproximationOptions.FlattenTolerance;
end;

function TBLContext.GetGlobalAlpha: Double;
begin
  Result := State.GlobalAlpha;
end;

function TBLContext.GetGradientQuality: TBLGradientQuality;
begin
  Result := State.Hints.GradientQuality;
end;

function TBLContext.GetHints: TBLContextHints;
begin
  Result := State.Hints;
end;

function TBLContext.GetIsValid: Boolean;
begin
  Result := (ContextType <> TBLContextType.None);
end;

function TBLContext.GetMetaTransform: TBLMatrix2D;
begin
  Result := State.MetaTransform;
end;

function TBLContext.GetPatternQuality: TBLPatternQuality;
begin
  Result := State.Hints.PatternQuality;
end;

function TBLContext.GetRenderingQuality: TBLRenderingQuality;
begin
  Result := State.Hints.RenderingQuality;
end;

function TBLContext.GetSavedStateCount: Integer;
begin
  Result := State.SavedStateCount;
end;

function TBLContext.GetStrokeAlpha: Double;
begin
  Result := State.StyleAlpha[Ord(TBLContextStyleSlot.Stroke)];
end;

function TBLContext.GetStrokeDashArray: TBLArray<Double>;
begin
  Result := State.StrokeOptions.DashArray;
end;

function TBLContext.GetStrokeDashOffset: Double;
begin
  Result := State.StrokeOptions.DashOffset;
end;

function TBLContext.GetStrokeEndCap: TBLStrokeCap;
begin
  Result := State.StrokeOptions.EndCap;
end;

function TBLContext.GetStrokeJoin: TBLStrokeJoin;
begin
  Result := State.StrokeOptions.Join;
end;

function TBLContext.GetStrokeMiterLimit: Double;
begin
  Result := State.StrokeOptions.MiterLimit;
end;

function TBLContext.GetStrokeOptions: TBLStrokeOptions;
begin
  Result := State.StrokeOptions;
end;

function TBLContext.GetStrokeStartCap: TBLStrokeCap;
begin
  Result := State.StrokeOptions.StartCap;
end;

function TBLContext.GetStrokeStyle: TBLVar;
begin
  _BLCheck(_blContextGetStrokeStyle(@Self, @Result))
end;

function TBLContext.GetStrokeStyleType: TBLObjectType;
begin
  Result := TBLObjectType(State.StyleType[Ord(TBLContextStyleSlot.Stroke)]);
end;

function TBLContext.GetStrokeTransformOrder: TBLStrokeTransformOrder;
begin
  Result := State.StrokeOptions.TransformOrder;
end;

function TBLContext.GetStrokeWidth: Double;
begin
  Result := State.StrokeOptions.Width;
end;

function TBLContext.GetStyle(const ASlot: TBLContextStyleSlot): TBLVar;
begin
  if (ASlot = TBLContextStyleSlot.Fill) then
    _BLCheck(_blContextGetFillStyle(@Self, @Result))
  else
    _BLCheck(_blContextGetStrokeStyle(@Self, @Result));
end;

function TBLContext.GetStyleAlpha(const ASlot: TBLContextStyleSlot): Double;
begin
  Result := State.StyleAlpha[Ord(ASlot)];
end;

function TBLContext.GetStyleType(
  const ASlot: TBLContextStyleSlot): TBLObjectType;
begin
  Result := TBLObjectType(State.StyleType[Ord(ASlot)]);
end;

function TBLContext.GetTargetHeight: Double;
begin
  Result := State.Targetize.H;
end;

function TBLContext.GetTargetImage: TBLImage;
begin
  _blImageAssignWeak(@Result, @State.TargetImage);
end;

function TBLContext.GetTargetSize: TBLSize;
begin
  Result := State.Targetize;
end;

function TBLContext.GetTargetWidth: Double;
begin
  Result := State.Targetize.W;
end;

function TBLContext.GetThreadCount: Integer;
begin
  _BLCheck(_blObjectGetPropertyUInt32(@Self, 'threadCount', 11, @Result));
end;

function TBLContext.GetTransformedFillStyle: TBLVar;
begin
  _BLCheck(_blContextGetTransformedFillStyle(@Self, @Result))
end;

function TBLContext.GetTransformedStrokeStyle: TBLVar;
begin
  _BLCheck(_blContextGetTransformedStrokeStyle(@Self, @Result))
end;

function TBLContext.GetTransformedStyle(
  const ASlot: TBLContextStyleSlot): TBLVar;
begin
  if (ASlot = TBLContextStyleSlot.Fill) then
    _BLCheck(_blContextGetTransformedFillStyle(@Self, @Result))
  else
    _BLCheck(_blContextGetTransformedStrokeStyle(@Self, @Result));
end;

function TBLContext.GetUserTransform: TBLMatrix2D;
begin
  Result := State.UserTransform;
end;

function TBLContext.Impl: PImpl;
begin
  Result := PImpl(FBase.FImpl);
end;

class operator TBLContext.Initialize(out ADest: TBLContext);
begin
  _BLCheck(_blContextInit(@ADest));
end;

class operator TBLContext.NotEqual(const ALeft: TBLContext;
  const ARight: Pointer): Boolean;
begin
  if (ALeft.IsValid) then
    Result := (ARight <> nil)
  else
    Result := (ARight = nil);
end;

class operator TBLContext.NotEqual(const ALeft, ARight: TBLContext): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLContext.PostRotate(const AAngle: Double);
begin
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.PostRotate), @AAngle));
end;

procedure TBLContext.PostRotate(const AAngle, AX, AY: Double);
var
  Values: array [0..2] of Double;
begin
  Values[0] := AAngle;
  Values[1] := AX;
  Values[2] := AY;
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.PostRotatePoint), @Values));
end;

procedure TBLContext.PostRotate(const AAngle: Double; const AOrigin: TBLPointI);
var
  Values: array [0..2] of Double;
begin
  Values[0] := AAngle;
  Values[1] := AOrigin.X;
  Values[2] := AOrigin.Y;
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.PostRotatePoint), @Values));
end;

procedure TBLContext.PostRotate(const AAngle: Double; const AOrigin: TBLPoint);
var
  Values: array [0..2] of Double;
begin
  Values[0] := AAngle;
  Values[1] := AOrigin.X;
  Values[2] := AOrigin.Y;
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.PostRotatePoint), @Values));
end;

procedure TBLContext.PostScale(const AP: TBLPoint);
begin
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.PostScale), @AP));
end;

procedure TBLContext.PostScale(const AP: TBLPointI);
begin
  var P := BLPoint(AP.X, AP.Y);
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.PostScale), @P));
end;

procedure TBLContext.PostScale(const AX, AY: Double);
begin
  var P := BLPoint(AX, AY);
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.PostScale), @P));
end;

procedure TBLContext.PostScale(const AXY: Double);
begin
  var P := BLPoint(AXY, AXY);
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.PostScale), @P));
end;

procedure TBLContext.PostSkew(const AX, AY: Double);
begin
  var P := BLPoint(AX, AY);
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.PostSkew), @P));
end;

procedure TBLContext.PostSkew(const AP: TBLPoint);
begin
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.PostSkew), @AP));
end;

procedure TBLContext.PostTransform(const ATransform: TBLMatrix2D);
begin
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.PostTransform), @ATransform));
end;

procedure TBLContext.PostTranslate(const AP: TBLPoint);
begin
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.PostTranslate), @AP));
end;

procedure TBLContext.PostTranslate(const AP: TBLPointI);
begin
  var P := BLPoint(AP.X, AP.Y);
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.PostTranslate), @P));
end;

procedure TBLContext.PostTranslate(const AX, AY: Double);
begin
  var P := BLPoint(AX, AY);
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.PostTranslate), @P));
end;

procedure TBLContext.Reset;
begin
  _BLCheck(_blContextReset(@Self));
end;

procedure TBLContext.ResetTransform;
begin
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.Reset), nil));
end;

procedure TBLContext.Restore(const ACookie: TBLContextCookie);
begin
  _BLCheck(_blContextRestore(@Self, @ACookie));
end;

procedure TBLContext.RestoreClipping;
begin
  _BLCheck(_blContextRestoreClipping(@Self));
end;

procedure TBLContext.Rotate(const AAngle: Double);
begin
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.Rotate), @AAngle));
end;

procedure TBLContext.Rotate(const AAngle, AX, AY: Double);
var
  Values: array [0..2] of Double;
begin
  Values[0] := AAngle;
  Values[1] := AX;
  Values[2] := AY;
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.RotatePoint), @Values));
end;

procedure TBLContext.Rotate(const AAngle: Double; const AOrigin: TBLPoint);
var
  Values: array [0..2] of Double;
begin
  Values[0] := AAngle;
  Values[1] := AOrigin.X;
  Values[2] := AOrigin.Y;
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.RotatePoint), @Values));
end;

procedure TBLContext.Rotate(const AAngle: Double; const AOrigin: TBLPointI);
var
  Values: array [0..2] of Double;
begin
  Values[0] := AAngle;
  Values[1] := AOrigin.X;
  Values[2] := AOrigin.Y;
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.RotatePoint), @Values));
end;

procedure TBLContext.Restore;
begin
  _BLCheck(_blContextRestore(@Self, nil));
end;

procedure TBLContext.Save;
begin
  _BLCheck(_blContextSave(@Self, nil));
end;

procedure TBLContext.Save(out ACookie: TBLContextCookie);
begin
  _BLCheck(_blContextSave(@Self, @ACookie));
end;

procedure TBLContext.Scale(const AX, AY: Double);
begin
  var P := BLPoint(AX, AY);
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.Scale), @P));
end;

procedure TBLContext.Scale(const AXY: Double);
begin
  var P := BLPoint(AXY, AXY);
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.Scale), @P));
end;

procedure TBLContext.Scale(const AP: TBLPoint);
begin
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.Scale), @AP));
end;

procedure TBLContext.Scale(const AP: TBLPointI);
begin
  var P := BLPoint(AP.X, AP.Y);
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.Scale), @P));
end;

procedure TBLContext.SetApproximationOptions(
  const AValue: TBLApproximationOptions);
begin
  _BLCheck(_blContextSetApproximationOptions(@Self, @AValue));
end;

procedure TBLContext.SetCompOp(const AValue: TBLCompOp);
begin
  _BLCheck(_blContextSetCompOp(@Self, Ord(AValue)));
end;

procedure TBLContext.SetFillStyle(const AStyle: TBLVar);
begin
  _BLCheck(_blContextSetFillStyle(@Self, @AStyle))
end;

procedure TBLContext.SetFillStyle(const AStyle: TBLRgba);
begin
  _BLCheck(_blContextSetFillStyleRgba(@Self, @AStyle))
end;

procedure TBLContext.SetFillStyle(const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextSetFillStyleRgba32(@Self, AStyle.Value))
end;

procedure TBLContext.SetFillStyle(const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextSetFillStyleRgba64(@Self, AStyle.Value))
end;

procedure TBLContext.SetFillStyle(const AStyle: TBLGradient);
begin
  _BLCheck(_blContextSetFillStyle(@Self, @AStyle))
end;

procedure TBLContext.SetFillStyle(const AStyle: TBLPattern);
begin
  _BLCheck(_blContextSetFillStyle(@Self, @AStyle))
end;

procedure TBLContext.SetFillStyle(const AStyle: TBLGradient;
  const ATransformMode: TBLContextStyleTransformMode);
begin
  _BLCheck(_blContextSetFillStyleWithMode(@Self, @AStyle, Ord(ATransformMode)))
end;

procedure TBLContext.SetFillStyle(const AStyle: TBLPattern;
  const ATransformMode: TBLContextStyleTransformMode);
begin
  _BLCheck(_blContextSetFillStyleWithMode(@Self, @AStyle, Ord(ATransformMode)))
end;

procedure TBLContext.SetFillAlpha(const AValue: Double);
begin
  _BLCheck(_blContextSetFillAlpha(@Self, AValue));
end;

procedure TBLContext.SetFillRule(const AValue: TBLFillRule);
begin
  _BLCheck(_blContextSetFillRule(@Self, Ord(AValue)));
end;

procedure TBLContext.SetFillStyle(const AStyle: TBLVar;
  const ATransformMode: TBLContextStyleTransformMode);
begin
  _BLCheck(_blContextSetFillStyleWithMode(@Self, @AStyle, Ord(ATransformMode)))
end;

procedure TBLContext.SetFillStyle(const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextSetFillStyleRgba32(@Self, AStyle))
end;

procedure TBLContext.SetFlattenMode(const AValue: TBLFlattenMode);
begin
  _BLCheck(_blContextSetFlattenMode(@Self, Ord(AValue)));
end;

procedure TBLContext.SetFlattenTolerance(const AValue: Double);
begin
  _BLCheck(_blContextSetFlattenTolerance(@Self, AValue));
end;

procedure TBLContext.SetGlobalAlpha(const AValue: Double);
begin
  _BLCheck(_blContextSetGlobalAlpha(@Self, AValue));
end;

procedure TBLContext.SetGradientQuality(const AValue: TBLGradientQuality);
begin
  _BLCheck(_blContextSetHint(@Self, Ord(TBLContextHint.GradientQuality), Ord(AValue)));
end;

procedure TBLContext.SetHint(const AHintType: TBLContextHint;
  const AValue: Integer);
begin
  _BLCheck(_blContextSetHint(@Self, Ord(AHintType), AValue));
end;

procedure TBLContext.SetHints(const AValue: TBLContextHints);
begin
  _BLCheck(_blContextSetHints(@Self, @AValue));
end;

procedure TBLContext.SetPatternQuality(const AValue: TBLPatternQuality);
begin
  _BLCheck(_blContextSetHint(@Self, Ord(TBLContextHint.PatternQuality), Ord(AValue)));
end;

procedure TBLContext.SetRenderingQuality(const AValue: TBLRenderingQuality);
begin
  _BLCheck(_blContextSetHint(@Self, Ord(TBLContextHint.RenderingQuality), Ord(AValue)));
end;

procedure TBLContext.SetStyle(const ASlot: TBLContextStyleSlot;
  const AStyle: TBLRgba);
begin
  if (ASlot = TBLContextStyleSlot.Fill) then
    _BLCheck(_blContextSetFillStyleRgba(@Self, @AStyle))
  else
    _BLCheck(_blContextSetStrokeStyleRgba(@Self, @AStyle));
end;

procedure TBLContext.SetStyle(const ASlot: TBLContextStyleSlot;
  const AStyle: TBLRgba32);
begin
  if (ASlot = TBLContextStyleSlot.Fill) then
    _BLCheck(_blContextSetFillStyleRgba32(@Self, AStyle.Value))
  else
    _BLCheck(_blContextSetStrokeStyleRgba32(@Self, AStyle.Value));
end;

procedure TBLContext.SetStyle(const ASlot: TBLContextStyleSlot;
  const AStyle: TBLRgba64);
begin
  if (ASlot = TBLContextStyleSlot.Fill) then
    _BLCheck(_blContextSetFillStyleRgba64(@Self, AStyle.Value))
  else
    _BLCheck(_blContextSetStrokeStyleRgba64(@Self, AStyle.Value));
end;

procedure TBLContext.SetStyle(const ASlot: TBLContextStyleSlot;
  const AStyle: TBLGradient);
begin
  if (ASlot = TBLContextStyleSlot.Fill) then
    _BLCheck(_blContextSetFillStyle(@Self, @AStyle))
  else
    _BLCheck(_blContextSetStrokeStyle(@Self, @AStyle));
end;

procedure TBLContext.SetStyle(const ASlot: TBLContextStyleSlot;
  const AStyle: TBLPattern);
begin
  if (ASlot = TBLContextStyleSlot.Fill) then
    _BLCheck(_blContextSetFillStyle(@Self, @AStyle))
  else
    _BLCheck(_blContextSetStrokeStyle(@Self, @AStyle));
end;

procedure TBLContext.SetStyle(const ASlot: TBLContextStyleSlot;
  const AStyle: TBLVar);
begin
  if (ASlot = TBLContextStyleSlot.Fill) then
    _BLCheck(_blContextSetFillStyle(@Self, @AStyle))
  else
    _BLCheck(_blContextSetStrokeStyle(@Self, @AStyle));
end;

procedure TBLContext.SetStyle(const ASlot: TBLContextStyleSlot;
  const AStyle: TBLGradient;
  const ATransformMode: TBLContextStyleTransformMode);
begin
  if (ASlot = TBLContextStyleSlot.Fill) then
    _BLCheck(_blContextSetFillStyleWithMode(@Self, @AStyle, Ord(ATransformMode)))
  else
    _BLCheck(_blContextSetStrokeStyleWithMode(@Self, @AStyle, Ord(ATransformMode)));
end;

procedure TBLContext.SetStyle(const ASlot: TBLContextStyleSlot;
  const AStyle: TBLPattern; const ATransformMode: TBLContextStyleTransformMode);
begin
  if (ASlot = TBLContextStyleSlot.Fill) then
    _BLCheck(_blContextSetFillStyleWithMode(@Self, @AStyle, Ord(ATransformMode)))
  else
    _BLCheck(_blContextSetStrokeStyleWithMode(@Self, @AStyle, Ord(ATransformMode)));
end;

procedure TBLContext.SetStrokeStyle(const AStyle: TBLVar);
begin
  _BLCheck(_blContextSetStrokeStyle(@Self, @AStyle))
end;

procedure TBLContext.SetStrokeStyle(const AStyle: TBLRgba);
begin
  _BLCheck(_blContextSetStrokeStyleRgba(@Self, @AStyle))
end;

procedure TBLContext.SetStrokeStyle(const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextSetStrokeStyleRgba32(@Self, AStyle.Value))
end;

procedure TBLContext.SetStrokeStyle(const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextSetStrokeStyleRgba64(@Self, AStyle.Value))
end;

procedure TBLContext.SetStrokeStyle(const AStyle: TBLGradient);
begin
  _BLCheck(_blContextSetStrokeStyle(@Self, @AStyle))
end;

procedure TBLContext.SetStrokeStyle(const AStyle: TBLPattern);
begin
  _BLCheck(_blContextSetStrokeStyle(@Self, @AStyle))
end;

procedure TBLContext.SetStrokeStyle(const AStyle: TBLGradient;
  const ATransformMode: TBLContextStyleTransformMode);
begin
  _BLCheck(_blContextSetStrokeStyleWithMode(@Self, @AStyle, Ord(ATransformMode)))
end;

procedure TBLContext.SetStrokeStyle(const AStyle: TBLPattern;
  const ATransformMode: TBLContextStyleTransformMode);
begin
  _BLCheck(_blContextSetStrokeStyleWithMode(@Self, @AStyle, Ord(ATransformMode)))
end;

procedure TBLContext.SetStrokeAlpha(const AValue: Double);
begin
  _BLCheck(_blContextSetStrokeAlpha(@Self, AValue));
end;

procedure TBLContext.SetStrokeCap(const APosition: TBLStrokeCapPosition;
  const AStrokeCap: TBLStrokeCap);
begin
  _BLCheck(_blContextSetStrokeCap(@Self, Ord(APosition), Ord(AStrokeCap)));
end;

procedure TBLContext.SetStrokeCaps(const AStrokeCap: TBLStrokeCap);
begin
  _BLCheck(_blContextSetStrokeCaps(@Self, Ord(AStrokeCap)));
end;

procedure TBLContext.SetStrokeDashArray(const AValue: TBLArray<Double>);
begin
  _BLCheck(_blContextSetStrokeDashArray(@Self, @AValue));
end;

procedure TBLContext.SetStrokeDashOffset(const AValue: Double);
begin
  _BLCheck(_blContextSetStrokeDashOffset(@Self, AValue));
end;

procedure TBLContext.SetStrokeEndCap(const AValue: TBLStrokeCap);
begin
  _BLCheck(_blContextSetStrokeCap(@Self, Ord(TBLStrokeCapPosition.EndOfPath), Ord(AValue)));
end;

procedure TBLContext.SetStrokeJoin(const AValue: TBLStrokeJoin);
begin
  _BLCheck(_blContextSetStrokeJoin(@Self, Ord(AValue)));
end;

procedure TBLContext.SetStrokeMiterLimit(const AValue: Double);
begin
  _BLCheck(_blContextSetStrokeMiterLimit(@Self, AValue));
end;

procedure TBLContext.SetStrokeOptions(const AValue: TBLStrokeOptions);
begin
  _BLCheck(_blContextSetStrokeOptions(@Self, @AValue));
end;

procedure TBLContext.SetStrokeStartCap(const AValue: TBLStrokeCap);
begin
  _BLCheck(_blContextSetStrokeCap(@Self, Ord(TBLStrokeCapPosition.StartOfPath), Ord(AValue)));
end;

procedure TBLContext.SetStrokeStyle(const AStyle: TBLVar;
  const ATransformMode: TBLContextStyleTransformMode);
begin
  _BLCheck(_blContextSetStrokeStyleWithMode(@Self, @AStyle, Ord(ATransformMode)))
end;

procedure TBLContext.SetStrokeStyle(const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextSetStrokeStyleRgba32(@Self, AStyle))
end;

procedure TBLContext.SetStrokeTransformOrder(
  const AValue: TBLStrokeTransformOrder);
begin
  _BLCheck(_blContextSetStrokeTransformOrder(@Self, Ord(AValue)));
end;

procedure TBLContext.SetStrokeWidth(const AValue: Double);
begin
  _BLCheck(_blContextSetStrokeWidth(@Self, AValue));
end;

procedure TBLContext.SetStyle(const ASlot: TBLContextStyleSlot;
  const AStyle: TBLVar; const ATransformMode: TBLContextStyleTransformMode);
begin
  if (ASlot = TBLContextStyleSlot.Fill) then
    _BLCheck(_blContextSetFillStyleWithMode(@Self, @AStyle, Ord(ATransformMode)))
  else
    _BLCheck(_blContextSetStrokeStyleWithMode(@Self, @AStyle, Ord(ATransformMode)));
end;

procedure TBLContext.SetStyle(const ASlot: TBLContextStyleSlot;
  const AColor: TAlphaColor);
begin
  if (ASlot = TBLContextStyleSlot.Fill) then
    _BLCheck(_blContextSetFillStyleRgba32(@Self, AColor))
  else
    _BLCheck(_blContextSetStrokeStyleRgba32(@Self, AColor));
end;

procedure TBLContext.SetStyleAlpha(const ASlot: TBLContextStyleSlot;
  const AValue: Double);
begin
  if (ASlot = TBLContextStyleSlot.Fill) then
    _BLCheck(_blContextSetFillAlpha(@Self, AValue))
  else
    _BLCheck(_blContextSetStrokeAlpha(@Self, AValue));
end;

procedure TBLContext.SetTransform(const ATransform: TBLMatrix2D);
begin
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.Assign), @ATransform));
end;

procedure TBLContext.SetUserTransform(const AValue: TBLMatrix2D);
begin
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.Assign), @AValue));
end;

procedure TBLContext.Skew(const AP: TBLPoint);
begin
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.Skew), @AP));
end;

procedure TBLContext.Skew(const AX, AY: Double);
begin
  var P := BLPoint(AX, AY);
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.Skew), @P));
end;

procedure TBLContext.Start(const AImage: TBLImage;
  const ACreateInfo: TBLContextCreateInfo);
begin
  _BLCheck(_blContextBegin(@Self, @AImage, @ACreateInfo));
end;

procedure TBLContext.Start(const AImage: TBLImage);
begin
  _BLCheck(_blContextBegin(@Self, @AImage, nil));
end;

function TBLContext.State: PState;
begin
  Result := PImpl(FBase.FImpl).State;
end;

procedure TBLContext.StrokeArc(const AArc: TBLArc; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokeGeometryRgba64(@Self, Ord(TBLGeometryType.Arc), @AArc, AStyle.Value));
end;

procedure TBLContext.StrokeArc(const AArc: TBLArc; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.Arc), @AArc, AStyle.Value));
end;

procedure TBLContext.StrokeArc(const AArc: TBLArc; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Arc), @AArc, @Style));
end;

procedure TBLContext.StrokeArc(const AArc: TBLArc);
begin
  _BLCheck(_blContextStrokeGeometry(@Self, Ord(TBLGeometryType.Arc), @AArc));
end;

procedure TBLContext.StrokeArc(const AArc: TBLArc; const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Arc), @AArc, @AStyle));
end;

procedure TBLContext.StrokeArc(const AArc: TBLArc; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Arc), @AArc, @AStyle));
end;

procedure TBLContext.StrokeArc(const AArc: TBLArc; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Arc), @AArc, @AStyle));
end;

procedure TBLContext.StrokeArc(const AArc: TBLArc; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.Arc), @AArc, AStyle));
end;

procedure TBLContext.StrokeArc(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLRgba64);
begin
  StrokeArc(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeArc(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLRgba32);
begin
  StrokeArc(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeArc(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLRgba);
begin
  StrokeArc(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeArc(const ACX, ACY, AR, AStart, ASweep: Double);
begin
  StrokeArc(BLArc(ACX, ACY, AR, AR, AStart, ASweep));
end;

procedure TBLContext.StrokeArc(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLVar);
begin
  StrokeArc(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeArc(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLGradient);
begin
  StrokeArc(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeArc(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLPattern);
begin
  StrokeArc(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeArc(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TAlphaColor);
begin
  StrokeArc(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeArc(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLRgba64);
begin
  StrokeArc(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeArc(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLRgba32);
begin
  StrokeArc(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeArc(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLRgba);
begin
  StrokeArc(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeArc(const ACX, ACY, ARX, ARY, AStart,
  ASweep: Double);
begin
  StrokeArc(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep));
end;

procedure TBLContext.StrokeArc(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLVar);
begin
  StrokeArc(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeArc(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLGradient);
begin
  StrokeArc(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeArc(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLPattern);
begin
  StrokeArc(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeArc(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TAlphaColor);
begin
  StrokeArc(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeBox(const ABox: TBLBox; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokeGeometryRgba64(@Self, Ord(TBLGeometryType.BoxD), @ABox, AStyle.Value));
end;

procedure TBLContext.StrokeBox(const ABox: TBLBox; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.BoxD), @ABox, AStyle.Value));
end;

procedure TBLContext.StrokeBox(const ABox: TBLBox; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.BoxD), @ABox, @Style));
end;

procedure TBLContext.StrokeBox(const ABox: TBLBox);
begin
  _BLCheck(_blContextStrokeGeometry(@Self, Ord(TBLGeometryType.BoxD), @ABox));
end;

procedure TBLContext.StrokeBox(const ABox: TBLBox; const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.BoxD), @ABox, @AStyle));
end;

procedure TBLContext.StrokeBox(const ABox: TBLBox; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.BoxD), @ABox, @AStyle));
end;

procedure TBLContext.StrokeBox(const ABox: TBLBox; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.BoxD), @ABox, @AStyle));
end;

procedure TBLContext.StrokeBox(const ABox: TBLBox; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.BoxD), @ABox, AStyle));
end;

procedure TBLContext.StrokeBox(const ABox: TBLBoxI; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokeGeometryRgba64(@Self, Ord(TBLGeometryType.BoxI), @ABox, AStyle.Value));
end;

procedure TBLContext.StrokeBox(const ABox: TBLBoxI; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.BoxI), @ABox, AStyle.Value));
end;

procedure TBLContext.StrokeBox(const ABox: TBLBoxI; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.BoxI), @ABox, @Style));
end;

procedure TBLContext.StrokeBox(const ABox: TBLBoxI);
begin
  _BLCheck(_blContextStrokeGeometry(@Self, Ord(TBLGeometryType.BoxI), @ABox));
end;

procedure TBLContext.StrokeBox(const ABox: TBLBoxI; const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.BoxI), @ABox, @AStyle));
end;

procedure TBLContext.StrokeBox(const ABox: TBLBoxI; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.BoxI), @ABox, @AStyle));
end;

procedure TBLContext.StrokeBox(const ABox: TBLBoxI; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.BoxI), @ABox, @AStyle));
end;

procedure TBLContext.StrokeBox(const ABox: TBLBoxI; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.BoxI), @ABox, AStyle));
end;

procedure TBLContext.StrokeBox(const AX0, AY0, AX1, AY1: Double;
  const AStyle: TBLRgba64);
begin
  StrokeBox(BLBox(AX0, AY0, AX1, AY1), AStyle);
end;

procedure TBLContext.StrokeBox(const AX0, AY0, AX1, AY1: Double;
  const AStyle: TBLRgba32);
begin
  StrokeBox(BLBox(AX0, AY0, AX1, AY1), AStyle);
end;

procedure TBLContext.StrokeBox(const AX0, AY0, AX1, AY1: Double;
  const AStyle: TBLRgba);
begin
  StrokeBox(BLBox(AX0, AY0, AX1, AY1), AStyle);
end;

procedure TBLContext.StrokeBox(const AX0, AY0, AX1, AY1: Double);
begin
  StrokeBox(BLBox(AX0, AY0, AX1, AY1));
end;

procedure TBLContext.StrokeBox(const AX0, AY0, AX1, AY1: Double;
  const AStyle: TBLVar);
begin
  StrokeBox(BLBox(AX0, AY0, AX1, AY1), AStyle);
end;

procedure TBLContext.StrokeBox(const AX0, AY0, AX1, AY1: Double;
  const AStyle: TBLGradient);
begin
  StrokeBox(BLBox(AX0, AY0, AX1, AY1), AStyle);
end;

procedure TBLContext.StrokeBox(const AX0, AY0, AX1, AY1: Double;
  const AStyle: TBLPattern);
begin
  StrokeBox(BLBox(AX0, AY0, AX1, AY1), AStyle);
end;

procedure TBLContext.StrokeBox(const AX0, AY0, AX1, AY1: Double;
  const AStyle: TAlphaColor);
begin
  StrokeBox(BLBox(AX0, AY0, AX1, AY1), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: TBLArrayView<TBLBox>;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokeGeometryRgba64(@Self, Ord(TBLGeometryType.ArrayViewBoxD), @AArray, AStyle.Value));
end;

procedure TBLContext.StrokeBoxArray(const AArray: TBLArrayView<TBLBox>;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.ArrayViewBoxD), @AArray, AStyle.Value));
end;

procedure TBLContext.StrokeBoxArray(const AArray: TBLArrayView<TBLBox>;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewBoxD), @AArray, @Style));
end;

procedure TBLContext.StrokeBoxArray(const AArray: TBLArrayView<TBLBox>);
begin
  _BLCheck(_blContextStrokeGeometry(@Self, Ord(TBLGeometryType.ArrayViewBoxD), @AArray));
end;

procedure TBLContext.StrokeBoxArray(const AArray: TBLArrayView<TBLBox>;
  const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewBoxD), @AArray, @AStyle));
end;

procedure TBLContext.StrokeBoxArray(const AArray: TBLArrayView<TBLBox>;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewBoxD), @AArray, @AStyle));
end;

procedure TBLContext.StrokeBoxArray(const AArray: TBLArrayView<TBLBox>;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewBoxD), @AArray, @AStyle));
end;

procedure TBLContext.StrokeBoxArray(const AArray: TBLArrayView<TBLBox>;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.ArrayViewBoxD), @AArray, AStyle));
end;

procedure TBLContext.StrokeBoxArray(const AArray: TArray<TBLBox>;
  const AStyle: TBLRgba64);
begin
  StrokeBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: TArray<TBLBox>;
  const AStyle: TBLRgba32);
begin
  StrokeBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: TArray<TBLBox>;
  const AStyle: TBLRgba);
begin
  StrokeBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: TArray<TBLBox>);
begin
  StrokeBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), Length(AArray)));
end;

procedure TBLContext.StrokeBoxArray(const AArray: TArray<TBLBox>;
  const AStyle: TBLVar);
begin
  StrokeBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: TArray<TBLBox>;
  const AStyle: TBLGradient);
begin
  StrokeBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: TArray<TBLBox>;
  const AStyle: TBLPattern);
begin
  StrokeBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: TArray<TBLBox>;
  const AStyle: TAlphaColor);
begin
  StrokeBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: PBLBox; const ACount: NativeInt;
  const AStyle: TBLRgba64);
begin
  StrokeBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: PBLBox; const ACount: NativeInt;
  const AStyle: TBLRgba32);
begin
  StrokeBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: PBLBox; const ACount: NativeInt;
  const AStyle: TBLRgba);
begin
  StrokeBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: PBLBox;
  const ACount: NativeInt);
begin
  StrokeBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), ACount));
end;

procedure TBLContext.StrokeBoxArray(const AArray: PBLBox; const ACount: NativeInt;
  const AStyle: TBLVar);
begin
  StrokeBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: PBLBox; const ACount: NativeInt;
  const AStyle: TBLGradient);
begin
  StrokeBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: PBLBox; const ACount: NativeInt;
  const AStyle: TBLPattern);
begin
  StrokeBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: PBLBox; const ACount: NativeInt;
  const AStyle: TAlphaColor);
begin
  StrokeBoxArray(TBLArrayView<TBLBox>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: TBLArrayView<TBLBoxI>;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokeGeometryRgba64(@Self, Ord(TBLGeometryType.ArrayViewBoxI), @AArray, AStyle.Value));
end;

procedure TBLContext.StrokeBoxArray(const AArray: TBLArrayView<TBLBoxI>;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.ArrayViewBoxI), @AArray, AStyle.Value));
end;

procedure TBLContext.StrokeBoxArray(const AArray: TBLArrayView<TBLBoxI>;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewBoxI), @AArray, @Style));
end;

procedure TBLContext.StrokeBoxArray(const AArray: TBLArrayView<TBLBoxI>);
begin
  _BLCheck(_blContextStrokeGeometry(@Self, Ord(TBLGeometryType.ArrayViewBoxI), @AArray));
end;

procedure TBLContext.StrokeBoxArray(const AArray: TBLArrayView<TBLBoxI>;
  const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewBoxI), @AArray, @AStyle));
end;

procedure TBLContext.StrokeBoxArray(const AArray: TBLArrayView<TBLBoxI>;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewBoxI), @AArray, @AStyle));
end;

procedure TBLContext.StrokeBoxArray(const AArray: TBLArrayView<TBLBoxI>;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewBoxI), @AArray, @AStyle));
end;

procedure TBLContext.StrokeBoxArray(const AArray: TBLArrayView<TBLBoxI>;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.ArrayViewBoxI), @AArray, AStyle));
end;

procedure TBLContext.StrokeBoxArray(const AArray: TArray<TBLBoxI>;
  const AStyle: TBLRgba64);
begin
  StrokeBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: TArray<TBLBoxI>;
  const AStyle: TBLRgba32);
begin
  StrokeBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: TArray<TBLBoxI>;
  const AStyle: TBLRgba);
begin
  StrokeBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: TArray<TBLBoxI>);
begin
  StrokeBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), Length(AArray)));
end;

procedure TBLContext.StrokeBoxArray(const AArray: TArray<TBLBoxI>;
  const AStyle: TBLVar);
begin
  StrokeBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: TArray<TBLBoxI>;
  const AStyle: TBLGradient);
begin
  StrokeBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: TArray<TBLBoxI>;
  const AStyle: TBLPattern);
begin
  StrokeBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: TArray<TBLBoxI>;
  const AStyle: TAlphaColor);
begin
  StrokeBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: PBLBoxI; const ACount: NativeInt;
  const AStyle: TBLRgba64);
begin
  StrokeBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: PBLBoxI; const ACount: NativeInt;
  const AStyle: TBLRgba32);
begin
  StrokeBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: PBLBoxI; const ACount: NativeInt;
  const AStyle: TBLRgba);
begin
  StrokeBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: PBLBoxI;
  const ACount: NativeInt);
begin
  StrokeBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), ACount));
end;

procedure TBLContext.StrokeBoxArray(const AArray: PBLBoxI; const ACount: NativeInt;
  const AStyle: TBLVar);
begin
  StrokeBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: PBLBoxI; const ACount: NativeInt;
  const AStyle: TBLGradient);
begin
  StrokeBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: PBLBoxI; const ACount: NativeInt;
  const AStyle: TBLPattern);
begin
  StrokeBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeBoxArray(const AArray: PBLBoxI; const ACount: NativeInt;
  const AStyle: TAlphaColor);
begin
  StrokeBoxArray(TBLArrayView<TBLBoxI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeChord(const AChord: TBLArc; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokeGeometryRgba64(@Self, Ord(TBLGeometryType.Chord), @AChord, AStyle.Value));
end;

procedure TBLContext.StrokeChord(const AChord: TBLArc; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.Chord), @AChord, AStyle.Value));
end;

procedure TBLContext.StrokeChord(const AChord: TBLArc; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Chord), @AChord, @Style));
end;

procedure TBLContext.StrokeChord(const AChord: TBLArc);
begin
  _BLCheck(_blContextStrokeGeometry(@Self, Ord(TBLGeometryType.Chord), @AChord));
end;

procedure TBLContext.StrokeChord(const AChord: TBLArc; const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Chord), @AChord, @AStyle));
end;

procedure TBLContext.StrokeChord(const AChord: TBLArc; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Chord), @AChord, @AStyle));
end;

procedure TBLContext.StrokeChord(const AChord: TBLArc; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Chord), @AChord, @AStyle));
end;

procedure TBLContext.StrokeChord(const AChord: TBLArc; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.Chord), @AChord, AStyle));
end;

procedure TBLContext.StrokeChord(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLRgba64);
begin
  StrokeChord(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeChord(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLRgba32);
begin
  StrokeChord(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeChord(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLRgba);
begin
  StrokeChord(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeChord(const ACX, ACY, AR, AStart, ASweep: Double);
begin
  StrokeChord(BLArc(ACX, ACY, AR, AR, AStart, ASweep));
end;

procedure TBLContext.StrokeChord(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLVar);
begin
  StrokeChord(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeChord(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLGradient);
begin
  StrokeChord(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeChord(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLPattern);
begin
  StrokeChord(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeChord(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TAlphaColor);
begin
  StrokeChord(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLRgba64);
begin
  StrokeChord(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLRgba32);
begin
  StrokeChord(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLRgba);
begin
  StrokeChord(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeChord(const ACX, ACY, ARX, ARY, AStart,
  ASweep: Double);
begin
  StrokeChord(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep));
end;

procedure TBLContext.StrokeChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLVar);
begin
  StrokeChord(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLGradient);
begin
  StrokeChord(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLPattern);
begin
  StrokeChord(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeChord(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TAlphaColor);
begin
  StrokeChord(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokeCircle(const ACircle: TBLCircle;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokeGeometryRgba64(@Self, Ord(TBLGeometryType.Circle), @ACircle, AStyle.Value));
end;

procedure TBLContext.StrokeCircle(const ACircle: TBLCircle;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.Circle), @ACircle, AStyle.Value));
end;

procedure TBLContext.StrokeCircle(const ACircle: TBLCircle;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Circle), @ACircle, @Style));
end;

procedure TBLContext.StrokeCircle(const ACircle: TBLCircle);
begin
  _BLCheck(_blContextStrokeGeometry(@Self, Ord(TBLGeometryType.Circle), @ACircle));
end;

procedure TBLContext.StrokeCircle(const ACircle: TBLCircle; const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Circle), @ACircle, @AStyle));
end;

procedure TBLContext.StrokeCircle(const ACircle: TBLCircle;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Circle), @ACircle, @AStyle));
end;

procedure TBLContext.StrokeCircle(const ACircle: TBLCircle;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Circle), @ACircle, @AStyle));
end;

procedure TBLContext.StrokeCircle(const ACircle: TBLCircle;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.Circle), @ACircle, AStyle));
end;

procedure TBLContext.StrokeCircle(const ACX, ACY, AR: Double;
  const AStyle: TBLRgba64);
begin
  StrokeCircle(BLCircle(ACX, ACY, AR), AStyle);
end;

procedure TBLContext.StrokeCircle(const ACX, ACY, AR: Double;
  const AStyle: TBLRgba32);
begin
  StrokeCircle(BLCircle(ACX, ACY, AR), AStyle);
end;

procedure TBLContext.StrokeCircle(const ACX, ACY, AR: Double;
  const AStyle: TBLRgba);
begin
  StrokeCircle(BLCircle(ACX, ACY, AR), AStyle);
end;

procedure TBLContext.StrokeCircle(const ACX, ACY, AR: Double);
begin
  StrokeCircle(BLCircle(ACX, ACY, AR));
end;

procedure TBLContext.StrokeCircle(const ACX, ACY, AR: Double;
  const AStyle: TBLVar);
begin
  StrokeCircle(BLCircle(ACX, ACY, AR), AStyle);
end;

procedure TBLContext.StrokeCircle(const ACX, ACY, AR: Double;
  const AStyle: TBLGradient);
begin
  StrokeCircle(BLCircle(ACX, ACY, AR), AStyle);
end;

procedure TBLContext.StrokeCircle(const ACX, ACY, AR: Double;
  const AStyle: TBLPattern);
begin
  StrokeCircle(BLCircle(ACX, ACY, AR), AStyle);
end;

procedure TBLContext.StrokeCircle(const ACX, ACY, AR: Double;
  const AStyle: TAlphaColor);
begin
  StrokeCircle(BLCircle(ACX, ACY, AR), AStyle);
end;

procedure TBLContext.StrokeEllipse(const AEllipse: TBLEllipse;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokeGeometryRgba64(@Self, Ord(TBLGeometryType.Ellipse), @AEllipse, AStyle.Value));
end;

procedure TBLContext.StrokeEllipse(const AEllipse: TBLEllipse;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.Ellipse), @AEllipse, AStyle.Value));
end;

procedure TBLContext.StrokeEllipse(const AEllipse: TBLEllipse;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Ellipse), @AEllipse, @Style));
end;

procedure TBLContext.StrokeEllipse(const AEllipse: TBLEllipse);
begin
  _BLCheck(_blContextStrokeGeometry(@Self, Ord(TBLGeometryType.Ellipse), @AEllipse));
end;

procedure TBLContext.StrokeEllipse(const AEllipse: TBLEllipse;
  const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Ellipse), @AEllipse, @AStyle));
end;

procedure TBLContext.StrokeEllipse(const AEllipse: TBLEllipse;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Ellipse), @AEllipse, @AStyle));
end;

procedure TBLContext.StrokeEllipse(const AEllipse: TBLEllipse;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Ellipse), @AEllipse, @AStyle));
end;

procedure TBLContext.StrokeEllipse(const AEllipse: TBLEllipse;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.Ellipse), @AEllipse, AStyle));
end;

procedure TBLContext.StrokeEllipse(const ACX, ACY, ARX, ARY: Double;
  const AStyle: TBLRgba64);
begin
  StrokeEllipse(BLEllipse(ACX, ACY, ARX, ARY), AStyle);
end;

procedure TBLContext.StrokeEllipse(const ACX, ACY, ARX, ARY: Double;
  const AStyle: TBLRgba32);
begin
  StrokeEllipse(BLEllipse(ACX, ACY, ARX, ARY), AStyle);
end;

procedure TBLContext.StrokeEllipse(const ACX, ACY, ARX, ARY: Double;
  const AStyle: TBLRgba);
begin
  StrokeEllipse(BLEllipse(ACX, ACY, ARX, ARY), AStyle);
end;

procedure TBLContext.StrokeEllipse(const ACX, ACY, ARX, ARY: Double);
begin
  StrokeEllipse(BLEllipse(ACX, ACY, ARX, ARY));
end;

procedure TBLContext.StrokeEllipse(const ACX, ACY, ARX, ARY: Double;
  const AStyle: TBLVar);
begin
  StrokeEllipse(BLEllipse(ACX, ACY, ARX, ARY), AStyle);
end;

procedure TBLContext.StrokeEllipse(const ACX, ACY, ARX, ARY: Double;
  const AStyle: TBLGradient);
begin
  StrokeEllipse(BLEllipse(ACX, ACY, ARX, ARY), AStyle);
end;

procedure TBLContext.StrokeEllipse(const ACX, ACY, ARX, ARY: Double;
  const AStyle: TBLPattern);
begin
  StrokeEllipse(BLEllipse(ACX, ACY, ARX, ARY), AStyle);
end;

procedure TBLContext.StrokeEllipse(const ACX, ACY, ARX, ARY: Double;
  const AStyle: TAlphaColor);
begin
  StrokeEllipse(BLEllipse(ACX, ACY, ARX, ARY), AStyle);
end;

procedure TBLContext.StrokeGeometry(const AType: TBLGeometryType;
  const AData: Pointer; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokeGeometryRgba64(@Self, Ord(AType), AData, AStyle.Value));
end;

procedure TBLContext.StrokeGeometry(const AType: TBLGeometryType;
  const AData: Pointer; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(AType), AData, AStyle.Value));
end;

procedure TBLContext.StrokeGeometry(const AType: TBLGeometryType;
  const AData: Pointer; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(AType), AData, @Style));
end;

procedure TBLContext.StrokeGeometry(const AType: TBLGeometryType;
  const AData: Pointer);
begin
  _BLCheck(_blContextStrokeGeometry(@Self, Ord(AType), AData));
end;

procedure TBLContext.StrokeGeometry(const AType: TBLGeometryType;
  const AData: Pointer; const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(AType), AData, @AStyle));
end;

procedure TBLContext.StrokeGeometry(const AType: TBLGeometryType;
  const AData: Pointer; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(AType), AData, @AStyle));
end;

procedure TBLContext.StrokeGeometry(const AType: TBLGeometryType;
  const AData: Pointer; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(AType), AData, @AStyle));
end;

procedure TBLContext.StrokeGeometry(const AType: TBLGeometryType;
  const AData: Pointer; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(AType), AData, AStyle));
end;

procedure TBLContext.StrokeGlyphRun(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokeGlyphRunIRgba64(@Self, @AOrigin, @AFont, @AGlyphRun, AStyle.Value));
end;

procedure TBLContext.StrokeGlyphRun(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokeGlyphRunIRgba32(@Self, @AOrigin, @AFont, @AGlyphRun, AStyle.Value));
end;

procedure TBLContext.StrokeGlyphRun(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokeGlyphRunIExt(@Self, @AOrigin, @AFont, @AGlyphRun, @Style));
end;

procedure TBLContext.StrokeGlyphRun(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun);
begin
  _BLCheck(_blContextStrokeGlyphRunI(@Self, @AOrigin, @AFont, @AGlyphRun));
end;

procedure TBLContext.StrokeGlyphRun(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun; const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokeGlyphRunIExt(@Self, @AOrigin, @AFont, @AGlyphRun, @AStyle));
end;

procedure TBLContext.StrokeGlyphRun(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokeGlyphRunIExt(@Self, @AOrigin, @AFont, @AGlyphRun, @AStyle));
end;

procedure TBLContext.StrokeGlyphRun(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokeGlyphRunIExt(@Self, @AOrigin, @AFont, @AGlyphRun, @AStyle));
end;

procedure TBLContext.StrokeGlyphRun(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokeGlyphRunIRgba32(@Self, @AOrigin, @AFont, @AGlyphRun, AStyle));
end;

procedure TBLContext.StrokeGlyphRun(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillGlyphRunDRgba64(@Self, @AOrigin, @AFont, @AGlyphRun, AStyle.Value));
end;

procedure TBLContext.StrokeGlyphRun(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillGlyphRunDRgba32(@Self, @AOrigin, @AFont, @AGlyphRun, AStyle.Value));
end;

procedure TBLContext.StrokeGlyphRun(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillGlyphRunDExt(@Self, @AOrigin, @AFont, @AGlyphRun, @Style));
end;

procedure TBLContext.StrokeGlyphRun(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun);
begin
  _BLCheck(_blContextFillGlyphRunD(@Self, @AOrigin, @AFont, @AGlyphRun));
end;

procedure TBLContext.StrokeGlyphRun(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun; const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillGlyphRunDExt(@Self, @AOrigin, @AFont, @AGlyphRun, @AStyle));
end;

procedure TBLContext.StrokeGlyphRun(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillGlyphRunDExt(@Self, @AOrigin, @AFont, @AGlyphRun, @AStyle));
end;

procedure TBLContext.StrokeGlyphRun(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillGlyphRunDExt(@Self, @AOrigin, @AFont, @AGlyphRun, @AStyle));
end;

procedure TBLContext.StrokeGlyphRun(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AGlyphRun: TBLGlyphRun;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillGlyphRunDRgba32(@Self, @AOrigin, @AFont, @AGlyphRun, AStyle));
end;

procedure TBLContext.StrokeLine(const ALine: TBLLine; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokeGeometryRgba64(@Self, Ord(TBLGeometryType.Line), @ALine, AStyle.Value));
end;

procedure TBLContext.StrokeLine(const ALine: TBLLine; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.Line), @ALine, AStyle.Value));
end;

procedure TBLContext.StrokeLine(const ALine: TBLLine; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Line), @ALine, @Style));
end;

procedure TBLContext.StrokeLine(const ALine: TBLLine);
begin
  _BLCheck(_blContextStrokeGeometry(@Self, Ord(TBLGeometryType.Line), @ALine));
end;

procedure TBLContext.StrokeLine(const ALine: TBLLine; const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Line), @ALine, @AStyle));
end;

procedure TBLContext.StrokeLine(const ALine: TBLLine;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Line), @ALine, @AStyle));
end;

procedure TBLContext.StrokeLine(const ALine: TBLLine; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Line), @ALine, @AStyle));
end;

procedure TBLContext.StrokeLine(const ALine: TBLLine;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.Line), @ALine, AStyle));
end;

procedure TBLContext.StrokeLine(const AP0, AP1: TBLPoint;
  const AStyle: TBLRgba64);
begin
  StrokeLine(BLLine(AP0, AP1), AStyle);
end;

procedure TBLContext.StrokeLine(const AP0, AP1: TBLPoint;
  const AStyle: TBLRgba32);
begin
  StrokeLine(BLLine(AP0, AP1), AStyle);
end;

procedure TBLContext.StrokeLine(const AP0, AP1: TBLPoint;
  const AStyle: TBLRgba);
begin
  StrokeLine(BLLine(AP0, AP1), AStyle);
end;

procedure TBLContext.StrokeLine(const AP0, AP1: TBLPoint);
begin
  StrokeLine(BLLine(AP0, AP1));
end;

procedure TBLContext.StrokeLine(const AP0, AP1: TBLPoint; const AStyle: TBLVar);
begin
  StrokeLine(BLLine(AP0, AP1), AStyle);
end;

procedure TBLContext.StrokeLine(const AP0, AP1: TBLPoint;
  const AStyle: TBLGradient);
begin
  StrokeLine(BLLine(AP0, AP1), AStyle);
end;

procedure TBLContext.StrokeLine(const AP0, AP1: TBLPoint;
  const AStyle: TBLPattern);
begin
  StrokeLine(BLLine(AP0, AP1), AStyle);
end;

procedure TBLContext.StrokeLine(const AP0, AP1: TBLPoint;
  const AStyle: TAlphaColor);
begin
  StrokeLine(BLLine(AP0, AP1), AStyle);
end;

procedure TBLContext.StrokeLine(const AX0, AY0, AX1, AY1: Double;
  const AStyle: TBLRgba64);
begin
  StrokeLine(BLLine(AX0, AY0, AX1, AY1), AStyle);
end;

procedure TBLContext.StrokeLine(const AX0, AY0, AX1, AY1: Double;
  const AStyle: TBLRgba32);
begin
  StrokeLine(BLLine(AX0, AY0, AX1, AY1), AStyle);
end;

procedure TBLContext.StrokeLine(const AX0, AY0, AX1, AY1: Double;
  const AStyle: TBLRgba);
begin
  StrokeLine(BLLine(AX0, AY0, AX1, AY1), AStyle);
end;

procedure TBLContext.StrokeLine(const AX0, AY0, AX1, AY1: Double);
begin
  StrokeLine(BLLine(AX0, AY0, AX1, AY1));
end;

procedure TBLContext.StrokeLine(const AX0, AY0, AX1, AY1: Double;
  const AStyle: TBLVar);
begin
  StrokeLine(BLLine(AX0, AY0, AX1, AY1), AStyle);
end;

procedure TBLContext.StrokeLine(const AX0, AY0, AX1, AY1: Double;
  const AStyle: TBLGradient);
begin
  StrokeLine(BLLine(AX0, AY0, AX1, AY1), AStyle);
end;

procedure TBLContext.StrokeLine(const AX0, AY0, AX1, AY1: Double;
  const AStyle: TBLPattern);
begin
  StrokeLine(BLLine(AX0, AY0, AX1, AY1), AStyle);
end;

procedure TBLContext.StrokeLine(const AX0, AY0, AX1, AY1: Double;
  const AStyle: TAlphaColor);
begin
  StrokeLine(BLLine(AX0, AY0, AX1, AY1), AStyle);
end;

procedure TBLContext.StrokePath(const APath: TBLPath; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokePathDRgba32(@Self, @TBLPoint.Empty, @APath, AStyle.Value));
end;

procedure TBLContext.StrokePath(const APath: TBLPath; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokePathDRgba64(@Self, @TBLPoint.Empty, @APath, AStyle.Value));
end;

procedure TBLContext.StrokePath(const APath: TBLPath; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokePathDExt(@Self, @TBLPoint.Empty, @APath, @Style));
end;

procedure TBLContext.StrokePath(const APath: TBLPath);
begin
  _BLCheck(_blContextStrokePathD(@Self, @TBLPoint.Empty, @APath));
end;

procedure TBLContext.StrokePath(const APath: TBLPath; const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokePathDExt(@Self, @TBLPoint.Empty, @APath, @AStyle));
end;

procedure TBLContext.StrokePath(const APath: TBLPath; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokePathDExt(@Self, @TBLPoint.Empty, @APath, @AStyle));
end;

procedure TBLContext.StrokePath(const APath: TBLPath; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokePathDExt(@Self, @TBLPoint.Empty, @APath, @AStyle));
end;

procedure TBLContext.StrokePath(const APath: TBLPath; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokePathDRgba32(@Self, @TBLPoint.Empty, @APath, AStyle));
end;

procedure TBLContext.StrokePath(const AOrigin: TBLPoint; const APath: TBLPath;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokePathDRgba64(@Self, @AOrigin, @APath, AStyle));
end;

procedure TBLContext.StrokePath(const AOrigin: TBLPoint; const APath: TBLPath;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokePathDRgba32(@Self, @AOrigin, @APath, AStyle));
end;

procedure TBLContext.StrokePath(const AOrigin: TBLPoint; const APath: TBLPath;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokePathDExt(@Self, @AOrigin, @APath, @Style));
end;

procedure TBLContext.StrokePath(const AOrigin: TBLPoint; const APath: TBLPath);
begin
  _BLCheck(_blContextStrokePathD(@Self, @AOrigin, @APath));
end;

procedure TBLContext.StrokePath(const AOrigin: TBLPoint; const APath: TBLPath;
  const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokePathDExt(@Self, @AOrigin, @APath, @AStyle));
end;

procedure TBLContext.StrokePath(const AOrigin: TBLPoint; const APath: TBLPath;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokePathDExt(@Self, @AOrigin, @APath, @AStyle));
end;

procedure TBLContext.StrokePath(const AOrigin: TBLPoint; const APath: TBLPath;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokePathDExt(@Self, @AOrigin, @APath, @AStyle));
end;

procedure TBLContext.StrokePath(const AOrigin: TBLPoint; const APath: TBLPath;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokePathDRgba32(@Self, @AOrigin, @APath, AStyle));
end;

procedure TBLContext.StrokePie(const APie: TBLArc; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokeGeometryRgba64(@Self, Ord(TBLGeometryType.Pie), @APie, AStyle.Value));
end;

procedure TBLContext.StrokePie(const APie: TBLArc; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.Pie), @APie, AStyle.Value));
end;

procedure TBLContext.StrokePie(const APie: TBLArc; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Pie), @APie, @Style));
end;

procedure TBLContext.StrokePie(const APie: TBLArc);
begin
  _BLCheck(_blContextStrokeGeometry(@Self, Ord(TBLGeometryType.Pie), @APie));
end;

procedure TBLContext.StrokePie(const APie: TBLArc; const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Pie), @APie, @AStyle));
end;

procedure TBLContext.StrokePie(const APie: TBLArc; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Pie), @APie, @AStyle));
end;

procedure TBLContext.StrokePie(const APie: TBLArc; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Pie), @APie, @AStyle));
end;

procedure TBLContext.StrokePie(const APie: TBLArc; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.Pie), @APie, AStyle));
end;

procedure TBLContext.StrokePie(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLRgba64);
begin
  StrokePie(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokePie(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLRgba32);
begin
  StrokePie(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokePie(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLRgba);
begin
  StrokePie(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokePie(const ACX, ACY, AR, AStart, ASweep: Double);
begin
  StrokePie(BLArc(ACX, ACY, AR, AR, AStart, ASweep));
end;

procedure TBLContext.StrokePie(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLVar);
begin
  StrokePie(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokePie(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLGradient);
begin
  StrokePie(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokePie(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TBLPattern);
begin
  StrokePie(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokePie(const ACX, ACY, AR, AStart, ASweep: Double;
  const AStyle: TAlphaColor);
begin
  StrokePie(BLArc(ACX, ACY, AR, AR, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokePie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLRgba64);
begin
  StrokePie(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokePie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLRgba32);
begin
  StrokePie(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokePie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLRgba);
begin
  StrokePie(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokePie(const ACX, ACY, ARX, ARY, AStart,
  ASweep: Double);
begin
  StrokePie(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep));
end;

procedure TBLContext.StrokePie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLVar);
begin
  StrokePie(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokePie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLGradient);
begin
  StrokePie(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokePie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TBLPattern);
begin
  StrokePie(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokePie(const ACX, ACY, ARX, ARY, AStart, ASweep: Double;
  const AStyle: TAlphaColor);
begin
  StrokePie(BLArc(ACX, ACY, ARX, ARY, AStart, ASweep), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: TBLArrayView<TBLPoint>;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokeGeometryRgba64(@Self, Ord(TBLGeometryType.PolygonD), @APoly, AStyle.Value));
end;

procedure TBLContext.StrokePolygon(const APoly: TBLArrayView<TBLPoint>;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.PolygonD), @APoly, AStyle.Value));
end;

procedure TBLContext.StrokePolygon(const APoly: TBLArrayView<TBLPoint>;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.PolygonD), @APoly, @Style));
end;

procedure TBLContext.StrokePolygon(const APoly: TBLArrayView<TBLPoint>);
begin
  _BLCheck(_blContextStrokeGeometry(@Self, Ord(TBLGeometryType.PolygonD), @APoly));
end;

procedure TBLContext.StrokePolygon(const APoly: TBLArrayView<TBLPoint>;
  const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.PolygonD), @APoly, @AStyle));
end;

procedure TBLContext.StrokePolygon(const APoly: TBLArrayView<TBLPoint>;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.PolygonD), @APoly, @AStyle));
end;

procedure TBLContext.StrokePolygon(const APoly: TBLArrayView<TBLPoint>;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.PolygonD), @APoly, @AStyle));
end;

procedure TBLContext.StrokePolygon(const APoly: TBLArrayView<TBLPoint>;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.PolygonD), @APoly, AStyle));
end;

procedure TBLContext.StrokePolygon(const APoly: TArray<TBLPoint>;
  const AStyle: TBLRgba64);
begin
  StrokePolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: TArray<TBLPoint>;
  const AStyle: TBLRgba32);
begin
  StrokePolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: TArray<TBLPoint>;
  const AStyle: TBLRgba);
begin
  StrokePolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: TArray<TBLPoint>);
begin
  StrokePolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), Length(APoly)));
end;

procedure TBLContext.StrokePolygon(const APoly: TArray<TBLPoint>;
  const AStyle: TBLVar);
begin
  StrokePolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: TArray<TBLPoint>;
  const AStyle: TBLGradient);
begin
  StrokePolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: TArray<TBLPoint>;
  const AStyle: TBLPattern);
begin
  StrokePolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: TArray<TBLPoint>;
  const AStyle: TAlphaColor);
begin
  StrokePolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: PBLPoint; const ACount: NativeInt;
  const AStyle: TBLRgba64);
begin
  StrokePolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: PBLPoint; const ACount: NativeInt;
  const AStyle: TBLRgba32);
begin
  StrokePolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: PBLPoint; const ACount: NativeInt;
  const AStyle: TBLRgba);
begin
  StrokePolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: PBLPoint; const ACount: NativeInt);
begin
  StrokePolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), ACount));
end;

procedure TBLContext.StrokePolygon(const APoly: PBLPoint; const ACount: NativeInt;
  const AStyle: TBLVar);
begin
  StrokePolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: PBLPoint; const ACount: NativeInt;
  const AStyle: TBLGradient);
begin
  StrokePolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: PBLPoint; const ACount: NativeInt;
  const AStyle: TBLPattern);
begin
  StrokePolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: PBLPoint; const ACount: NativeInt;
  const AStyle: TAlphaColor);
begin
  StrokePolygon(TBLArrayView<TBLPoint>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: TBLArrayView<TBLPointI>;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokeGeometryRgba64(@Self, Ord(TBLGeometryType.PolygonI), @APoly, AStyle.Value));
end;

procedure TBLContext.StrokePolygon(const APoly: TBLArrayView<TBLPointI>;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.PolygonI), @APoly, AStyle.Value));
end;

procedure TBLContext.StrokePolygon(const APoly: TBLArrayView<TBLPointI>;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.PolygonI), @APoly, @Style));
end;

procedure TBLContext.StrokePolygon(const APoly: TBLArrayView<TBLPointI>);
begin
  _BLCheck(_blContextStrokeGeometry(@Self, Ord(TBLGeometryType.PolygonI), @APoly));
end;

procedure TBLContext.StrokePolygon(const APoly: TBLArrayView<TBLPointI>;
  const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.PolygonI), @APoly, @AStyle));
end;

procedure TBLContext.StrokePolygon(const APoly: TBLArrayView<TBLPointI>;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.PolygonI), @APoly, @AStyle));
end;

procedure TBLContext.StrokePolygon(const APoly: TBLArrayView<TBLPointI>;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.PolygonI), @APoly, @AStyle));
end;

procedure TBLContext.StrokePolygon(const APoly: TBLArrayView<TBLPointI>;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.PolygonI), @APoly, AStyle));
end;

procedure TBLContext.StrokePolygon(const APoly: TArray<TBLPointI>;
  const AStyle: TBLRgba64);
begin
  StrokePolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: TArray<TBLPointI>;
  const AStyle: TBLRgba32);
begin
  StrokePolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: TArray<TBLPointI>;
  const AStyle: TBLRgba);
begin
  StrokePolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: TArray<TBLPointI>);
begin
  StrokePolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), Length(APoly)));
end;

procedure TBLContext.StrokePolygon(const APoly: TArray<TBLPointI>;
  const AStyle: TBLVar);
begin
  StrokePolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: TArray<TBLPointI>;
  const AStyle: TBLGradient);
begin
  StrokePolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: TArray<TBLPointI>;
  const AStyle: TBLPattern);
begin
  StrokePolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: TArray<TBLPointI>;
  const AStyle: TAlphaColor);
begin
  StrokePolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: PBLPointI; const ACount: NativeInt;
  const AStyle: TBLRgba64);
begin
  StrokePolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: PBLPointI; const ACount: NativeInt;
  const AStyle: TBLRgba32);
begin
  StrokePolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: PBLPointI; const ACount: NativeInt;
  const AStyle: TBLRgba);
begin
  StrokePolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: PBLPointI; const ACount: NativeInt);
begin
  StrokePolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), ACount));
end;

procedure TBLContext.StrokePolygon(const APoly: PBLPointI; const ACount: NativeInt;
  const AStyle: TBLVar);
begin
  StrokePolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: PBLPointI; const ACount: NativeInt;
  const AStyle: TBLGradient);
begin
  StrokePolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: PBLPointI; const ACount: NativeInt;
  const AStyle: TBLPattern);
begin
  StrokePolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolygon(const APoly: PBLPointI; const ACount: NativeInt;
  const AStyle: TAlphaColor);
begin
  StrokePolygon(TBLArrayView<TBLPointI>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: TBLArrayView<TBLPoint>;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokeGeometryRgba64(@Self, Ord(TBLGeometryType.PolylineD), @APoly, AStyle.Value));
end;

procedure TBLContext.StrokePolyline(const APoly: TBLArrayView<TBLPoint>;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.PolylineD), @APoly, AStyle.Value));
end;

procedure TBLContext.StrokePolyline(const APoly: TBLArrayView<TBLPoint>;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.PolylineD), @APoly, @Style));
end;

procedure TBLContext.StrokePolyline(const APoly: TBLArrayView<TBLPoint>);
begin
  _BLCheck(_blContextStrokeGeometry(@Self, Ord(TBLGeometryType.PolylineD), @APoly));
end;

procedure TBLContext.StrokePolyline(const APoly: TBLArrayView<TBLPoint>;
  const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.PolylineD), @APoly, @AStyle));
end;

procedure TBLContext.StrokePolyline(const APoly: TBLArrayView<TBLPoint>;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.PolylineD), @APoly, @AStyle));
end;

procedure TBLContext.StrokePolyline(const APoly: TBLArrayView<TBLPoint>;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.PolylineD), @APoly, @AStyle));
end;

procedure TBLContext.StrokePolyline(const APoly: TBLArrayView<TBLPoint>;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.PolylineD), @APoly, AStyle));
end;

procedure TBLContext.StrokePolyline(const APoly: TArray<TBLPoint>;
  const AStyle: TBLRgba64);
begin
  StrokePolyline(TBLArrayView<TBLPoint>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: TArray<TBLPoint>;
  const AStyle: TBLRgba32);
begin
  StrokePolyline(TBLArrayView<TBLPoint>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: TArray<TBLPoint>;
  const AStyle: TBLRgba);
begin
  StrokePolyline(TBLArrayView<TBLPoint>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: TArray<TBLPoint>);
begin
  StrokePolyline(TBLArrayView<TBLPoint>.Create(Pointer(APoly), Length(APoly)));
end;

procedure TBLContext.StrokePolyline(const APoly: TArray<TBLPoint>;
  const AStyle: TBLVar);
begin
  StrokePolyline(TBLArrayView<TBLPoint>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: TArray<TBLPoint>;
  const AStyle: TBLGradient);
begin
  StrokePolyline(TBLArrayView<TBLPoint>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: TArray<TBLPoint>;
  const AStyle: TBLPattern);
begin
  StrokePolyline(TBLArrayView<TBLPoint>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: TArray<TBLPoint>;
  const AStyle: TAlphaColor);
begin
  StrokePolyline(TBLArrayView<TBLPoint>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: PBLPoint; const ACount: NativeInt;
  const AStyle: TBLRgba64);
begin
  StrokePolyline(TBLArrayView<TBLPoint>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: PBLPoint; const ACount: NativeInt;
  const AStyle: TBLRgba32);
begin
  StrokePolyline(TBLArrayView<TBLPoint>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: PBLPoint; const ACount: NativeInt;
  const AStyle: TBLRgba);
begin
  StrokePolyline(TBLArrayView<TBLPoint>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: PBLPoint; const ACount: NativeInt);
begin
  StrokePolyline(TBLArrayView<TBLPoint>.Create(Pointer(APoly), ACount));
end;

procedure TBLContext.StrokePolyline(const APoly: PBLPoint; const ACount: NativeInt;
  const AStyle: TBLVar);
begin
  StrokePolyline(TBLArrayView<TBLPoint>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: PBLPoint; const ACount: NativeInt;
  const AStyle: TBLGradient);
begin
  StrokePolyline(TBLArrayView<TBLPoint>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: PBLPoint; const ACount: NativeInt;
  const AStyle: TBLPattern);
begin
  StrokePolyline(TBLArrayView<TBLPoint>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: PBLPoint; const ACount: NativeInt;
  const AStyle: TAlphaColor);
begin
  StrokePolyline(TBLArrayView<TBLPoint>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: TBLArrayView<TBLPointI>;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokeGeometryRgba64(@Self, Ord(TBLGeometryType.PolylineI), @APoly, AStyle.Value));
end;

procedure TBLContext.StrokePolyline(const APoly: TBLArrayView<TBLPointI>;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.PolylineI), @APoly, AStyle.Value));
end;

procedure TBLContext.StrokePolyline(const APoly: TBLArrayView<TBLPointI>;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.PolylineI), @APoly, @Style));
end;

procedure TBLContext.StrokePolyline(const APoly: TBLArrayView<TBLPointI>);
begin
  _BLCheck(_blContextStrokeGeometry(@Self, Ord(TBLGeometryType.PolylineI), @APoly));
end;

procedure TBLContext.StrokePolyline(const APoly: TBLArrayView<TBLPointI>;
  const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.PolylineI), @APoly, @AStyle));
end;

procedure TBLContext.StrokePolyline(const APoly: TBLArrayView<TBLPointI>;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.PolylineI), @APoly, @AStyle));
end;

procedure TBLContext.StrokePolyline(const APoly: TBLArrayView<TBLPointI>;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.PolylineI), @APoly, @AStyle));
end;

procedure TBLContext.StrokePolyline(const APoly: TBLArrayView<TBLPointI>;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.PolylineI), @APoly, AStyle));
end;

procedure TBLContext.StrokePolyline(const APoly: TArray<TBLPointI>;
  const AStyle: TBLRgba64);
begin
  StrokePolyline(TBLArrayView<TBLPointI>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: TArray<TBLPointI>;
  const AStyle: TBLRgba32);
begin
  StrokePolyline(TBLArrayView<TBLPointI>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: TArray<TBLPointI>;
  const AStyle: TBLRgba);
begin
  StrokePolyline(TBLArrayView<TBLPointI>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: TArray<TBLPointI>);
begin
  StrokePolyline(TBLArrayView<TBLPointI>.Create(Pointer(APoly), Length(APoly)));
end;

procedure TBLContext.StrokePolyline(const APoly: TArray<TBLPointI>;
  const AStyle: TBLVar);
begin
  StrokePolyline(TBLArrayView<TBLPointI>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: TArray<TBLPointI>;
  const AStyle: TBLGradient);
begin
  StrokePolyline(TBLArrayView<TBLPointI>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: TArray<TBLPointI>;
  const AStyle: TBLPattern);
begin
  StrokePolyline(TBLArrayView<TBLPointI>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: TArray<TBLPointI>;
  const AStyle: TAlphaColor);
begin
  StrokePolyline(TBLArrayView<TBLPointI>.Create(Pointer(APoly), Length(APoly)), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: PBLPointI; const ACount: NativeInt;
  const AStyle: TBLRgba64);
begin
  StrokePolyline(TBLArrayView<TBLPointI>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: PBLPointI; const ACount: NativeInt;
  const AStyle: TBLRgba32);
begin
  StrokePolyline(TBLArrayView<TBLPointI>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: PBLPointI; const ACount: NativeInt;
  const AStyle: TBLRgba);
begin
  StrokePolyline(TBLArrayView<TBLPointI>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: PBLPointI; const ACount: NativeInt);
begin
  StrokePolyline(TBLArrayView<TBLPointI>.Create(Pointer(APoly), ACount));
end;

procedure TBLContext.StrokePolyline(const APoly: PBLPointI; const ACount: NativeInt;
  const AStyle: TBLVar);
begin
  StrokePolyline(TBLArrayView<TBLPointI>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: PBLPointI; const ACount: NativeInt;
  const AStyle: TBLGradient);
begin
  StrokePolyline(TBLArrayView<TBLPointI>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: PBLPointI; const ACount: NativeInt;
  const AStyle: TBLPattern);
begin
  StrokePolyline(TBLArrayView<TBLPointI>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokePolyline(const APoly: PBLPointI; const ACount: NativeInt;
  const AStyle: TAlphaColor);
begin
  StrokePolyline(TBLArrayView<TBLPointI>.Create(Pointer(APoly), ACount), AStyle);
end;

procedure TBLContext.StrokeRect(const ARect: TBLRectI; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokeRectIRgba64(@Self, @ARect, AStyle.Value));
end;

procedure TBLContext.StrokeRect(const ARect: TBLRectI; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokeRectIRgba32(@Self, @ARect, AStyle.Value));
end;

procedure TBLContext.StrokeRect(const ARect: TBLRectI; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokeRectIExt(@Self, @ARect, @Style));
end;

procedure TBLContext.StrokeRect(const ARect: TBLRectI);
begin
  _BLCheck(_blContextStrokeRectI(@Self, @ARect));
end;

procedure TBLContext.StrokeRect(const ARect: TBLRectI; const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokeRectIExt(@Self, @ARect, @AStyle));
end;

procedure TBLContext.StrokeRect(const ARect: TBLRectI; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokeRectIExt(@Self, @ARect, @AStyle));
end;

procedure TBLContext.StrokeRect(const ARect: TBLRectI; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokeRectIExt(@Self, @ARect, @AStyle));
end;

procedure TBLContext.StrokeRect(const ARect: TBLRectI; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokeRectIRgba32(@Self, @ARect, AStyle));
end;

procedure TBLContext.StrokeRect(const ARect: TBLRect; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillRectDRgba64(@Self, @ARect, AStyle.Value));
end;

procedure TBLContext.StrokeRect(const ARect: TBLRect; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillRectDRgba32(@Self, @ARect, AStyle.Value));
end;

procedure TBLContext.StrokeRect(const ARect: TBLRect; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillRectDExt(@Self, @ARect, @Style));
end;

procedure TBLContext.StrokeRect(const ARect: TBLRect);
begin
  _BLCheck(_blContextFillRectD(@Self, @ARect));
end;

procedure TBLContext.StrokeRect(const ARect: TBLRect; const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillRectDExt(@Self, @ARect, @AStyle));
end;

procedure TBLContext.StrokeRect(const ARect: TBLRect; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillRectDExt(@Self, @ARect, @AStyle));
end;

procedure TBLContext.StrokeRect(const ARect: TBLRect; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillRectDExt(@Self, @ARect, @AStyle));
end;

procedure TBLContext.StrokeRect(const ARect: TBLRect; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillRectDRgba32(@Self, @ARect, AStyle));
end;

procedure TBLContext.StrokeRect(const AX, AY, AW, AH: Double;
  const AStyle: TBLRgba64);
begin
  StrokeRect(BLRect(AX, AY, AW, AH), AStyle);
end;

procedure TBLContext.StrokeRect(const AX, AY, AW, AH: Double;
  const AStyle: TBLRgba32);
begin
  StrokeRect(BLRect(AX, AY, AW, AH), AStyle);
end;

procedure TBLContext.StrokeRect(const AX, AY, AW, AH: Double;
  const AStyle: TBLRgba);
begin
  StrokeRect(BLRect(AX, AY, AW, AH), AStyle);
end;

procedure TBLContext.StrokeRect(const AX, AY, AW, AH: Double);
begin
  StrokeRect(BLRect(AX, AY, AW, AH));
end;

procedure TBLContext.StrokeRect(const AX, AY, AW, AH: Double;
  const AStyle: TBLVar);
begin
  StrokeRect(BLRect(AX, AY, AW, AH), AStyle);
end;

procedure TBLContext.StrokeRect(const AX, AY, AW, AH: Double;
  const AStyle: TBLGradient);
begin
  StrokeRect(BLRect(AX, AY, AW, AH), AStyle);
end;

procedure TBLContext.StrokeRect(const AX, AY, AW, AH: Double;
  const AStyle: TBLPattern);
begin
  StrokeRect(BLRect(AX, AY, AW, AH), AStyle);
end;

procedure TBLContext.StrokeRect(const AX, AY, AW, AH: Double;
  const AStyle: TAlphaColor);
begin
  StrokeRect(BLRect(AX, AY, AW, AH), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: TBLArrayView<TBLRect>;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokeGeometryRgba64(@Self, Ord(TBLGeometryType.ArrayViewRectD), @AArray, AStyle.Value));
end;

procedure TBLContext.StrokeRectArray(const AArray: TBLArrayView<TBLRect>;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.ArrayViewRectD), @AArray, AStyle.Value));
end;

procedure TBLContext.StrokeRectArray(const AArray: TBLArrayView<TBLRect>;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewRectD), @AArray, @Style));
end;

procedure TBLContext.StrokeRectArray(const AArray: TBLArrayView<TBLRect>);
begin
  _BLCheck(_blContextStrokeGeometry(@Self, Ord(TBLGeometryType.ArrayViewRectD), @AArray));
end;

procedure TBLContext.StrokeRectArray(const AArray: TBLArrayView<TBLRect>;
  const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewRectD), @AArray, @AStyle));
end;

procedure TBLContext.StrokeRectArray(const AArray: TBLArrayView<TBLRect>;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewRectD), @AArray, @AStyle));
end;

procedure TBLContext.StrokeRectArray(const AArray: TBLArrayView<TBLRect>;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewRectD), @AArray, @AStyle));
end;

procedure TBLContext.StrokeRectArray(const AArray: TBLArrayView<TBLRect>;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.ArrayViewRectD), @AArray, AStyle));
end;

procedure TBLContext.StrokeRectArray(const AArray: TArray<TBLRect>;
  const AStyle: TBLRgba64);
begin
  StrokeRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: TArray<TBLRect>;
  const AStyle: TBLRgba32);
begin
  StrokeRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: TArray<TBLRect>;
  const AStyle: TBLRgba);
begin
  StrokeRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: TArray<TBLRect>);
begin
  StrokeRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), Length(AArray)));
end;

procedure TBLContext.StrokeRectArray(const AArray: TArray<TBLRect>;
  const AStyle: TBLVar);
begin
  StrokeRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: TArray<TBLRect>;
  const AStyle: TBLGradient);
begin
  StrokeRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: TArray<TBLRect>;
  const AStyle: TBLPattern);
begin
  StrokeRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: TArray<TBLRect>;
  const AStyle: TAlphaColor);
begin
  StrokeRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: PBLRect; const ACount: NativeInt;
  const AStyle: TBLRgba64);
begin
  StrokeRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: PBLRect; const ACount: NativeInt;
  const AStyle: TBLRgba32);
begin
  StrokeRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: PBLRect; const ACount: NativeInt;
  const AStyle: TBLRgba);
begin
  StrokeRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: PBLRect;
  const ACount: NativeInt);
begin
  StrokeRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), ACount));
end;

procedure TBLContext.StrokeRectArray(const AArray: PBLRect; const ACount: NativeInt;
  const AStyle: TBLVar);
begin
  StrokeRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: PBLRect; const ACount: NativeInt;
  const AStyle: TBLGradient);
begin
  StrokeRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: PBLRect; const ACount: NativeInt;
  const AStyle: TBLPattern);
begin
  StrokeRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: PBLRect; const ACount: NativeInt;
  const AStyle: TAlphaColor);
begin
  StrokeRectArray(TBLArrayView<TBLRect>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: TBLArrayView<TBLRectI>;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokeGeometryRgba64(@Self, Ord(TBLGeometryType.ArrayViewRectI), @AArray, AStyle.Value));
end;

procedure TBLContext.StrokeRectArray(const AArray: TBLArrayView<TBLRectI>;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.ArrayViewRectI), @AArray, AStyle.Value));
end;

procedure TBLContext.StrokeRectArray(const AArray: TBLArrayView<TBLRectI>;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewRectI), @AArray, @Style));
end;

procedure TBLContext.StrokeRectArray(const AArray: TBLArrayView<TBLRectI>);
begin
  _BLCheck(_blContextStrokeGeometry(@Self, Ord(TBLGeometryType.ArrayViewRectI), @AArray));
end;

procedure TBLContext.StrokeRectArray(const AArray: TBLArrayView<TBLRectI>;
  const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewRectI), @AArray, @AStyle));
end;

procedure TBLContext.StrokeRectArray(const AArray: TBLArrayView<TBLRectI>;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewRectI), @AArray, @AStyle));
end;

procedure TBLContext.StrokeRectArray(const AArray: TBLArrayView<TBLRectI>;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.ArrayViewRectI), @AArray, @AStyle));
end;

procedure TBLContext.StrokeRectArray(const AArray: TBLArrayView<TBLRectI>;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.ArrayViewRectI), @AArray, AStyle));
end;

procedure TBLContext.StrokeRectArray(const AArray: TArray<TBLRectI>;
  const AStyle: TBLRgba64);
begin
  StrokeRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: TArray<TBLRectI>;
  const AStyle: TBLRgba32);
begin
  StrokeRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: TArray<TBLRectI>;
  const AStyle: TBLRgba);
begin
  StrokeRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: TArray<TBLRectI>);
begin
  StrokeRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), Length(AArray)));
end;

procedure TBLContext.StrokeRectArray(const AArray: TArray<TBLRectI>;
  const AStyle: TBLVar);
begin
  StrokeRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: TArray<TBLRectI>;
  const AStyle: TBLGradient);
begin
  StrokeRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: TArray<TBLRectI>;
  const AStyle: TBLPattern);
begin
  StrokeRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: TArray<TBLRectI>;
  const AStyle: TAlphaColor);
begin
  StrokeRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), Length(AArray)), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: PBLRectI; const ACount: NativeInt;
  const AStyle: TBLRgba64);
begin
  StrokeRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: PBLRectI; const ACount: NativeInt;
  const AStyle: TBLRgba32);
begin
  StrokeRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: PBLRectI; const ACount: NativeInt;
  const AStyle: TBLRgba);
begin
  StrokeRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: PBLRectI;
  const ACount: NativeInt);
begin
  StrokeRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), ACount));
end;

procedure TBLContext.StrokeRectArray(const AArray: PBLRectI; const ACount: NativeInt;
  const AStyle: TBLVar);
begin
  StrokeRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: PBLRectI; const ACount: NativeInt;
  const AStyle: TBLGradient);
begin
  StrokeRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: PBLRectI; const ACount: NativeInt;
  const AStyle: TBLPattern);
begin
  StrokeRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeRectArray(const AArray: PBLRectI; const ACount: NativeInt;
  const AStyle: TAlphaColor);
begin
  StrokeRectArray(TBLArrayView<TBLRectI>.Create(Pointer(AArray), ACount), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const ARR: TBLRoundRect;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokeGeometryRgba64(@Self, Ord(TBLGeometryType.RoundRect), @ARR, AStyle.Value));
end;

procedure TBLContext.StrokeRoundRect(const ARR: TBLRoundRect;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.RoundRect), @ARR, AStyle.Value));
end;

procedure TBLContext.StrokeRoundRect(const ARR: TBLRoundRect;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.RoundRect), @ARR, @Style));
end;

procedure TBLContext.StrokeRoundRect(const ARR: TBLRoundRect);
begin
  _BLCheck(_blContextStrokeGeometry(@Self, Ord(TBLGeometryType.RoundRect), @ARR));
end;

procedure TBLContext.StrokeRoundRect(const ARR: TBLRoundRect;
  const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.RoundRect), @ARR, @AStyle));
end;

procedure TBLContext.StrokeRoundRect(const ARR: TBLRoundRect;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.RoundRect), @ARR, @AStyle));
end;

procedure TBLContext.StrokeRoundRect(const ARR: TBLRoundRect;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.RoundRect), @ARR, @AStyle));
end;

procedure TBLContext.StrokeRoundRect(const ARR: TBLRoundRect;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.RoundRect), @ARR, AStyle));
end;

procedure TBLContext.StrokeRoundRect(const ARect: TBLRect; const AR: Double;
  const AStyle: TBLRgba64);
begin
  StrokeRoundRect(BLRoundRect(ARect, AR), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const ARect: TBLRect; const AR: Double;
  const AStyle: TBLRgba32);
begin
  StrokeRoundRect(BLRoundRect(ARect, AR), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const ARect: TBLRect; const AR: Double;
  const AStyle: TBLRgba);
begin
  StrokeRoundRect(BLRoundRect(ARect, AR), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const ARect: TBLRect; const AR: Double);
begin
  StrokeRoundRect(BLRoundRect(ARect, AR));
end;

procedure TBLContext.StrokeRoundRect(const ARect: TBLRect; const AR: Double;
  const AStyle: TBLVar);
begin
  StrokeRoundRect(BLRoundRect(ARect, AR), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const ARect: TBLRect; const AR: Double;
  const AStyle: TBLGradient);
begin
  StrokeRoundRect(BLRoundRect(ARect, AR), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const ARect: TBLRect; const AR: Double;
  const AStyle: TBLPattern);
begin
  StrokeRoundRect(BLRoundRect(ARect, AR), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const ARect: TBLRect; const AR: Double;
  const AStyle: TAlphaColor);
begin
  StrokeRoundRect(BLRoundRect(ARect, AR), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const ARect: TBLRect; const ARX, ARY: Double;
  const AStyle: TBLRgba64);
begin
  StrokeRoundRect(BLRoundRect(ARect, ARX, ARY), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const ARect: TBLRect; const ARX, ARY: Double;
  const AStyle: TBLRgba32);
begin
  StrokeRoundRect(BLRoundRect(ARect, ARX, ARY), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const ARect: TBLRect; const ARX, ARY: Double;
  const AStyle: TBLRgba);
begin
  StrokeRoundRect(BLRoundRect(ARect, ARX, ARY), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const ARect: TBLRect; const ARX,
  ARY: Double);
begin
  StrokeRoundRect(BLRoundRect(ARect, ARX, ARY));
end;

procedure TBLContext.StrokeRoundRect(const ARect: TBLRect; const ARX, ARY: Double;
  const AStyle: TBLVar);
begin
  StrokeRoundRect(BLRoundRect(ARect, ARX, ARY), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const ARect: TBLRect; const ARX, ARY: Double;
  const AStyle: TBLGradient);
begin
  StrokeRoundRect(BLRoundRect(ARect, ARX, ARY), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const ARect: TBLRect; const ARX, ARY: Double;
  const AStyle: TBLPattern);
begin
  StrokeRoundRect(BLRoundRect(ARect, ARX, ARY), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const ARect: TBLRect; const ARX, ARY: Double;
  const AStyle: TAlphaColor);
begin
  StrokeRoundRect(BLRoundRect(ARect, ARX, ARY), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const AX, AY, AW, AH, AR: Double;
  const AStyle: TBLRgba64);
begin
  StrokeRoundRect(BLRoundRect(AX, AY, AW, AH, AR), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const AX, AY, AW, AH, AR: Double;
  const AStyle: TBLRgba32);
begin
  StrokeRoundRect(BLRoundRect(AX, AY, AW, AH, AR), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const AX, AY, AW, AH, AR: Double;
  const AStyle: TBLRgba);
begin
  StrokeRoundRect(BLRoundRect(AX, AY, AW, AH, AR), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const AX, AY, AW, AH, AR: Double);
begin
  StrokeRoundRect(BLRoundRect(AX, AY, AW, AH, AR));
end;

procedure TBLContext.StrokeRoundRect(const AX, AY, AW, AH, AR: Double;
  const AStyle: TBLVar);
begin
  StrokeRoundRect(BLRoundRect(AX, AY, AW, AH, AR), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const AX, AY, AW, AH, AR: Double;
  const AStyle: TBLGradient);
begin
  StrokeRoundRect(BLRoundRect(AX, AY, AW, AH, AR), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const AX, AY, AW, AH, AR: Double;
  const AStyle: TBLPattern);
begin
  StrokeRoundRect(BLRoundRect(AX, AY, AW, AH, AR), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const AX, AY, AW, AH, AR: Double;
  const AStyle: TAlphaColor);
begin
  StrokeRoundRect(BLRoundRect(AX, AY, AW, AH, AR), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const AX, AY, AW, AH, ARX, ARY: Double;
  const AStyle: TBLRgba64);
begin
  StrokeRoundRect(BLRoundRect(AX, AY, AW, AH, ARX, ARY), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const AX, AY, AW, AH, ARX, ARY: Double;
  const AStyle: TBLRgba32);
begin
  StrokeRoundRect(BLRoundRect(AX, AY, AW, AH, ARX, ARY), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const AX, AY, AW, AH, ARX, ARY: Double;
  const AStyle: TBLRgba);
begin
  StrokeRoundRect(BLRoundRect(AX, AY, AW, AH, ARX, ARY), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const AX, AY, AW, AH, ARX, ARY: Double);
begin
  StrokeRoundRect(BLRoundRect(AX, AY, AW, AH, ARX, ARY));
end;

procedure TBLContext.StrokeRoundRect(const AX, AY, AW, AH, ARX, ARY: Double;
  const AStyle: TBLVar);
begin
  StrokeRoundRect(BLRoundRect(AX, AY, AW, AH, ARX, ARY), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const AX, AY, AW, AH, ARX, ARY: Double;
  const AStyle: TBLGradient);
begin
  StrokeRoundRect(BLRoundRect(AX, AY, AW, AH, ARX, ARY), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const AX, AY, AW, AH, ARX, ARY: Double;
  const AStyle: TBLPattern);
begin
  StrokeRoundRect(BLRoundRect(AX, AY, AW, AH, ARX, ARY), AStyle);
end;

procedure TBLContext.StrokeRoundRect(const AX, AY, AW, AH, ARX, ARY: Double;
  const AStyle: TAlphaColor);
begin
  StrokeRoundRect(BLRoundRect(AX, AY, AW, AH, ARX, ARY), AStyle);
end;

procedure TBLContext.StrokeText(const AOrigin: TBLPointI; const AFont: TBLFont;
  const AText: String; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokeUtf16TextIRgba64(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), AStyle.Value));
end;

procedure TBLContext.StrokeText(const AOrigin: TBLPointI; const AFont: TBLFont;
  const AText: String; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokeUtf16TextIRgba32(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), AStyle.Value));
end;

procedure TBLContext.StrokeText(const AOrigin: TBLPointI; const AFont: TBLFont;
  const AText: String; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokeUtf16TextIExt(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), @Style));
end;

procedure TBLContext.StrokeText(const AOrigin: TBLPointI; const AFont: TBLFont;
  const AText: String);
begin
  _BLCheck(_blContextStrokeUtf16TextI(@Self, @AOrigin, @AFont, PChar(AText), Length(AText)));
end;

procedure TBLContext.StrokeText(const AOrigin: TBLPointI; const AFont: TBLFont;
  const AText: String; const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokeUtf16TextIExt(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), @AStyle));
end;

procedure TBLContext.StrokeText(const AOrigin: TBLPointI; const AFont: TBLFont;
  const AText: String; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokeUtf16TextIExt(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), @AStyle));
end;

procedure TBLContext.StrokeText(const AOrigin: TBLPointI; const AFont: TBLFont;
  const AText: String; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokeUtf16TextIExt(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), @AStyle));
end;

procedure TBLContext.StrokeText(const AOrigin: TBLPointI; const AFont: TBLFont;
  const AText: String; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokeUtf16TextIRgba32(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), AStyle));
end;

procedure TBLContext.StrokeText(const AOrigin: TBLPoint; const AFont: TBLFont;
  const AText: String; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillUtf16TextDRgba64(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), AStyle.Value));
end;

procedure TBLContext.StrokeText(const AOrigin: TBLPoint; const AFont: TBLFont;
  const AText: String; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillUtf16TextDRgba32(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), AStyle.Value));
end;

procedure TBLContext.StrokeText(const AOrigin: TBLPoint; const AFont: TBLFont;
  const AText: String; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillUtf16TextDExt(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), @Style));
end;

procedure TBLContext.StrokeText(const AOrigin: TBLPoint; const AFont: TBLFont;
  const AText: String);
begin
  _BLCheck(_blContextFillUtf16TextD(@Self, @AOrigin, @AFont, PChar(AText), Length(AText)));
end;

procedure TBLContext.StrokeText(const AOrigin: TBLPoint; const AFont: TBLFont;
  const AText: String; const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillUtf16TextDExt(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), @AStyle));
end;

procedure TBLContext.StrokeText(const AOrigin: TBLPoint; const AFont: TBLFont;
  const AText: String; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillUtf16TextDExt(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), @AStyle));
end;

procedure TBLContext.StrokeText(const AOrigin: TBLPoint; const AFont: TBLFont;
  const AText: String; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillUtf16TextDExt(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), @AStyle));
end;

procedure TBLContext.StrokeText(const AOrigin: TBLPoint; const AFont: TBLFont;
  const AText: String; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillUtf16TextDRgba32(@Self, @AOrigin, @AFont, PChar(AText), Length(AText), AStyle));
end;

procedure TBLContext.StrokeTriangle(const ATriangle: TBLTriangle;
  const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokeGeometryRgba64(@Self, Ord(TBLGeometryType.Triangle), @ATriangle, AStyle.Value));
end;

procedure TBLContext.StrokeTriangle(const ATriangle: TBLTriangle;
  const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.Triangle), @ATriangle, AStyle.Value));
end;

procedure TBLContext.StrokeTriangle(const ATriangle: TBLTriangle;
  const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Triangle), @ATriangle, @Style));
end;

procedure TBLContext.StrokeTriangle(const ATriangle: TBLTriangle);
begin
  _BLCheck(_blContextStrokeGeometry(@Self, Ord(TBLGeometryType.Triangle), @ATriangle));
end;

procedure TBLContext.StrokeTriangle(const ATriangle: TBLTriangle;
  const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Triangle), @ATriangle, @AStyle));
end;

procedure TBLContext.StrokeTriangle(const ATriangle: TBLTriangle;
  const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Triangle), @ATriangle, @AStyle));
end;

procedure TBLContext.StrokeTriangle(const ATriangle: TBLTriangle;
  const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokeGeometryExt(@Self, Ord(TBLGeometryType.Triangle), @ATriangle, @AStyle));
end;

procedure TBLContext.StrokeTriangle(const ATriangle: TBLTriangle;
  const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokeGeometryRgba32(@Self, Ord(TBLGeometryType.Triangle), @ATriangle, AStyle));
end;

procedure TBLContext.StrokeTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double;
  const AStyle: TBLRgba64);
begin
  StrokeTriangle(BLTriangle(AX0, AY0, AX1, AY1, AX2, AY2), AStyle);
end;

procedure TBLContext.StrokeTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double;
  const AStyle: TBLRgba32);
begin
  StrokeTriangle(BLTriangle(AX0, AY0, AX1, AY1, AX2, AY2), AStyle);
end;

procedure TBLContext.StrokeTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double;
  const AStyle: TBLRgba);
begin
  StrokeTriangle(BLTriangle(AX0, AY0, AX1, AY1, AX2, AY2), AStyle);
end;

procedure TBLContext.StrokeTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double);
begin
  StrokeTriangle(BLTriangle(AX0, AY0, AX1, AY1, AX2, AY2));
end;

procedure TBLContext.StrokeTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double;
  const AStyle: TBLVar);
begin
  StrokeTriangle(BLTriangle(AX0, AY0, AX1, AY1, AX2, AY2), AStyle);
end;

procedure TBLContext.StrokeTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double;
  const AStyle: TBLGradient);
begin
  StrokeTriangle(BLTriangle(AX0, AY0, AX1, AY1, AX2, AY2), AStyle);
end;

procedure TBLContext.StrokeTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double;
  const AStyle: TBLPattern);
begin
  StrokeTriangle(BLTriangle(AX0, AY0, AX1, AY1, AX2, AY2), AStyle);
end;

procedure TBLContext.StrokeTriangle(const AX0, AY0, AX1, AY1, AX2, AY2: Double;
  const AStyle: TAlphaColor);
begin
  StrokeTriangle(BLTriangle(AX0, AY0, AX1, AY1, AX2, AY2), AStyle);
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokeUtf8TextIRgba64(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), AStyle.Value));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokeUtf8TextIRgba32(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), AStyle.Value));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokeUtf8TextIExt(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), @Style));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AText: UTF8String);
begin
  _BLCheck(_blContextStrokeUtf8TextI(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText)));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokeUtf8TextIExt(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), @AStyle));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokeUtf8TextIExt(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), @AStyle));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokeUtf8TextIExt(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), @AStyle));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokeUtf8TextIRgba32(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), AStyle));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextStrokeUtf8TextIRgba64(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, AStyle.Value));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextStrokeUtf8TextIRgba32(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, AStyle.Value));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextStrokeUtf8TextIExt(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, @Style));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AView: TBLStringView);
begin
  _BLCheck(_blContextStrokeUtf8TextI(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TBLVar);
begin
  _BLCheck(_blContextStrokeUtf8TextIExt(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, @AStyle));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextStrokeUtf8TextIExt(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, @AStyle));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextStrokeUtf8TextIExt(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, @AStyle));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPointI;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextStrokeUtf8TextIRgba32(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, AStyle));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillUtf8TextDRgba64(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), AStyle.Value));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillUtf8TextDRgba32(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), AStyle.Value));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillUtf8TextDExt(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), @Style));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AText: UTF8String);
begin
  _BLCheck(_blContextFillUtf8TextD(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText)));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillUtf8TextDExt(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), @AStyle));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillUtf8TextDExt(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), @AStyle));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillUtf8TextDExt(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), @AStyle));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AText: UTF8String; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillUtf8TextDRgba32(@Self, @AOrigin, @AFont, PUTF8Char(AText), Length(AText), AStyle));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TBLRgba64);
begin
  _BLCheck(_blContextFillUtf8TextDRgba64(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, AStyle.Value));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TBLRgba32);
begin
  _BLCheck(_blContextFillUtf8TextDRgba32(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, AStyle.Value));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TBLRgba);
begin
  var Style: TBLVar := AStyle;
  _BLCheck(_blContextFillUtf8TextDExt(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, @Style));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AView: TBLStringView);
begin
  _BLCheck(_blContextFillUtf8TextD(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TBLVar);
begin
  _BLCheck(_blContextFillUtf8TextDExt(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, @AStyle));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TBLGradient);
begin
  _BLCheck(_blContextFillUtf8TextDExt(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, @AStyle));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TBLPattern);
begin
  _BLCheck(_blContextFillUtf8TextDExt(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, @AStyle));
end;

procedure TBLContext.StrokeUtf8Text(const AOrigin: TBLPoint;
  const AFont: TBLFont; const AView: TBLStringView; const AStyle: TAlphaColor);
begin
  _BLCheck(_blContextFillUtf8TextDRgba32(@Self, @AOrigin, @AFont, Pointer(AView.FData), AView.FCount, AStyle));
end;

procedure TBLContext.SwapStyles(const AMode: TBLContextStyleSwapMode);
begin
  _BLCheck(_blContextSwapStyles(@Self, Ord(AMode)));
end;

procedure TBLContext.Translate(const AP: TBLPointI);
begin
  var P := BLPoint(AP.X, AP.Y);
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.Translate), @P));
end;

procedure TBLContext.UserToMeta;
begin
  _BLCheck(_blContextUserToMeta(@Self));
end;

procedure TBLContext.Translate(const AP: TBLPoint);
begin
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.Translate), @AP));
end;

procedure TBLContext.Translate(const AX, AY: Double);
begin
  var P := BLPoint(AX, AY);
  _BLCheck(_blContextApplyTransformOp(@Self, Ord(TBLTransformOp.Translate), @P));
end;

{$ENDREGION 'Rendering'}

{$REGION 'Internal'}

{ _TBLGenericUtils<T> }

class function _TBLGenericUtils<T>.AreEqual(const ALeft, ARight: T): Boolean;
type
  UInt24 = packed record
    Lo: UInt16;
    Hi: UInt8;
  end;
type
  UInt128 = record
    Lo: UInt64;
    Hi: UInt64;
  end;
var
  Left8: UInt8 absolute ALeft;
  Right8: UInt8 absolute ARight;
  Left16: UInt16 absolute ALeft;
  Right16: UInt16 absolute ARight;
  Left24: UInt24 absolute ALeft;
  Right24: UInt24 absolute ARight;
  Left32: UInt32 absolute ALeft;
  Right32: UInt32 absolute ARight;
  Left64: UInt64 absolute ALeft;
  Right64: UInt64 absolute ARight;
  Left128: UInt128 absolute ALeft;
  Right128: UInt128 absolute ARight;
  LeftObj: TBLObjectCore absolute ALeft;
  RightObj: TBLObjectCore absolute ARight;
begin
  case SizeOf(T) of
    1: Result := (Left8 = Right8);
    2: Result := (Left16 = Right16);
    3: Result := (Left24.Lo = Right24.Lo) and (Left24.Hi = Right24.Hi);
    4: Result := (Left32 = Right32);
    8: Result := (Left64 = Right64);
   16: {case AType of
         TBLObjectType.Null,
         TBLObjectType.Pattern,
         TBLObjectType.Gradient,
         TBLObjectType.Image,
         TBLObjectType.Path,
         TBLObjectType.Font,
         TBLObjectType.FontFeatureSettings,
         TBLObjectType.FontVariationSettings,
         TBLObjectType.BitArray,
         TBLObjectType.BitSet,
         TBLObjectType.String,
         TBLObjectType.ArrayObject,
         TBLObjectType.Context,
         TBLObjectType.ImageCodec,
         TBLObjectType.ImageDecoder,
         TBLObjectType.ImageEncoder,
         TBLObjectType.FontFace,
         TBLObjectType.FontData,
         TBLObjectType.FontManager:

       else}
         Result := (Left128.Lo = Right24.Lo) and (Left128.Hi = Right24.Hi);
       {end;}
  else
    Result := CompareMem(@ALeft, @ARight, SizeOf(T));
  end;
end;

class procedure _TBLGenericUtils<T>.CopyToUnitialized(ADst: P;
  const ASrc: array of T; const AArrayType: TBLObjectType);
begin
  if (AArrayType = TBLObjectType.ArrayObject) then
  begin
    FillChar(ADst^, Length(ASrc) * SizeOf(T), 0); { TODO : Is this needed? }
    for var I := 0 to Length(ASrc) - 1 do
      ADst[I] := ASrc[I];
  end
  else
    Move(ASrc[0], ADst^, Length(ASrc) * SizeOf(T));
end;
{$ENDREGION 'Internal'}

{$REGION 'Runtime'}

{ TBLRuntimeBuildInfo }

function TBLRuntimeBuildInfo.GetCompilerInfo: String;
begin
  Result := String(UTF8String(PUTF8Char(@FCompilerInfo)));
end;

procedure TBLRuntimeBuildInfo.Reset;
begin
  FillChar(Self, SizeOf(Self), 0);
end;

{ TBLRuntimeSystemInfo }

function TBLRuntimeSystemInfo.GetCpuBrand: String;
begin
  Result := String(UTF8String(PUTF8Char(@FCpuBrand)));
end;

function TBLRuntimeSystemInfo.GetCpuVendor: String;
begin
  Result := String(UTF8String(PUTF8Char(@FCpuVendor)));
end;

procedure TBLRuntimeSystemInfo.Reset;
begin
  FillChar(Self, SizeOf(Self), 0);
end;

{ TBLRuntimeResourceInfo }

function TBLRuntimeResourceInfo.GetDynamicPipelineCount: NativeInt;
begin
  Result := FDynamicPipelineCount;
end;

function TBLRuntimeResourceInfo.GetVMBlockCount: NativeInt;
begin
  Result := FVMBlockCount;
end;

function TBLRuntimeResourceInfo.GetVMOverhead: NativeInt;
begin
  Result := FVMOverhead;
end;

function TBLRuntimeResourceInfo.GetVMReserved: NativeInt;
begin
  Result := FVMReserved;
end;

function TBLRuntimeResourceInfo.GetVMUsed: NativeInt;
begin
  Result := FVMUsed;
end;

function TBLRuntimeResourceInfo.GetZMBlockCount: NativeInt;
begin
  Result := FZMBlockCount;
end;

function TBLRuntimeResourceInfo.GetZMOverhead: NativeInt;
begin
  Result := FZMOverhead;
end;

function TBLRuntimeResourceInfo.GetZMReserved: NativeInt;
begin
  Result := FZMReserved;
end;

function TBLRuntimeResourceInfo.GetZMUsed: NativeInt;
begin
  Result := FZMUsed;
end;

procedure TBLRuntimeResourceInfo.Reset;
begin
  FillChar(Self, SizeOf(Self), 0);
end;

{ TBLRuntime }

class procedure TBLRuntime.Cleanup(const ACleanupFlags: TBLRuntimeCleanupFlags);
begin
  _BLCheck(_blRuntimeCleanup(Byte(ACleanupFlags)));
end;

class procedure TBLRuntime.Message(const AMsg: String;
  const AArgs: array of const);
begin
  Message(AMsg, AArgs);
end;

class procedure TBLRuntime.Message(const AMsg: String);
begin
  _BLCheck(_blRuntimeMessageOut(PUTF8Char(UTF8String(AMsg))));
end;

class function TBLRuntime.QueryBuildInfo: TBLRuntimeBuildInfo;
begin
  _BLCheck(_blRuntimeQueryInfo(0, @Result));
end;

class function TBLRuntime.QueryResourceInfo: TBLRuntimeResourceInfo;
begin
  _BLCheck(_blRuntimeQueryInfo(2, @Result));
end;

class function TBLRuntime.QuerySystemInfo: TBLRuntimeSystemInfo;
begin
  _BLCheck(_blRuntimeQueryInfo(1, @Result));
end;
{$ENDREGION 'Runtime'}

{$REGION 'Miscellaneous'}
{ TBLRandom }

class function TBLRandom.Create: TBLRandom;
begin
  Result.Reset(0);
end;

constructor TBLRandom.Create(const ASeed: UInt64);
begin
  Reset(ASeed);
end;

class operator TBLRandom.Equal(const ALeft, ARight: TBLRandom): Boolean;
begin
  Result := ALeft.Equals(ARight);
end;

function TBLRandom.Equals(const AOther: TBLRandom): Boolean;
begin
  Result := (FData[0] = AOther.FData[0]) and (FData[1] = AOther.FData[1]);
end;

function TBLRandom.NextDouble: Double;
begin
  Result := _blRandomNextDouble(@Self);
end;

function TBLRandom.NextUInt32: UInt32;
begin
  Result := _blRandomNextUInt32(@Self);
end;

function TBLRandom.NextUInt64: UInt64;
begin
  Result := _blRandomNextUInt64(@Self);
end;

class operator TBLRandom.NotEqual(const ALeft, ARight: TBLRandom): Boolean;
begin
  Result := not ALeft.Equals(ARight);
end;

procedure TBLRandom.Reset(const ASeed: UInt64);
begin
  _blRandomReset(@Self, ASeed);
end;

{$ENDREGION 'Miscellaneous'}

{$REGION 'Initialization'}
initialization
  Assert(SizeOf(TBLObjectCore) = 16);
  Assert(SizeOf(TBLImage) = 16);
  Assert(SizeOf(TBLStrokeOptions.TValues) = 8);
  _blRuntimeInit;
  BLSetExceptionErrorHandler;

finalization
  _blRuntimeShutdown;
{$ENDREGION 'Initialization'}

end.
